<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="Yie">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://yie0007.github.io/2023/10/07/springboot/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="SpringBootSpring Boot让您可以轻松地创建独立的、生产级别的Spring应用程序，并“直接运行”这些应用程序。SpringBoot为大量的第三方库添加了支持，能够做到开箱即用，简化大量繁琐配置，用最少的配置快速构建你想要的项目。在2023年，SpringBoot迎来了它的第三个大版本，随着SpringBoot 3的正式发布，整个生态也迎来了一次重大革新。 目前的最新版本以及对应的">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot">
<meta property="og:url" content="http://yie0007.github.io/2023/10/07/SpringBoot/index.html">
<meta property="og:site_name" content="Yie&#39;s Blog">
<meta property="og:description" content="SpringBootSpring Boot让您可以轻松地创建独立的、生产级别的Spring应用程序，并“直接运行”这些应用程序。SpringBoot为大量的第三方库添加了支持，能够做到开箱即用，简化大量繁琐配置，用最少的配置快速构建你想要的项目。在2023年，SpringBoot迎来了它的第三个大版本，随着SpringBoot 3的正式发布，整个生态也迎来了一次重大革新。 目前的最新版本以及对应的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2023/07/10/qnjY5MdRrOemFaQ.png">
<meta property="og:image" content="https://s2.loli.net/2022/11/22/hDGo7m9uBlgVn5A.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/11/V6lBrtp5QvbPyKk.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/11/Ol3Tqh21V8pjyLW.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/11/rzJblifUQomV4Ed.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/11/2P9wIJGdYluk8Hz.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/11/ZSAbwpurQKYDN6O.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/11/1YvbfCkoIWEBg4X.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/11/Hz1dVPqpe3vJsuR.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/11/7GELtUH3Kj5ld1w.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/13/2jrxoswhNpASPil.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/15/1dJaDbqlyUgnFBt.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/15/a4QbGBtMdZP6qec.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/15/StwKT5JLdG3Vacv.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/15/HfGt61A7OqVDesz.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/15/thnN29vz4fuYRFW.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/15/yWAUnZufkxH8CFp.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/15/E3nsZG7DcaSzOBY.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/15/HJWz7PIl6Sgk1nx.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/ygRp98mDKafXkw1.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/lTrXepw1c38IdSv.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/PSfpylWGCs3bzZj.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/oI6YjqUurZznw3C.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/2dToslkFHXxujOa.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/itQxlHTL5hsjIme.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/7bjyil3RgfuNLsZ.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/eycOMVRfZHmLnWX.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/CiNpxywXOso32kH.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/3hp6guwVt2aGKlQ.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/VDiRhqgNam8cleI.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/Fn5kxeECwhuoWBl.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/xK8sgwWoAIB61qk.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/qJiMVGeDnhf7HYu.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/Y8VBnQPL4mHit7N.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/lCjUpPYWhkm6eTq.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/fxzCEJbmluGn8jy.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/9JekL4VAB7EOdrf.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/MTu4GCmsogfaeRO.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/MGg1EHxtuvswV8d.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/o1bMPITBcgetVYa.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/HCZQndu2YPwINoS.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/sL56YdmgGblfFjo.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/sOyWQguFonJKXNw.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/n1FMADOiQCRcGw6.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/EibCc4sHWflywek.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/7JH6BzOhlUe9gkG.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/16/ygRp98mDKafXkw1.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/20/ijczpNxh4fXoQKv.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/20/xMeBEY3sdKVGmly.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/20/mq4Ut7BMI5XTDoN.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/XaoLIPrjDKzO9Tx.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/20/kABZVhJ8vjKSqzT.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/20/ksI3J5eidzTrvyL.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/20/TRHOWbop267Al4Q.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/21/uIBciLqFsH5tdDR.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/21/mioZaUk7Yj3QDxb.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/WnPEmdR2sDLuwGN.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/07/21/dUAkeOP9FfVarRL.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/21/fwAQGv43HdRnyI7.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/07/21/R7fhN5UtAOPFe4M.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/21/FxOfrnERhVPi8tu.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/21/lwaJUF3g2opbWZG.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/21/XMPLWB3N6VpHUkG.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/21/W1e8fFuUwSpi7Cg.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/21/l5Vkb9dgtJcyL4R.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/21/lGT4g5Y6Heqavsw.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/21/bIZ9D2cA7XsgSoU.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/21/SdDRqZPnNrkeKjG.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/21/pKMnwFZEOBmLXDy.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/21/CEdRz5wgaoxUjFJ.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/21/lxaBgGPubOkptCT.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/21/gZlbG9JDIa3kSMO.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/21/K6DufSwG3hdqPsr.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/22/8Zxp5PVjN7zfn6b.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/22/A7gTxwv6r89tKh3.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/22/DtLF21ue7RVMQPY.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/22/65snkmhyjFENTxt.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/22/GEWekp2IwMZhx5c.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/22/vt52ogbLp8YN1Im.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/22/yZpHd4wcikVxhta.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/23/EiMUuCjcKpnOmRb.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/23/KYULQNoFsHbm3zg.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/23/QVFEWknMdujomqi.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/23/1GpZuQUawM48eVq.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/24/L4PcVKpO2nmHG7e.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/24/Rf9BSVLvih1lOE2.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/07/Xu8lxYhKoJNr6it.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/24/4bThtMwA9XsP5uc.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/24/17dmiHXEG4rLO6W.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/24/L1O8m6auYc2IFWR.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/24/Hn7X5qeDf9htk6P.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/24/ID96yY7lkr5VsPS.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/24/4o76q5yNHkabuip.png">
<meta property="og:image" content="https://s2.loli.net/2023/07/24/cqEgnQOZtFp1w7o.png">
<meta property="article:published_time" content="2023-10-07T13:59:00.000Z">
<meta property="article:modified_time" content="2023-10-07T13:59:00.219Z">
<meta property="article:author" content="Yie">
<meta property="article:tag" content="SpringBoot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/07/10/qnjY5MdRrOemFaQ.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/favicon.png" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/favicon.png">
    <!--- Page Info-->
    
    <title>
        
            SpringBoot -
        
        Yie&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">

    <!--- Font Part-->
    
    
    
        <link href="https://puhuiti.oss-cn-hangzhou.aliyuncs.com/AlibabaPuHuiTi-2/AlibabaPuHuiTi-2-45-Light/AlibabaPuHuiTi-2-45-Light.ttf" rel="stylesheet">
    
    
        <link href="https://puhuiti.oss-cn-hangzhou.aliyuncs.com/AlibabaPuHuiTi-2/AlibabaPuHuiTi-2-45-Light/AlibabaPuHuiTi-2-45-Light.ttf" rel="stylesheet">
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    window.config = {"hostname":"yie0007.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/pexels-krivec-ales-547115.jpg","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null},"global":{"fonts":{"chinese":{"enable":true,"family":"AlibabaPuHuiTi","url":"https://puhuiti.oss-cn-hangzhou.aliyuncs.com/AlibabaPuHuiTi-2/AlibabaPuHuiTi-2-45-Light/AlibabaPuHuiTi-2-45-Light.ttf"},"english":{"enable":true,"family":"AlibabaPuHuiTi","url":"https://puhuiti.oss-cn-hangzhou.aliyuncs.com/AlibabaPuHuiTi-2/AlibabaPuHuiTi-2-45-Light/AlibabaPuHuiTi-2-45-Light.ttf"}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":true},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/img/pexels-krivec-ales-547115.jpg","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"Keep chasing","subtitle":{"text":["生命不息，攀登不止。","Life never stops, keep climbing."],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.5.0","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Docs":{"icon":"fa-light fa-books","submenus":{"Tags":"/tags","Categories":"/categories"}},"About":{"icon":"fa-regular fa-user","submenus":{"Me":"/about","Github":"https://github.com/Yie007"}}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"}}},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2023/10/13 22:31:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="swup-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                Yie&#39;s Blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        HOME
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        ARCHIVES
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-light fa-books"></i>
                                        
                                        DOCS&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a href="/tags">TAGS
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a href="/categories">CATEGORIES
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-user"></i>
                                        
                                        ABOUT&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a href="/about">ME
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://github.com/Yie007">GITHUB
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer w-full absolute top-0 left-0 bg-background-color">
        <ul class="drawer-navbar-list flex flex-col justify-start items-center">
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group " 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                HOME
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group " 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                ARCHIVES
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-light fa-books"></i>
                                
                                DOCS&nbsp;<i class="group-hover:rotate-180 transition-transform fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="drawer-navbar-item text-base flex justify-center items-center hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                <a class="py-0.5" href="/tags">TAGS</a>
                            </li>
                        
                            <li class="drawer-navbar-item text-base flex justify-center items-center hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                <a class="py-0.5" href="/categories">CATEGORIES</a>
                            </li>
                        
                    
            
                
                    <li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center">
                        <a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-user"></i>
                                
                                ABOUT&nbsp;<i class="group-hover:rotate-180 transition-transform fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="drawer-navbar-item text-base flex justify-center items-center hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                <a class="py-0.5" href="/about">ME</a>
                            </li>
                        
                            <li class="drawer-navbar-item text-base flex justify-center items-center hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                <a class="py-0.5" target="_blank" rel="noopener" href="https://github.com/Yie007">GITHUB</a>
                            </li>
                        
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container">
    <div class="article-content-container">

        <div class="article-title">
            
                <h1 class="article-title-regular">SpringBoot</h1>
            
            </div>
            
                    
        
        
            <div class="article-header flex flex-row gap-2 items-center">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/images/avatar.jpg">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">Yie</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv1</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-10-07 21:59</span>
        <span class="mobile">2023-10-07 21:59</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2023-10-07 21:59</span>
            <span class="mobile">2023-10-07 21:59</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/SpringBoot/">SpringBoot</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body">
            <h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p>Spring Boot让您可以轻松地创建独立的、生产级别的Spring应用程序，并“直接运行”这些应用程序。SpringBoot为大量的第三方库添加了支持，能够做到开箱即用，简化大量繁琐配置，用最少的配置快速构建你想要的项目。在2023年，SpringBoot迎来了它的第三个大版本，随着SpringBoot 3的正式发布，整个生态也迎来了一次重大革新。</p>
<p>目前的最新版本以及对应的维护情况：</p>
<p><img src="https://s2.loli.net/2023/07/10/qnjY5MdRrOemFaQ.png" alt="image-20230710174659973"></p>
<p>可以看到，曾经的SpringBoot 2.5版本将会在2023年8月底终止商业支持，届时将不会再对这类旧版本进行任何维护，因此，将我们的老版本SpringBoot项目进行升级已经迫在眉睫，目前最强的3.1正式版会维护到2025年中旬。</p>
<p>在3.X之后的变化相比2.X可以说是相当大，尤其是其生态下的SpringSecurity框架，旧版本项目在升级之后API已经完全发生改变；以及内置Tomcat服务器的升级，Servlet也升级到5以上，从<code>javax</code>全新升级到<code>jakarta</code>新包名；包括在3.X得到的大量新特性，如支持GraalVM打包本地镜像运行等；并且Java版本也强制要求为17版本。迁移到新版本不仅可以享受到免费维护支持，也可以感受Java17带来的全新体验。</p>
<p>介绍了这么多，我们首先还是来看看SpringBoot功能有哪些：</p>
<ul>
<li>能够创建独立的Spring应用程序</li>
<li>内嵌Tomcat、Jetty或Undertow服务器（无需单独部署WAR包，打包成Jar本身就是一个可以运行的应用程序）</li>
<li>提供一站式的“starter”依赖项，以简化Maven配置（需要整合什么框架，直接导对应框架的starter依赖）</li>
<li>尽可能自动配置Spring和第三方库（除非特殊情况，否则几乎不需要进行任何配置）</li>
<li>提供生产环境下相关功能，如指标、运行状况检查和外部化配置</li>
<li>没有任何代码生成，也不需要任何XML配置（XML是什么，好吃吗）</li>
</ul>
<p>SpringBoot是现在最主流的开发框架，国内的公司基本都在使用，也是我们出去找工作一定要会的框架，它提供了一站式的开发体验，能够大幅度提高我们的开发效率。</p>
<p><img src="https://s2.loli.net/2022/11/22/hDGo7m9uBlgVn5A.png" alt="image-20221122175719997"></p>
<p>在SSM阶段，当我们需要搭建一个基于Spring全家桶的Web应用程序时，我们不得不做大量的依赖导入和框架整合相关的Bean定义，光是整合框架就花费了我们大量的时间，但是实际上我们发现，整合框架其实基本都是一些固定流程，我们每创建一个新的Web应用程序，基本都会使用同样的方式去整合框架，我们完全可以将一些重复的配置作为约定，只要框架遵守这个约定，为我们提供默认的配置就好，这样就不用我们再去配置了，约定优于配置！</p>
<p>而SpringBoot正是将这些过程大幅度进行了简化，它可以自动进行配置，我们只需要导入对应的启动器（starter）依赖即可。</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>要感受SpringBoot带来的快速开发体验，我们就从创建一个项目开始。</p>
<h3 id="极速创建项目"><a href="#极速创建项目" class="headerlink" title="极速创建项目"></a>极速创建项目</h3><p>在过去，我们创建一个SSM项目，需要先导入各种依赖，进行大量的配置，而现在，有了SpringBoot，我们可以享受超快的项目创建体验，只需要前往官网进行少量配置就能快速为你生成一个SpringBoot项目模版：<a target="_blank" rel="noopener" href="https://start.spring.io/">https://start.spring.io/</a></p>
<p><img src="https://s2.loli.net/2023/07/11/V6lBrtp5QvbPyKk.png" alt="image-20230711124041648"></p>
<p>不过，为了方便，IDEA已经将这个工具集成到内部了，我们可以直接在IDEA中进行创建，效果是一样的，首先在新建项目阶段，选择 Spring Initializr 类型：</p>
<p><img src="https://s2.loli.net/2023/07/11/Ol3Tqh21V8pjyLW.png" alt="image-20230711124216094"></p>
<p>接着我们就可以配置项目的语言，并且选择项目需要使用的模块，这里我们简单选择两个依赖：</p>
<p><img src="https://s2.loli.net/2023/07/11/rzJblifUQomV4Ed.png" alt="image-20230711124332819"></p>
<p>如果一开始不清楚自己需要哪些模块，我们也可以后续自己手动添加对应模块的starter依赖，使用非常简单。</p>
<p>项目自动生成之后，可以看到Spring相关的依赖已经全部自动导入：</p>
<p><img src="https://s2.loli.net/2023/07/11/2P9wIJGdYluk8Hz.png" alt="image-20230711124949017"></p>
<p>并且也自动为我们创建了一个主类用于运行我们的SpringBoot项目：</p>
<p><img src="https://s2.loli.net/2023/07/11/ZSAbwpurQKYDN6O.png" alt="image-20230711125025254"></p>
<p>我们可以一键启动我们的SpringBoot项目：</p>
<p><img src="https://s2.loli.net/2023/07/11/1YvbfCkoIWEBg4X.png" alt="image-20230711125447493"></p>
<p>只不过由于我们没有添加任何有用的模块，也没有编写什么操作，因此启动之后项目就直接停止了。</p>
<h3 id="常用模块快速整合"><a href="#常用模块快速整合" class="headerlink" title="常用模块快速整合"></a>常用模块快速整合</h3><p>前面我们说了，SpringBoot的核心思想就是约定大于配置，能在一开始默认的就直接默认，不用我们自己来进行配置，我们只需要配置某些特殊的部分即可，这一部分我们就来详细体验一下。</p>
<p>我们来尝试将我们之前使用过的模块进行一下快速整合，可以看到在一开始的时候，我们没有勾选其他的依赖，因此这里只导入了最基本的<code>spring-boot-starter</code>依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>所有的SpringBoot依赖都是以starter的形式命名的，之后我们需要导入其他模块也是导入<code>spring-boot-starter-xxxx</code>这种名称格式的依赖。</p>
<p>首先我们还是从SpringMvc相关依赖开始。SpringBoot为我们提供了包含内置Tomcat服务器的Web模块，我们只需要导入依赖就能直接运行服务器：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们不需要进行任何配置，直接点击启动：</p>
<p><img src="https://s2.loli.net/2023/07/11/Hz1dVPqpe3vJsuR.png" alt="image-20230711133113516"></p>
<p>它真的做到了开箱即用，我们现在可以直接访问这个网站：</p>
<p><img src="https://s2.loli.net/2023/07/11/7GELtUH3Kj5ld1w.png" alt="image-20230711133224425"></p>
<p>可以看到成功响应了404页面，相比之前的大量配置，可以说方便了很多，我们到目前为止仅仅是导入了一个依赖，就可以做到直接启动我们的Web服务器并正常访问。</p>
<p>SpringBoot支持自动包扫描，我们不需要编写任何配置，直接在任意路径（但是不能跑到主类所在包外面去了）下创建的组件（如Controller、Service、Component、Configuration等）都可以生效，比如我们这里创建一个测试的Controller试试看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启之后，可以看到直接就能访问到，而这期间我们只是创建了对应的Controller却没有进行任何配置，这真的太方便了：</p>
<p><img src="https://s2.loli.net/2023/07/13/2jrxoswhNpASPil.png" alt="image-20230713225914578"></p>
<p>包括一个对象现在也可以直接以JSON形式返回给客户端，无需任何配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> sid;</span><br><span class="line">    String name;</span><br><span class="line">    String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Student <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student.setName(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    student.setSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    student.setSid(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![image-20230715171140388](&#x2F;Users&#x2F;nagocoler&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230715171140388.png)</p>
<p>最后浏览器能够直接得到<code>application/json</code>的响应数据，就是这么方便，这都得归功于SpringBoot对应的start帮助我们自动将处理JSON数据的Converter进行了配置，我们不需要再单独去配置Converter了。不过SpringBoot官方默认使用的是<code>Jackson</code>和<code>Gson</code> 的HttpMessageConverter来进行配置，不是我们之前教程中使用的FastJSON框架。</p>
<p>我们最后来看看这个Start包含了哪些依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>里面包含了以下内容：</p>
<ul>
<li>spring-boot-starter  基础依赖starter</li>
<li>spring-boot-starter-json  配置JSON转换的starter</li>
<li>spring-boot-starter-tomcat   内置Tomcat服务器</li>
<li>spring-web、spring-webmvc    不用多说了吧，之前已经讲过了</li>
</ul>
<p>如果需要像之前一样添加WebMvc的配置类，方法是一样的，直接创建即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只需要添加Configuration用于注册配置类，不需要其他任何注解，已经自动配置好了</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">HandlerInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> HandlerInterceptor.<span class="built_in">super</span>.preHandle(request, response, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在SSM阶段编写的大量配置，到现在已经彻底不需要了。</p>
<p>同样的，我们来看看SpringSecurity框架如何进行整合，也是非常简单，我们只需要直接导入即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>导入完成后，再次访问网站，就可以看到熟悉的登录界面了：</p>
<p><img src="https://s2.loli.net/2023/07/15/1dJaDbqlyUgnFBt.png" alt="image-20230715182059681"></p>
<p>我们没有进行任何配置，而是对应的Starter帮助我们完成了默认的配置，并且在启动时，就已经帮助我们配置了一个随机密码的用户可以直接登录使用：</p>
<p><img src="https://s2.loli.net/2023/07/15/a4QbGBtMdZP6qec.png" alt="image-20230715182323772"></p>
<p>密码直接展示在启动日志中，而默认用户名称为<code>user</code>我们可以直接登录：</p>
<p><img src="https://s2.loli.net/2023/07/15/StwKT5JLdG3Vacv.png" alt="image-20230715182448770"></p>
<p>同样没有进行任何配置，我们只需要添加对应的starter就能做到开箱即用，并且内置一套默认配置，自动帮助我们创建一个测试用户，方便我们快速搭建项目，同样的，如果要进行额外配置，我们只需要直接添加配置类即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依然只需要Configuration注解即可，不需要其他配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//配置方式跟之前SSM阶段是一样的</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> http</span><br><span class="line">                .authorizeHttpRequests(auth -&gt; &#123;</span><br><span class="line">                    auth.anyRequest().authenticated();</span><br><span class="line">                &#125;)</span><br><span class="line">                .formLogin(conf -&gt; &#123;</span><br><span class="line">                    conf.loginPage(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">                    conf.loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>);</span><br><span class="line">                    conf.defaultSuccessUrl(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                    conf.permitAll();</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，我们也可以快速整合之前使用的模版引擎，比如Thymeleaf框架，直接上对应的Starter即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在默认情况下，我们需要在<code>resources</code>目录下创建两个目录：</p>
<p><img src="https://s2.loli.net/2023/07/15/HfGt61A7OqVDesz.png" alt="image-20230715225833930"></p>
<p>这两个目录是默认配置下需要的，名字必须是这个：</p>
<ul>
<li><code>templates</code> - 所有模版文件都存放在这里</li>
<li><code>static</code> - 所有静态资源都存放在这里</li>
</ul>
<p>我们只需要按照上面的样子放入我们之前的前端模版，就可以正常使用模版引擎了，同样不需要进入任何的配置，当然，如果各位小伙伴觉得不方便，我们后续也可以进行修改。</p>
<p>我们不需要在controller中写任何内容，它默认会将index.html作为首页文件，我们直接访问服务器地址就能展示首页了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">		<span class="comment">//什么都不用写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/07/15/thnN29vz4fuYRFW.png" alt="image-20230715230152860"></p>
<p>这都是得益于约定大于配置的思想，开箱即用的感觉就是这么舒服，不过肯定有小伙伴好奇那现在要怎么才能像之前一样自己写呢，这个肯定还是跟之前一样的呗，该怎么写就怎么写。</p>
<p>我们最后再来看看Mybatis如何进行整合，同样只需要一个starter即可，这里顺便把MySQL的驱动加上：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意这里的<code>mybatis-spring-boot-starter</code>版本需要我们自己指定，因为它没有被父工程默认管理。</p>
<p><img src="https://s2.loli.net/2023/07/15/yWAUnZufkxH8CFp.png" alt="image-20230715231142842"></p>
<p>启动服务器时，我们发现这里出现了问题，导致无法启动。这是因为我们没有配置数据源导致的，虽然SpringBoot采用约定大于配置的思想，但是数据库信息只有我们自己清楚，而且变化多样，根本没有办法提前完成约定，所以说这里我们还是需要再配置文件中编写，至于如何编写配置文件我们会在下一节中进行讲解。</p>
<h3 id="自定义运行器"><a href="#自定义运行器" class="headerlink" title="自定义运行器"></a>自定义运行器</h3><p>在项目中，可能会遇到这样一个问题：我们需要在项目启动完成之后，紧接着执行一段代码。</p>
<p>我们可以编写自定义的ApplicationRunner来解决，它会在项目启动完成后执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRunner</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然也可以使用CommandLineRunner，它也支持使用@Order或是实现Ordered接口来支持优先级执行。</p>
<p>这个功能比较简单，不多做介绍了。</p>
<h3 id="配置文件介绍"><a href="#配置文件介绍" class="headerlink" title="配置文件介绍"></a>配置文件介绍</h3><p>前面我们已经体验了SpringBoot带来的快捷开发体验，不过我们发现有些东西还是需要我们自己来编写配置才可以，不然SpringBoot项目无法正常启动，我们来看看如何编写配置。我们可以直接在<code>application.properties</code>中进行配置编写，它是整个SpringBoot的配置文件，比如要修改服务器的默认端口：</p>
<p><img src="https://s2.loli.net/2023/07/15/E3nsZG7DcaSzOBY.png" alt="image-20230715232124133"></p>
<p>这些配置其实都是各种Starter提供的，部分配置在Starter中具有默认值，我们即使不配置也会使用默认值，比如这里的8080就是我们服务器的默认端口，我们也可以手动修改它，来变成我们需要的。</p>
<p>除了配置已经存在的选项，我们也可以添加自定义的配置，来方便我们程序中使用，比如我们这里创建一个测试数据：</p>
<p><img src="https://s2.loli.net/2023/07/15/HJWz7PIl6Sgk1nx.png" alt="image-20230715234130924"></p>
<p>我们可以直接在程序中通过<code>@Value</code>来访问到（跟我们之前Spring基础篇讲的是一样的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;test.data&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> data;   <span class="comment">//直接从配置中去取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件除了使用<code>properties</code>格式以外，还有一种叫做<code>yaml</code>格式，它的语法如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">一级目录:</span></span><br><span class="line">    <span class="string">二级目录:</span></span><br><span class="line">      <span class="string">三级目录1:</span> <span class="string">值</span></span><br><span class="line">      <span class="string">三级目录2:</span> <span class="string">值</span></span><br><span class="line">      <span class="string">三级目录List:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">元素1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">元素2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">元素3</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，每一级目录都是通过缩进（不能使用Tab，只能使用空格）区分，并且键和值之间需要添加冒号+空格来表示。</p>
<p>SpringBoot也支持这种格式的配置文件，我们可以将<code>application.properties</code>修改为<code>application.yml</code>或是<code>application.yaml</code>来使用YAML语法编写配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>现在我们来尝试为之前的数据源进行一下配置，这样才能正常启动我们的服务器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:3306/test</span></span><br><span class="line">    username: root</span><br><span class="line">    password: <span class="number">123456</span></span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>

<p>配置完成后，我们就可以正常启动服务器了。</p>
<p>这里我们接续来测试一下MyBatis的配置，想要在SpringBoot中使用Mybatis也很简单，不需要进行任何配置，我们直接编写Mapper即可，这里我们随便创建一个表试试看：</p>
<p><img src="https://s2.loli.net/2023/07/16/ygRp98mDKafXkw1.png" alt="image-20230716000431492"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    String email;</span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，在SpringBoot整合之后，我们只需要直接在配置类上添加<code>@MapperScan</code>注解即可，跟我们之前的使用方法是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>不过，为了方便，我们也可以直接为需要注册为Mapper的接口添加<code>@Mapper</code>注解，来表示这个接口作为Mapper使用：</p>
<p><img src="https://s2.loli.net/2023/07/16/lTrXepw1c38IdSv.png" alt="image-20230716000755756"></p>
<p>这样，即使不配置MapperScan也能直接注册为Mapper正常使用，是不是感觉特别方便？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mapper.findUserById(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问接口测试一下：</p>
<p><img src="https://s2.loli.net/2023/07/16/PSfpylWGCs3bzZj.png" alt="image-20230716001311316"></p>
<p>最后，我们再来介绍一下常见的配置项，比如SpringSecurity和SpringBootMvc配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="comment">#  Spring Mvc相关配置</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/static/**</span>   <span class="comment">#静态资源解析地址</span></span><br><span class="line">  <span class="comment"># Spring Security 相关配置</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">filter:</span></span><br><span class="line">      <span class="attr">order:</span> <span class="number">-100</span> <span class="comment">#Spring Security 过滤器优先级</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&#x27;admin&#x27;</span>   <span class="comment">#默认登录用户名</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&#x27;123456&#x27;</span>   <span class="comment">#默认登录密码</span></span><br><span class="line">      <span class="attr">roles:</span>    <span class="comment">#默认用户的角色</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">admin</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">user</span></span><br></pre></td></tr></table></figure>

<p>更多的配置我们可以在后续的学习中继续认识，这些配置其实都是由Starter提供的，确实极大程度简化了我们对于框架的使用。</p>
<h3 id="轻松打包运行"><a href="#轻松打包运行" class="headerlink" title="轻松打包运行"></a>轻松打包运行</h3><p>前面我们介绍了一个SpringBoot如何快捷整合其他框架以及进行配置编写，我们接着来看如何打包我们的SpringBoot项目使其可以正常运行，SpringBoot提供了一个非常便捷的打包插件，能够直接将我们的项目打包成一个jar包，然后使用java命令直接运行，我们直接点击Maven中的：</p>
<p><img src="https://s2.loli.net/2023/07/16/oI6YjqUurZznw3C.png" alt="image-20230716155322915"></p>
<p>点击之后项目会自动打包构建：</p>
<p><img src="https://s2.loli.net/2023/07/16/2dToslkFHXxujOa.png" alt="image-20230716155412252"></p>
<p>打包完成之后，会在target目录下出现一个打包好的jar文件：</p>
<p><img src="https://s2.loli.net/2023/07/16/itQxlHTL5hsjIme.png" alt="image-20230716155622849"></p>
<p>我们可以直接在命令行中运行这个程序，在CMD中进入到target目录，然后输入：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>这样就可以直接运行了：</p>
<p><img src="https://s2.loli.net/2023/07/16/7bjyil3RgfuNLsZ.png" alt="image-20230716155834628"></p>
<p>现在，我们的SpringBoot项目就可以快速部署到任何计算机了，只要能够安装JRE环境，都可以通过命令一键运行。</p>
<p>当然，可能也会有小伙伴好奇，怎么才能像之前一样在我们的Tomcat服务器中运行呢？我们也可以将其打包为War包的形式部署到我们自己环境中的Tomcat服务器或是其他任何支持Servlet的服务器中，但是这种做法相对比较复杂，不太推荐采用这种方式进行项目部署，不过我们这里还是介绍一下。</p>
<p>首先我们需要排除掉<code>spring-boot-starter-web</code>中自带的Tomcat服务器依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后自行添加Servlet依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后将打包方式修改为war包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着我们需要修改主类，将其继承SpringBoot需要的Initializer（又回到SSM阶段那烦人的配置了，所以说一点不推荐这种部署方式）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> <span class="keyword">extends</span> <span class="title class_">SpringBootServletInitializer</span> &#123;  <span class="comment">//继承专用的初始化器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//重写configure方法，完成启动类配置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> SpringApplicationBuilder <span class="title function_">configure</span><span class="params">(SpringApplicationBuilder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.sources(DemoApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们再次运行Maven 的package指令就可以打包为war包了：</p>
<p><img src="https://s2.loli.net/2023/07/16/eycOMVRfZHmLnWX.png" alt="image-20230716161834726"></p>
<p>我们可以直接将其部署到Tomcat服务器中（如何部署已经在JavaWeb篇介绍过了）</p>
<p><img src="https://s2.loli.net/2023/07/16/CiNpxywXOso32kH.png" alt="image-20230716161921180"></p>
<p>接着启动服务器就能正常访问了：</p>
<p><img src="https://s2.loli.net/2023/07/16/3hp6guwVt2aGKlQ.png" alt="image-20230716162008831"></p>
<p><img src="https://s2.loli.net/2023/07/16/VDiRhqgNam8cleI.png" alt="image-20230716162030102"></p>
<p>如果各位小伙伴需要在IDEA中进行调试运行，我们需要像之前一样配置一个Tomcat运行环境：</p>
<p><img src="https://s2.loli.net/2023/07/16/Fn5kxeECwhuoWBl.png" alt="image-20230716162119751"></p>
<p>这样就可以跟之前一样使用外部Tomcat服务器了：</p>
<p><img src="https://s2.loli.net/2023/07/16/xK8sgwWoAIB61qk.png" alt="image-20230716162156347"></p>
<p>最后，我们需要特别介绍一下新的特性，在SpringBoot3之后，特别对GraalVM进行了支持：</p>
<blockquote>
<p>GraalVM 是一种通用的虚拟机，最初由 Oracle 开发。它支持多种编程语言（例如 Java、JavaScript、Python 等），可以在不同的环境中运行，并提供高性能和低内存消耗。</p>
<p>GraalVM的核心是一个即时编译器，它能够将各种语言的代码直接编译成本地机器码，以获得更高的性能。此外，GraalVM 还提供了一个强大的运行时环境，包括垃圾回收器、即时编译器、线程管理器等，可以提供更好的性能和可扩展性。</p>
<p>GraalVM 的一个重要特性是它的跨语言互操作性。GraalVM 可以使不同语言之间的互操作更加容易。例如，你可以在 Java 代码中直接调用 JavaScript 函数，或者在 JavaScript 代码中直接调用 Java 类。这使得在不同语言之间共享和复用代码变得更加容易。</p>
<p>总的来说，GraalVM 是一个开创性的技术，可以提供出色的性能和灵活性，同时也为多语言开发提供了更好的支持。它是一个非常有潜力的工具，可以用于构建高效的应用程序和解决方案。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/07/16/qJiMVGeDnhf7HYu.png" alt="image-20230716160131837"></p>
<p>简而言之，我们的SpringBoot项目除了打包为传统的Jar包基于JVM运行之外，我们也可以将其直接编译为操作系统原生的程序来进行使用（这样会大幅提升程序的运行效率，但是由于编译为操作系统原生程序，这将无法支持跨平台）</p>
<p>首先我们需要安装GraalVM的环境才可以，这跟安装普通JDK的操作是完全一样的，下载地址：<a target="_blank" rel="noopener" href="https://github.com/graalvm/graalvm-ce-builds/releases/tag/jdk-17.0.7">https://github.com/graalvm/graalvm-ce-builds/releases/tag/jdk-17.0.7</a></p>
<p><img src="https://s2.loli.net/2023/07/16/Y8VBnQPL4mHit7N.png" alt="image-20230716162524422"></p>
<p>下载好对应系统架构的GraalVM环境之后，就可以安装部署了，首先我们需要为GraalVM配置环境变量，将GRAALVM_HOME作为环境变量指向你的安装目录的bin目录下，接着我们就可以开始进行打包了（注意，SpringBoot项目必须在创建的时候添加了Native支持才可以，否则无法正常打包）</p>
<p>注意，一定要将<code>GRAALVM_HOME</code>配置到环境变量中，否则会报错：</p>
<p><img src="https://s2.loli.net/2023/07/16/lCjUpPYWhkm6eTq.png" alt="image-20230716163645399"></p>
<p>一切无误后，我们直接在IDEA中或是命令行中输入：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -Pnative -DskipTests native:compile</span><br></pre></td></tr></table></figure>

<p>接着会自动安装<code>native-image</code>组件，然后进行本地镜像的编译（建议挂梯，不然卡一天都下不动）</p>
<p><img src="https://s2.loli.net/2023/07/16/fxzCEJbmluGn8jy.png" alt="image-20230716164025545"></p>
<p>编译过程中比较消耗资源，建议CPU选择6核及以上，不然速度会很慢，编译完成之后如下图：</p>
<p><img src="https://s2.loli.net/2023/07/16/9JekL4VAB7EOdrf.png" alt="image-20230716164317582"></p>
<p>这样一个系统原生的SpringBoot项目就打包好了，我们可以直接运行这个程序：</p>
<p><img src="https://s2.loli.net/2023/07/16/MTu4GCmsogfaeRO.png" alt="image-20230716165228609"></p>
<p>不过由于Mybatis目前不支持Native-Image，所以只能期待有朝一日这些框架都能够完整支持原生镜像，让我们的程序运行效率更上一层楼。</p>
<p>至此，关于SpringBoot的快速上手教程就全部结束了，其实只要SSM阶段学的扎实，到了Boot阶段之后也是轻轻松松，下一部分我们将隆重介绍一下SpringBoot的日志模块。</p>
<hr>
<h2 id="日志系统介绍"><a href="#日志系统介绍" class="headerlink" title="日志系统介绍"></a>日志系统介绍</h2><p>SpringBoot为我们提供了丰富的日志系统，它几乎是开箱即用的。我们在之前学习SSM时，如果不配置日志，就会报错，但是到了SpringBoot阶段之后似乎这个问题就不见了，日志打印得也非常统一，这是为什么呢？</p>
<h3 id="日志门面和日志实现"><a href="#日志门面和日志实现" class="headerlink" title="日志门面和日志实现"></a>日志门面和日志实现</h3><p>我们首先要区分一下，什么是日志门面（Facade）什么是日志实现，我们之前学习的JUL实际上就是一种日志实现，我们可以直接使用JUL为我们提供的日志框架来规范化打印日志。</p>
<p>而日志门面，如Slf4j，是把不同的日志系统的实现进行了具体的抽象化，只提供了统一的日志使用接口，使用时只需要按照其提供的接口方法进行调用即可，由于它只是一个接口，并不是一个具体的可以直接单独使用的日志框架，所以最终日志的格式、记录级别、输出方式等都要通过接口绑定的具体的日志系统来实现，这些具体的日志系统就有log4j、logback、java.util.logging等，它们才实现了具体的日志系统的功能。</p>
<p>日志门面和日志实现就像JDBC和数据库驱动一样，一个是画大饼的，一个是真的去做饼的。</p>
<p><img src="https://s2.loli.net/2023/03/06/MGg1EHxtuvswV8d.png" alt="img"></p>
<p>但是现在有一个问题就是，不同的框架可能使用了不同的日志框架，如果这个时候出现众多日志框架并存的情况，我们现在希望的是所有的框架一律使用日志门面（Slf4j）进行日志打印，这时该怎么去解决？我们不可能将其他框架依赖的日志框架替换掉，直接更换为Slf4j吧，这样显然不现实。</p>
<p>这时，可以采取类似于偷梁换柱的做法，只保留不同日志框架的接口和类定义等关键信息，而将实现全部定向为Slf4j调用。相当于有着和原有日志框架一样的外壳，对于其他框架来说依然可以使用对应的类进行操作，而具体如何执行，真正的内心已经是Slf4j的了。</p>
<p><img src="https://s2.loli.net/2023/03/06/o1bMPITBcgetVYa.png" alt="img"></p>
<p>所以，SpringBoot为了统一日志框架的使用，做了这些事情：</p>
<ul>
<li>直接将其他依赖以前的日志框架剔除</li>
<li>导入对应日志框架的Slf4j中间包</li>
<li>导入自己官方指定的日志实现，并作为Slf4j的日志实现层</li>
</ul>
<h3 id="打印项目日志信息"><a href="#打印项目日志信息" class="headerlink" title="打印项目日志信息"></a>打印项目日志信息</h3><p>SpringBoot使用的是Slf4j作为日志门面，Logback（<a target="_blank" rel="noopener" href="http://logback.qos.ch/">Logback</a> 是log4j 框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J）作为日志实现，对应的依赖为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此依赖已经被包含了，所以我们如果需要打印日志，可以像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(TestController.class);</span><br><span class="line">    logger.info(<span class="string">&quot;用户访问了一次测试数据&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mapper.findUserById(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们使用了Lombok，所以直接一个注解也可以搞定哦：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainController</span> &#123;</span><br><span class="line"></span><br><span class="line">  	<span class="meta">@ResponseBody</span></span><br><span class="line">		<span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    		log.info(<span class="string">&quot;用户访问了一次测试数据&quot;</span>);</span><br><span class="line">    		<span class="keyword">return</span> mapper.findUserById(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">  </span><br><span class="line">  	...</span><br></pre></td></tr></table></figure>

<p>日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，SpringBoot默认只会打印INFO以上级别的信息，效果如下，也是使用同样的格式打印在控制台的：</p>
<p><img src="https://s2.loli.net/2023/07/16/HCZQndu2YPwINoS.png" alt="image-20230716171120646"></p>
<h3 id="配置Logback日志"><a href="#配置Logback日志" class="headerlink" title="配置Logback日志"></a>配置Logback日志</h3><p>Logback官网：<a target="_blank" rel="noopener" href="https://logback.qos.ch/">https://logback.qos.ch</a></p>
<p>和JUL一样，Logback也能实现定制化，我们可以编写对应的配置文件，SpringBoot推荐将配置文件名称命名为<code>logback-spring.xml</code>表示这是SpringBoot下Logback专用的配置，可以使用SpringBoot 的高级Proﬁle功能，它的内容类似于这样：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最外层由<code>configuration</code>包裹，一旦编写，那么就会替换默认的配置，所以如果内部什么都不写的话，那么会导致我们的SpringBoot项目没有配置任何日志输出方式，控制台也不会打印日志。</p>
<p>我们接着来看如何配置一个控制台日志打印，我们可以直接导入并使用SpringBoot为我们预设好的日志格式，在<code>org/springframework/boot/logging/logback/defaults.xml</code>中已经帮我们把日志的输出格式定义好了，我们只需要设置对应的<code>appender</code>即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">included</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">&quot;clr&quot;</span> <span class="attr">converterClass</span>=<span class="string">&quot;org.springframework.boot.logging.logback.ColorConverter&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">&quot;wex&quot;</span> <span class="attr">converterClass</span>=<span class="string">&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">&quot;wEx&quot;</span> <span class="attr">converterClass</span>=<span class="string">&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE_LOG_PATTERN&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE_LOG_CHARSET&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;CONSOLE_LOG_CHARSET:-$&#123;file.encoding:-UTF-8&#125;&#125;&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_LOG_PATTERN&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;FILE_LOG_PATTERN:-%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125; $&#123;LOG_LEVEL_PATTERN:-%5p&#125; $&#123;PID:- &#125; --- [%t] %-40.40logger&#123;39&#125; : %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_LOG_CHARSET&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;FILE_LOG_CHARSET:-$&#123;file.encoding:-UTF-8&#125;&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.catalina.startup.DigesterFactory&quot;</span> <span class="attr">level</span>=<span class="string">&quot;ERROR&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.catalina.util.LifecycleBase&quot;</span> <span class="attr">level</span>=<span class="string">&quot;ERROR&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.sshd.common.util.SecurityUtils&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.tomcat.util.net.NioSelectorPool&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.eclipse.jetty.util.component.AbstractLifeCycle&quot;</span> <span class="attr">level</span>=<span class="string">&quot;ERROR&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.hibernate.validator.internal.util.Version&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework.boot.actuate.endpoint.jmx&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">included</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>导入后，我们利用预设的日志格式创建一个控制台日志打印：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  导入其他配置文件，作为预设  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  Appender作为日志打印器配置，这里命名随意  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  ch.qos.logback.core.ConsoleAppender是专用于控制台的Appender  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>$&#123;CONSOLE_LOG_CHARSET&#125;<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  指定日志输出级别，以及启用的Appender，这里就使用了我们上面的ConsoleAppender  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置完成后，我们发现控制台已经可以正常打印日志信息了。</p>
<p>接着我们来看看如何开启文件打印，我们只需要配置一个对应的Appender即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  ch.qos.logback.core.rolling.RollingFileAppender用于文件日志记录，它支持滚动  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>$&#123;FILE_LOG_CHARSET&#125;<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  自定义滚动策略，防止日志文件无限变大，也就是日志文件写到什么时候为止，重新创建一个新的日志文件开始写  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  文件保存位置以及文件命名规则，这里用到了%d&#123;yyyy-MM-dd&#125;表示当前日期，%i表示这一天的第N个日志  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>log/%d&#123;yyyy-MM-dd&#125;-spring-%i.log<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  到期自动清理日志文件  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cleanHistoryOnStart</span>&gt;</span>true<span class="tag">&lt;/<span class="name">cleanHistoryOnStart</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  最大日志保留时间  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>7<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  最大单个日志文件大小  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  指定日志输出级别，以及启用的Appender，这里就使用了我们上面的ConsoleAppender  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置完成后，我们可以看到日志文件也能自动生成了。</p>
<p>我们也可以魔改官方提供的日志格式，官方文档：<a target="_blank" rel="noopener" href="https://logback.qos.ch/manual/layouts.html">https://logback.qos.ch/manual/layouts.html</a></p>
<p>这里需要提及的是MDC机制，Logback内置的日志字段还是比较少，如果我们需要打印有关业务的更多的内容，包括自定义的一些数据，需要借助logback MDC机制，MDC为“Mapped Diagnostic Context”（映射诊断上下文），即将一些运行时的上下文数据通过logback打印出来；此时我们需要借助org.sl4j.MDC类。</p>
<p>比如我们现在需要记录是哪个用户访问我们网站的日志，只要是此用户访问我们网站，都会在日志中携带该用户的ID，我们希望每条日志中都携带这样一段信息文本，而官方提供的字段无法实现此功能，这时就需要使用MDC机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">test</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">   MDC.put(<span class="string">&quot;reqId&quot;</span>, request.getSession().getId());</span><br><span class="line">   log.info(<span class="string">&quot;用户访问了一次测试数据&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> mapper.findUserById(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，我们就可以向日志中传入自定义参数了，我们日志中添加这样一个占位符<code>%X&#123;键值&#125;</code>，名字保持一致：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%clr([%X&#123;reqId&#125;])&#123;faint&#125; </span><br></pre></td></tr></table></figure>

<p>这样当我们向MDC中添加信息后，只要是当前线程（本质是ThreadLocal实现）下输出的日志，都会自动替换占位符。</p>
<h3 id="自定义Banner展示"><a href="#自定义Banner展示" class="headerlink" title="自定义Banner展示"></a>自定义Banner展示</h3><p>我们在之前发现，实际上Banner部分和日志部分是独立的，SpringBoot启动后，会先打印Banner部分，那么这个Banner部分是否可以自定义呢？答案是可以的。</p>
<p>我们可以直接来配置文件所在目录下创建一个名为<code>banner.txt</code>的文本文档，内容随便你：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//                          _ooOoo_                               //</span><br><span class="line">//                         o8888888o                              //</span><br><span class="line">//                         88&quot; . &quot;88                              //</span><br><span class="line">//                         (| ^_^ |)                              //</span><br><span class="line">//                         O\  =  /O                              //</span><br><span class="line">//                      ____/`---&#x27;\____                           //</span><br><span class="line">//                    .&#x27;  \\|     |//  `.                         //</span><br><span class="line">//                   /  \\|||  :  |||//  \                        //</span><br><span class="line">//                  /  _||||| -:- |||||-  \                       //</span><br><span class="line">//                  |   | \\\  -  /// |   |                       //</span><br><span class="line">//                  | \_|  &#x27;&#x27;\---/&#x27;&#x27;  |   |                       //</span><br><span class="line">//                  \  .-\__  `-`  ___/-. /                       //</span><br><span class="line">//                ___`. .&#x27;  /--.--\  `. . ___                     //</span><br><span class="line">//              .&quot;&quot; &#x27;&lt;  `.___\_&lt;|&gt;_/___.&#x27;  &gt;&#x27;&quot;&quot;.                  //</span><br><span class="line">//            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //</span><br><span class="line">//            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //</span><br><span class="line">//      ========`-.____`-.___\_____/___.-`____.-&#x27;========         //</span><br><span class="line">//                           `=---=&#x27;                              //</span><br><span class="line">//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //</span><br><span class="line">//             佛祖保佑          永无BUG         永不修改             //</span><br></pre></td></tr></table></figure>

<p>可以使用在线生成网站进行生成自己的个性Banner：<a target="_blank" rel="noopener" href="https://www.bootschool.net/ascii">https://www.bootschool.net/ascii</a></p>
<p>我们甚至还可以使用颜色代码来为文本切换颜色：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;AnsiColor.BRIGHT_GREEN&#125;  //绿色</span><br></pre></td></tr></table></figure>

<p>也可以获取一些常用的变量信息：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;AnsiColor.YELLOW&#125; 当前 Spring Boot 版本：$&#123;spring-boot.version&#125;</span><br></pre></td></tr></table></figure>

<p>前面忘了，后面忘了，狠狠赚一笔！</p>
<hr>
<h2 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h2><p>在日常开发中，我们项目会有多个环境。例如开发环境（develop）也就是我们研发过程中疯狂敲代码修BUG阶段，生产环境（production ）项目开发得差不多了，可以放在服务器上跑了。不同的环境下，可能我们的配置文件也存在不同，但是我们不可能切换环境的时候又去重新写一次配置文件，所以我们可以将多个环境的配置文件提前写好，进行自由切换。</p>
<p>由于SpringBoot只会读取<code>application.properties</code>或是<code>application.yml</code>文件，那么怎么才能实现自由切换呢？SpringBoot给我们提供了一种方式，我们可以通过配置文件指定：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>

<p>接着我们分别创建两个环境的配置文件，<code>application-dev.yml</code>和<code>application-prod.yml</code>分别表示开发环境和生产环境的配置文件，比如开发环境我们使用的服务器端口为8080，而生产环境下可能就需要设置为80或是443端口，那么这个时候就需要不同环境下的配置文件进行区分：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>这样我们就可以灵活切换生产环境和开发环境下的配置文件了。</p>
<p>SpringBoot自带的Logback日志系统也是支持多环境配置的，比如我们想在开发环境下输出日志到控制台，而生产环境下只需要输出到文件即可，这时就需要进行环境配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;prod&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意<code>springProfile</code>是区分大小写的！</p>
<p>那如果我们希望生产环境中不要打包开发环境下的配置文件呢，我们目前虽然可以切换开发环境，但是打包的时候依然是所有配置文件全部打包，这样总感觉还欠缺一点完美，因此，打包的问题就只能找Maven解决了，Maven也可以设置多环境：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--分别设置开发，生产环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">environment</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 生产环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>false<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">environment</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着，我们需要根据环境的不同，排除其他环境的配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--排除配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--先排除所有的配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--使用通配符，当然可以定义多个exclude标签进行排除--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>application*.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--根据激活条件引入打包所需的配置和文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引入所需环境的配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>application.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--根据maven选择环境导入配置文件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>application-$&#123;environment&#125;.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着，我们可以直接将Maven中的<code>environment</code>属性，传递给SpringBoot的配置文件，在构建时替换为对应的值：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">&#x27;@environment@&#x27;</span>  <span class="comment">#注意YAML配置文件需要加单引号，否则会报错</span></span><br></pre></td></tr></table></figure>

<p>这样，根据我们Maven环境的切换，SpringBoot的配置文件也会进行对应的切换。</p>
<p>最后我们打开Maven栏目，就可以自由切换了，直接勾选即可，注意切换环境之后要重新加载一下Maven项目，不然不会生效！</p>
<hr>
<h2 id="常用框架介绍"><a href="#常用框架介绍" class="headerlink" title="常用框架介绍"></a>常用框架介绍</h2><p>前面我们介绍了SpringBoot项目的基本搭建，相信各位小伙伴已经体验到SpringBoot 3带来的超强便捷性了，不过光靠这些还不够，我们还需要了解更多框架来丰富我们的网站，通过了解其他的SpringBoot整合框架，我们就可以在我们自己的Web服务器上实现更多更高级的功能，同时也是为了给我们后续学习前后端分离项目做准备。</p>
<h3 id="邮件发送模块"><a href="#邮件发送模块" class="headerlink" title="邮件发送模块"></a>邮件发送模块</h3><p>都什么年代了，还在发传统邮件，我们来看看电子邮件。</p>
<p>我们在注册很多的网站时，都会遇到邮件或是手机号验证，也就是通过你的邮箱或是手机短信去接受网站发给你的注册验证信息，填写验证码之后，就可以完成注册了，同时，网站也会绑定你的手机号或是邮箱。</p>
<p>那么，像这样的功能，我们如何实现呢？SpringBoot已经给我们提供了封装好的邮件模块使用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在学习邮件发送之前，我们需要先了解一下什么是电子邮件。</p>
<blockquote>
<p>电子邮件也是一种通信方式，是互联网应用最广的服务。通过网络的电子邮件系统，用户可以以非常低廉的价格（不管发送到哪里，都只需负担网费，实际上就是把信息发送到对方服务器而已）、非常快速的方式，与世界上任何一个地方的电子邮箱用户联系。</p>
</blockquote>
<p>虽说方便倒是方便，虽然是曾经的霸主，不过现在这个时代，QQ微信横行，手机短信和电子邮箱貌似就只剩收验证码这一个功能了。</p>
<p>要在Internet上提供电子邮件功能，必须有专门的电子邮件服务器。例如现在Internet很多提供邮件服务的厂商：新浪、搜狐、163、QQ邮箱等，他们都有自己的邮件服务器。这些服务器类似于现实生活中的邮局，它主要负责接收用户投递过来的邮件，并把邮件投递到邮件接收者的电子邮箱中。</p>
<p>所有的用户都可以在电子邮件服务器上申请一个账号用于邮件发送和接收，那么邮件是以什么样的格式发送的呢？实际上和Http一样，邮件发送也有自己的协议，也就是约定邮件数据长啥样以及如何通信。</p>
<p><img src="https://s2.loli.net/2023/07/16/sL56YdmgGblfFjo.png" alt="image-20230716172901937"></p>
<p>比较常用的协议有两种：</p>
<ol>
<li>SMTP协议（主要用于发送邮件 Simple Mail Transfer Protocol）</li>
<li>POP3协议（主要用于接收邮件 Post Office Protocol 3）</li>
</ol>
<p>整个发送&#x2F;接收流程大致如下：</p>
<p><img src="https://s2.loli.net/2023/07/16/sOyWQguFonJKXNw.jpg" alt="img"></p>
<p>实际上每个邮箱服务器都有一个smtp发送服务器和pop3接收服务器，比如要从QQ邮箱发送邮件到163邮箱，那么我们只需要通过QQ邮箱客户端告知QQ邮箱的smtp服务器我们需要发送邮件，以及邮件的相关信息，然后QQ邮箱的smtp服务器就会帮助我们发送到163邮箱的pop3服务器上，163邮箱会通过163邮箱客户端告知对应用户收到一封新邮件。</p>
<p>而我们如果想要实现给别人发送邮件，那么就需要连接到对应电子邮箱的smtp服务器上，并告知其我们要发送邮件。而SpringBoot已经帮助我们将最基本的底层通信全部实现了，我们只需要关心smtp服务器的地址以及我们要发送的邮件长啥样即可。</p>
<p>这里以163邮箱 <a target="_blank" rel="noopener" href="https://mail.163.com/">https://mail.163.com</a> 为例，我们需要在配置文件中告诉SpringBootMail我们的smtp服务器的地址以及你的邮箱账号和密码，首先我们要去设置中开启smtp&#x2F;pop3服务才可以，开启后会得到一个随机生成的密钥，这个就是我们的密码。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">      <span class="comment"># 163邮箱的地址为smtp.163.com，直接填写即可</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.163.com</span></span><br><span class="line">    <span class="comment"># 你申请的163邮箱</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">javastudy111@163.com</span></span><br><span class="line">    <span class="comment"># 注意密码是在开启smtp/pop3时自动生成的，记得保存一下，不然就找不到了</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">AZJTOAWZESLMHTNI</span></span><br></pre></td></tr></table></figure>

<p>配置完成后，接着我们来进行一下测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringBootTestApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//JavaMailSender是专门用于发送邮件的对象，自动配置类已经提供了Bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JavaMailSender sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="comment">//SimpleMailMessage是一个比较简易的邮件封装，支持设置一些比较简单内容</span></span><br><span class="line">        <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">          <span class="comment">//设置邮件标题</span></span><br><span class="line">        message.setSubject(<span class="string">&quot;【电子科技大学教务处】关于近期学校对您的处分决定&quot;</span>);</span><br><span class="line">          <span class="comment">//设置邮件内容</span></span><br><span class="line">        message.setText(<span class="string">&quot;XXX同学您好，经监控和教务巡查发现，您近期存在旷课、迟到、早退、上课刷抖音行为，&quot;</span> +</span><br><span class="line">                <span class="string">&quot;现已通知相关辅导员，请手写5000字书面检讨，并在2022年4月1日17点前交到辅导员办公室。&quot;</span>);</span><br><span class="line">          <span class="comment">//设置邮件发送给谁，可以多个，这里就发给你的QQ邮箱</span></span><br><span class="line">        message.setTo(<span class="string">&quot;你的QQ号@qq.com&quot;</span>);</span><br><span class="line">          <span class="comment">//邮件发送者，这里要与配置文件中的保持一致</span></span><br><span class="line">        message.setFrom(<span class="string">&quot;javastudy111@163.com&quot;</span>);</span><br><span class="line">          <span class="comment">//OK，万事俱备只欠发送</span></span><br><span class="line">        sender.send(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要添加附件等更多功能，可以使用MimeMessageHelper来帮助我们完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> MessagingException &#123;</span><br><span class="line">      <span class="comment">//创建一个MimeMessage</span></span><br><span class="line">    <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> sender.createMimeMessage();</span><br><span class="line">      <span class="comment">//使用MimeMessageHelper来帮我们修改MimeMessage中的信息</span></span><br><span class="line">    <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message, <span class="literal">true</span>);</span><br><span class="line">    helper.setSubject(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    helper.setText(<span class="string">&quot;lbwnb&quot;</span>);</span><br><span class="line">    helper.setTo(<span class="string">&quot;你的QQ号@qq.com&quot;</span>);</span><br><span class="line">    helper.setFrom(<span class="string">&quot;javastudy111@163.com&quot;</span>);</span><br><span class="line">      <span class="comment">//发送修改好的MimeMessage</span></span><br><span class="line">    sender.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们来尝试为我们的网站实现一个邮件注册功能，首先明确验证流程：请求验证码 -&gt; 生成验证码（临时有效，注意设定过期时间） -&gt; 用户输入验证码并填写注册信息 -&gt; 验证通过注册成功！</p>
<p>接着我们就来着手写一下。</p>
<h3 id="接口规则校验"><a href="#接口规则校验" class="headerlink" title="接口规则校验"></a>接口规则校验</h3><p>通常我们在使用SpringMvc框架编写接口时，很有可能用户发送的数据存在一些问题，比如下面这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/submit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">submit</span><span class="params">(String username,</span></span><br><span class="line"><span class="params">                     String password)</span>&#123;</span><br><span class="line">    System.out.println(username.substring(<span class="number">3</span>));</span><br><span class="line">    System.out.println(password.substring(<span class="number">2</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;请求成功!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口中，我们需要将用户名和密码分割然后打印，在正常情况下，因为用户名长度规定不小于5，如果用户发送的数据是没有问题的，那么就可以正常运行，这也是我们所希望的情况，但是如果用户发送的数据并不是按照规定的，那么就会直接报错：</p>
<p><img src="https://s2.loli.net/2023/07/16/n1FMADOiQCRcGw6.png" alt="image-20230716215850225"></p>
<p>这个时候，我们就需要在请求进来之前进行校验了，最简单的办法就是判断一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/submit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">submit</span><span class="params">(String username,</span></span><br><span class="line"><span class="params">                     String password)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(username.length() &gt; <span class="number">3</span> &amp;&amp; password.length() &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        System.out.println(username.substring(<span class="number">3</span>));</span><br><span class="line">        System.out.println(password.substring(<span class="number">2</span>, <span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;请求成功!&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;请求失败&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这样就能直接解决问题，但是如果我们的每一个接口都需要这样去进行配置，那么是不是太麻烦了一点？SpringBoot为我们提供了很方便的接口校验框架：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在，我们可以直接使用注解完成全部接口的校验：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Validated</span>   <span class="comment">//首先在Controller上开启接口校验</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/submit&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">submit</span><span class="params">(<span class="meta">@Length(min = 3)</span> String username,  //使用<span class="meta">@Length</span>注解一步到位</span></span><br><span class="line"><span class="params">                         <span class="meta">@Length(min = 10)</span> String password)</span>&#123;</span><br><span class="line">        System.out.println(username.substring(<span class="number">3</span>));</span><br><span class="line">        System.out.println(password.substring(<span class="number">2</span>, <span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;请求成功!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们的接口校验就可以快速进行配置了，一个接口就能搞定：</p>
<p><img src="https://s2.loli.net/2023/07/16/EibCc4sHWflywek.png" alt="image-20230716220839816"></p>
<p>不过这样依然会抛出一个异常，对用户不太友好，我们可以稍微处理一下，这里我们可以直接使用之前在SSM阶段中学习的异常处理Controller来自行处理这类异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidationController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ConstraintViolationException.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">error</span><span class="params">(ValidationException e)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.getMessage();   <span class="comment">//出现异常直接返回消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/07/16/7JH6BzOhlUe9gkG.png" alt="image-20230716221420324"></p>
<p>除了@Length之外，我们也可以使用其他的接口来实现各种数据校验：</p>
<table>
<thead>
<tr>
<th align="center">验证注解</th>
<th align="center">验证的数据类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@AssertFalse</td>
<td align="center">Boolean,boolean</td>
<td align="center">值必须是false</td>
</tr>
<tr>
<td align="center">@AssertTrue</td>
<td align="center">Boolean,boolean</td>
<td align="center">值必须是true</td>
</tr>
<tr>
<td align="center">@NotNull</td>
<td align="center">任意类型</td>
<td align="center">值不能是null</td>
</tr>
<tr>
<td align="center">@Null</td>
<td align="center">任意类型</td>
<td align="center">值必须是null</td>
</tr>
<tr>
<td align="center">@Min</td>
<td align="center">BigDecimal、BigInteger、byte、short、int、long、double 以及任何Number或CharSequence子类型</td>
<td align="center">大于等于@Min指定的值</td>
</tr>
<tr>
<td align="center">@Max</td>
<td align="center">同上</td>
<td align="center">小于等于@Max指定的值</td>
</tr>
<tr>
<td align="center">@DecimalMin</td>
<td align="center">同上</td>
<td align="center">大于等于@DecimalMin指定的值（超高精度）</td>
</tr>
<tr>
<td align="center">@DecimalMax</td>
<td align="center">同上</td>
<td align="center">小于等于@DecimalMax指定的值（超高精度）</td>
</tr>
<tr>
<td align="center">@Digits</td>
<td align="center">同上</td>
<td align="center">限制整数位数和小数位数上限</td>
</tr>
<tr>
<td align="center">@Size</td>
<td align="center">字符串、Collection、Map、数组等</td>
<td align="center">长度在指定区间之内，如字符串长度、集合大小等</td>
</tr>
<tr>
<td align="center">@Past</td>
<td align="center">如 java.util.Date, java.util.Calendar 等日期类型</td>
<td align="center">值必须比当前时间早</td>
</tr>
<tr>
<td align="center">@Future</td>
<td align="center">同上</td>
<td align="center">值必须比当前时间晚</td>
</tr>
<tr>
<td align="center">@NotBlank</td>
<td align="center">CharSequence及其子类</td>
<td align="center">值不为空，在比较时会去除字符串的首位空格</td>
</tr>
<tr>
<td align="center">@Length</td>
<td align="center">CharSequence及其子类</td>
<td align="center">字符串长度在指定区间内</td>
</tr>
<tr>
<td align="center">@NotEmpty</td>
<td align="center">CharSequence及其子类、Collection、Map、数组</td>
<td align="center">值不为null且长度不为空（字符串长度不为0，集合大小不为0）</td>
</tr>
<tr>
<td align="center">@Range</td>
<td align="center">BigDecimal、BigInteger、CharSequence、byte、short、int、long 以及原子类型和包装类型</td>
<td align="center">值在指定区间内</td>
</tr>
<tr>
<td align="center">@Email</td>
<td align="center">CharSequence及其子类</td>
<td align="center">值必须是邮件格式</td>
</tr>
<tr>
<td align="center">@Pattern</td>
<td align="center">CharSequence及其子类</td>
<td align="center">值需要与指定的正则表达式匹配</td>
</tr>
<tr>
<td align="center">@Valid</td>
<td align="center">任何非原子类型</td>
<td align="center">用于验证对象属性</td>
</tr>
</tbody></table>
<p>虽然这样已经很方便了，但是在遇到对象的时候，依然不太方便，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    String username;</span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/submit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">submit</span><span class="params">(Account account)</span>&#123;   <span class="comment">//直接使用对象接收</span></span><br><span class="line">    System.out.println(account.getUsername().substring(<span class="number">3</span>));</span><br><span class="line">    System.out.println(account.getPassword().substring(<span class="number">2</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;请求成功!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时接口是以对象形式接收前端发送的表单数据的，这个时候就没办法向上面一样编写对应的校验规则了，那么现在又该怎么做呢？</p>
<p>对应对象类型，我们也可以进行验证，方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/submit&quot;)</span>  <span class="comment">//在参数上添加@Valid注解表示需要验证</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">submit</span><span class="params">(<span class="meta">@Valid</span> Account account)</span>&#123;</span><br><span class="line">    System.out.println(account.getUsername().substring(<span class="number">3</span>));</span><br><span class="line">    System.out.println(account.getPassword().substring(<span class="number">2</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;请求成功!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="meta">@Length(min = 3)</span>   <span class="comment">//只需要在对应的字段上添加校验的注解即可</span></span><br><span class="line">    String username;</span><br><span class="line">    <span class="meta">@Length(min = 10)</span></span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样当受到请求时，就会对对象中的字段进行校验了，这里我们稍微修改一下ValidationController的错误处理，对于实体类接收参数的验证，会抛出MethodArgumentNotValidException异常，这里也进行一下处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@ExceptionHandler(&#123;ConstraintViolationException.class, MethodArgumentNotValidException.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">error</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e <span class="keyword">instanceof</span> ConstraintViolationException exception) &#123;</span><br><span class="line">        <span class="keyword">return</span> exception.getMessage();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> MethodArgumentNotValidException exception)&#123;</span><br><span class="line">        <span class="keyword">if</span> (exception.getFieldError() == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;未知错误&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> exception.getFieldError().getDefaultMessage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;未知错误&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以正确返回对应的错误信息了。</p>
<h2 id="数据交互"><a href="#数据交互" class="headerlink" title="数据交互"></a>数据交互</h2><h3 id="JDBC交互框架"><a href="#JDBC交互框架" class="headerlink" title="JDBC交互框架"></a>JDBC交互框架</h3><p>除了我们前面一直认识的Mybatis之外，实际上Spring官方也提供了一个非常方便的JDBC操作工具，它同样可以快速进行增删改查。首先我们还是通过starter将依赖导入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>导入完成之后就可以轻松使用了。</p>
<h4 id="JDBC模版类"><a href="#JDBC模版类" class="headerlink" title="JDBC模版类"></a>JDBC模版类</h4><p>Spring JDBC为我们提供了一个非常方便的<code>JdbcTemplate</code>类，它封装了常用的JDBC操作，我们可以快速使用这些方法来实现增删改查，这里我们还是配置一下MySQL数据源信息：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>我们要操作数据库，最简单直接的方法就是使用JdbcTemplate来完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">JdbcTemplate template;</span><br></pre></td></tr></table></figure>

<p>它给我们封装了很多方法使用，比如我们要查询数据库中的一条记录：</p>
<p><img src="https://s2.loli.net/2023/07/16/ygRp98mDKafXkw1.png" alt="image-20230716000431492"></p>
<p>我们可以使用<code>queryForMap</code>快速以Map为结果的形式查询一行数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = template.queryForMap(<span class="string">&quot;select * from user where id = ?&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非常方便：</p>
<p><img src="https://s2.loli.net/2023/07/20/ijczpNxh4fXoQKv.png" alt="image-20230720215124918"></p>
<p>我们也可以编写自定义的Mapper用于直接得到查询结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    String email;</span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> template.queryForObject(<span class="string">&quot;select * from user where id = ?&quot;</span>,</span><br><span class="line">        (r, i) -&gt; <span class="keyword">new</span> <span class="title class_">User</span>(r.getInt(<span class="number">1</span>), r.getString(<span class="number">2</span>), r.getString(<span class="number">3</span>), r.getString(<span class="number">4</span>)), <span class="number">1</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然除了这些之外，它还提供了<code>update</code>方法适用于各种情况的查询、更新、删除操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> template.update(<span class="string">&quot;insert into user values(2, &#x27;admin&#x27;, &#x27;654321@qq.com&#x27;, &#x27;123456&#x27;)&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;更新了 &quot;</span>+update+<span class="string">&quot; 行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，如果是那种非常小型的项目，甚至是测试用例的话，都可以快速使用JdbcTemplate快速进行各种操作。</p>
<h4 id="JDBC简单封装"><a href="#JDBC简单封装" class="headerlink" title="JDBC简单封装"></a>JDBC简单封装</h4><p>对于一些插入操作，Spring JDBC为我们提供了更方便的SimpleJdbcInsert工具，它可以实现更多高级的插入功能，比如我们的表主键采用的是自增ID，那么它支持插入后返回自动生成的ID，这就非常方便了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    DataSource source;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="comment">//这个类需要自己创建对象</span></span><br><span class="line">        <span class="type">SimpleJdbcInsert</span> <span class="variable">simple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleJdbcInsert</span>(source)</span><br><span class="line">                .withTableName(<span class="string">&quot;user&quot;</span>)   <span class="comment">//设置要操作的表名称</span></span><br><span class="line">                .usingGeneratedKeyColumns(<span class="string">&quot;id&quot;</span>);    <span class="comment">//设置自增主键列</span></span><br><span class="line">        Map&lt;String, Object&gt; user = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);  <span class="comment">//插入操作需要传入一个Map作为数据</span></span><br><span class="line">        user.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;bob&quot;</span>);</span><br><span class="line">        user.put(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;112233@qq.com&quot;</span>);</span><br><span class="line">        user.put(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="type">Number</span> <span class="variable">number</span> <span class="operator">=</span> simple.executeAndReturnKey(user);   <span class="comment">//最后得到的Numver就是得到的自增主键</span></span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以快速进行插入操作并且返回自增主键了，还是挺方便的。</p>
<p><img src="https://s2.loli.net/2023/07/20/xMeBEY3sdKVGmly.png" alt="image-20230720224314223"></p>
<p>当然，虽然SpringJDBC给我们提供了这些小工具，但是其实只适用于简单小项目，稍微复杂一点就不太适合了，下一部分我们将介绍JPA框架。</p>
<h3 id="JPA框架"><a href="#JPA框架" class="headerlink" title="JPA框架"></a>JPA框架</h3><p><img src="https://s2.loli.net/2023/07/20/mq4Ut7BMI5XTDoN.png" alt="image-20230720230734488"></p>
<ul>
<li>用了Mybatis之后，你看那个JDBC，真是太逊了。</li>
<li>这么说，你的项目很勇哦？</li>
<li>开玩笑，我的写代码超勇的好不好。</li>
<li>阿伟，你可曾幻想过有一天你的项目里不再有SQL语句？</li>
<li>不再有SQL语句？那我怎么和数据库交互啊？</li>
<li>我看你是完全不懂哦</li>
<li>懂，懂什么啊？</li>
<li>你想懂？来，到我项目里来，我给你看点好康的。</li>
<li>好康？是什么新框架哦？</li>
<li>什么新框架，比新框架还刺激，还可以让你的项目登duang郎哦。</li>
<li>哇，杰哥，你项目里面都没SQL语句诶，这是用的什么框架啊？</li>
</ul>
<p>​		在我们之前编写的项目中，我们不难发现，实际上大部分的数据库交互操作，到最后都只会做一个事情，那就是把数据库中的数据映射为Java中的对象。比如我们要通过用户名去查找对应的用户，或是通过ID查找对应的学生信息，在使用Mybatis时，我们只需要编写正确的SQL语句就可以直接将获取的数据映射为对应的Java对象，通过调用Mapper中的方法就能直接获得实体类，这样就方便我们在Java中数据库表中的相关信息了。</p>
<p>​		但是以上这些操作都有一个共性，那就是它们都是通过某种条件去进行查询，而最后的查询结果，都是一个实体类，所以你会发现你写的很多SQL语句都是一个套路<code>select * from xxx where xxx=xxx</code>，实际上对于这种简单SQL语句，我们完全可以弄成一个模版来使用，那么能否有一种框架，帮我们把这些相同的套路给封装起来，直接把这类相似的SQL语句给屏蔽掉，不再由我们编写，而是让框架自己去组合拼接。</p>
<h4 id="认识SpringData-JPA"><a href="#认识SpringData-JPA" class="headerlink" title="认识SpringData JPA"></a>认识SpringData JPA</h4><p>首先我们来看一个国外的统计：</p>
<p><img src="https://s2.loli.net/2023/03/06/XaoLIPrjDKzO9Tx.png" alt="image-20230306224859664"></p>
<p>不对吧，为什么Mybatis这么好用，这么强大，却只有10%的人喜欢呢？然而事实就是，在国外JPA几乎占据了主导地位，而Mybatis并不像国内那样受待见，所以你会发现，JPA都有SpringBoot的官方直接提供的starter，而Mybatis没有，直到SpringBoot 3才开始加入到官方模版中。</p>
<p>那么，什么是JPA？</p>
<blockquote>
<p>JPA（Java Persistence API）和JDBC类似，也是官方定义的一组接口，但是它相比传统的JDBC，它是为了实现ORM而生的，即Object-Relationl Mapping，它的作用是在关系型数据库和对象之间形成一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作它就可以了。</p>
<p>其中比较常见的JPA实现有：</p>
<ol>
<li>Hibernate：Hibernate是JPA规范的一个具体实现，也是目前使用最广泛的JPA实现框架之一。它提供了强大的对象关系映射功能，可以将Java对象映射到数据库表中，并提供了丰富的查询语言和缓存机制。</li>
<li>EclipseLink：EclipseLink是另一个流行的JPA实现框架，由Eclipse基金会开发和维护。它提供了丰富的特性，如对象关系映射、缓存、查询语言和连接池管理等，并具有较高的性能和可扩展性。</li>
<li>OpenJPA：OpenJPA是Apache基金会的一个开源项目，也是JPA规范的一个实现。它提供了高性能的JPA实现和丰富的特性，如延迟加载、缓存和分布式事务等。</li>
<li>TopLink：TopLink是Oracle公司开发的一个对象关系映射框架，也是JPA规范的一个实现。虽然EclipseLink已经取代了TopLink成为Oracle推荐的JPA实现，但TopLink仍然得到广泛使用。</li>
</ol>
</blockquote>
<p>在之前，我们使用JDBC或是Mybatis来操作数据，通过直接编写对应的SQL语句来实现数据访问，但是我们发现实际上我们在Java中大部分操作数据库的情况都是读取数据并封装为一个实体类，因此，为什么不直接将实体类直接对应到一个数据库表呢？也就是说，一张表里面有什么属性，那么我们的对象就有什么属性，所有属性跟数据库里面的字段一一对应，而读取数据时，只需要读取一行的数据并封装为我们定义好的实体类既可以，而具体的SQL语句执行，完全可以交给框架根据我们定义的映射关系去生成，不再由我们去编写，因为这些SQL实际上都是千篇一律的。</p>
<p>而实现JPA规范的框架一般最常用的就是<code>Hibernate</code>，它是一个重量级框架，学习难度相比Mybatis也更高一些，而SpringDataJPA也是采用Hibernate框架作为底层实现，并对其加以封装。</p>
<p>官网：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-jpa">https://spring.io/projects/spring-data-jpa</a></p>
<h4 id="使用JPA快速上手"><a href="#使用JPA快速上手" class="headerlink" title="使用JPA快速上手"></a>使用JPA快速上手</h4><p>同样的，我们只需要导入stater依赖即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着我们可以直接创建一个类，比如用户类，我们只需要把一个账号对应的属性全部定义好即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String username;</span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，我们可以通过注解形式，在属性上添加数据库映射关系，这样就能够让JPA知道我们的实体类对应的数据库表长啥样，这里用到了很多注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span>   <span class="comment">//表示这个类是一个实体类</span></span><br><span class="line"><span class="meta">@Table(name = &quot;account&quot;)</span>    <span class="comment">//对应的数据库中表名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>   <span class="comment">//生成策略，这里配置为自增</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;id&quot;)</span>    <span class="comment">//对应表中id这一列</span></span><br><span class="line">    <span class="meta">@Id</span>     <span class="comment">//此属性为主键</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;username&quot;)</span>   <span class="comment">//对应表中username这一列</span></span><br><span class="line">    String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;password&quot;)</span>   <span class="comment">//对应表中password这一列</span></span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来修改一下配置文件，把日志打印给打开：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="comment">#开启SQL语句执行日志信息</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="comment">#配置为检查数据库表结构，没有时会自动创建</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br></pre></td></tr></table></figure>

<p><code>ddl-auto</code>属性用于设置自动表定义，可以实现自动在数据库中为我们创建一个表，表的结构会根据我们定义的实体类决定，它有以下几种：</p>
<ul>
<li><code>none</code>: 不执行任何操作，数据库表结构需要手动创建。</li>
<li><code>create</code>: 框架在每次运行时都会删除所有表，并重新创建。</li>
<li><code>create-drop</code>: 框架在每次运行时都会删除所有表，然后再创建，但在程序结束时会再次删除所有表。</li>
<li><code>update</code>: 框架会检查数据库表结构，如果与实体类定义不匹配，则会做相应的修改，以保持它们的一致性。</li>
<li><code>validate</code>: 框架会检查数据库表结构与实体类定义是否匹配，如果不匹配，则会抛出异常。</li>
</ul>
<p>这个配置项的作用是为了避免手动管理数据库表结构，使开发者可以更方便地进行开发和测试，但在生产环境中，更推荐使用数据库迁移工具来管理表结构的变更。</p>
<p>我们可以在日志中发现，在启动时执行了如下SQL语句：</p>
<p><img src="https://s2.loli.net/2023/07/20/kABZVhJ8vjKSqzT.png" alt="image-20230720235136506"></p>
<p>我们的数据库中对应的表已经自动创建好了。</p>
<p>我们接着来看如何访问我们的表，我们需要创建一个Repository实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意JpaRepository有两个泛型，前者是具体操作的对象实体，也就是对应的表，后者是ID的类型，接口中已经定义了比较常用的数据库操作。编写接口继承即可，我们可以直接注入此接口获得实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">AccountRepository repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    account.setUsername(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">    account.setPassword(<span class="string">&quot;1234567&quot;</span>);</span><br><span class="line">    System.out.println(repository.save(account).getId());   <span class="comment">//使用save来快速插入数据，并且会返回插入的对象，如果存在自增ID，对象的自增id属性会自动被赋值，这就很方便了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<p><img src="https://s2.loli.net/2023/07/20/ksI3J5eidzTrvyL.png" alt="image-20230720235640148"></p>
<p>同时，查询操作也很方便：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="comment">//默认通过通过ID查找的方法，并且返回的结果是Optional包装的对象，非常人性化</span></span><br><span class="line">    repository.findById(<span class="number">1</span>).ifPresent(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果为：</p>
<p><img src="https://s2.loli.net/2023/07/20/TRHOWbop267Al4Q.png" alt="image-20230720235949290"></p>
<p>包括常见的一些计数、删除操作等都包含在里面，仅仅配置应该接口就能完美实现增删改查：</p>
<p><img src="https://s2.loli.net/2023/07/21/uIBciLqFsH5tdDR.png" alt="image-20230721000050875"></p>
<p>我们发现，使用了JPA之后，整个项目的代码中没有出现任何的SQL语句，可以说是非常方便了，JPA依靠我们提供的注解信息自动完成了所有信息的映射和关联。</p>
<p>相比Mybatis，JPA几乎就是一个全自动的ORM框架，而Mybatis则顶多算是半自动ORM框架。</p>
<h4 id="方法名称拼接自定义SQL"><a href="#方法名称拼接自定义SQL" class="headerlink" title="方法名称拼接自定义SQL"></a>方法名称拼接自定义SQL</h4><p>虽然接口预置的方法使用起来非常方便，但是如果我们需要进行条件查询等操作或是一些判断，就需要自定义一些方法来实现，同样的，我们不需要编写SQL语句，而是通过方法名称的拼接来实现条件判断，这里列出了所有支持的条件判断名称：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>拼接方法名称示例</th>
<th>执行的语句</th>
</tr>
</thead>
<tbody><tr>
<td>Distinct</td>
<td>findDistinctByLastnameAndFirstname</td>
<td>select distinct … where x.lastname &#x3D; ?1 and x.firstname &#x3D; ?2</td>
</tr>
<tr>
<td>And</td>
<td>findByLastnameAndFirstname</td>
<td>… where x.lastname &#x3D; ?1 and x.firstname &#x3D; ?2</td>
</tr>
<tr>
<td>Or</td>
<td>findByLastnameOrFirstname</td>
<td>… where x.lastname &#x3D; ?1 or x.firstname &#x3D; ?2</td>
</tr>
<tr>
<td>Is，Equals</td>
<td>findByFirstname<code>,</code>findByFirstnameIs<code>,</code>findByFirstnameEquals</td>
<td>… where x.firstname &#x3D; ?1</td>
</tr>
<tr>
<td>Between</td>
<td>findByStartDateBetween</td>
<td>… where x.startDate between ?1 and ?2</td>
</tr>
<tr>
<td>LessThan</td>
<td>findByAgeLessThan</td>
<td>… where x.age &lt; ?1</td>
</tr>
<tr>
<td>LessThanEqual</td>
<td>findByAgeLessThanEqual</td>
<td>… where x.age &lt;&#x3D; ?1</td>
</tr>
<tr>
<td>GreaterThan</td>
<td>findByAgeGreaterThan</td>
<td>… where x.age &gt; ?1</td>
</tr>
<tr>
<td>GreaterThanEqual</td>
<td>findByAgeGreaterThanEqual</td>
<td>… where x.age &gt;&#x3D; ?1</td>
</tr>
<tr>
<td>After</td>
<td>findByStartDateAfter</td>
<td>… where x.startDate &gt; ?1</td>
</tr>
<tr>
<td>Before</td>
<td>findByStartDateBefore</td>
<td>… where x.startDate &lt; ?1</td>
</tr>
<tr>
<td>IsNull，Null</td>
<td>findByAge(Is)Null</td>
<td>… where x.age is null</td>
</tr>
<tr>
<td>IsNotNull，NotNull</td>
<td>findByAge(Is)NotNull</td>
<td>… where x.age not null</td>
</tr>
<tr>
<td>Like</td>
<td>findByFirstnameLike</td>
<td>… where x.firstname like ?1</td>
</tr>
<tr>
<td>NotLike</td>
<td>findByFirstnameNotLike</td>
<td>… where x.firstname not like ?1</td>
</tr>
<tr>
<td>StartingWith</td>
<td>findByFirstnameStartingWith</td>
<td>… where x.firstname like ?1（参数与附加<code>%</code>绑定）</td>
</tr>
<tr>
<td>EndingWith</td>
<td>findByFirstnameEndingWith</td>
<td>… where x.firstname like ?1（参数与前缀<code>%</code>绑定）</td>
</tr>
<tr>
<td>Containing</td>
<td>findByFirstnameContaining</td>
<td>… where x.firstname like ?1（参数绑定以<code>%</code>包装）</td>
</tr>
<tr>
<td>OrderBy</td>
<td>findByAgeOrderByLastnameDesc</td>
<td>… where x.age &#x3D; ?1 order by x.lastname desc</td>
</tr>
<tr>
<td>Not</td>
<td>findByLastnameNot</td>
<td>… where x.lastname &lt;&gt; ?1</td>
</tr>
<tr>
<td>In</td>
<td>findByAgeIn(Collection<Age> ages)</td>
<td>… where x.age in ?1</td>
</tr>
<tr>
<td>NotIn</td>
<td>findByAgeNotIn(Collection<Age> ages)</td>
<td>… where x.age not in ?1</td>
</tr>
<tr>
<td>True</td>
<td>findByActiveTrue</td>
<td>… where x.active &#x3D; true</td>
</tr>
<tr>
<td>False</td>
<td>findByActiveFalse</td>
<td>… where x.active &#x3D; false</td>
</tr>
<tr>
<td>IgnoreCase</td>
<td>findByFirstnameIgnoreCase</td>
<td>… where UPPER(x.firstname) &#x3D; UPPER(?1)</td>
</tr>
</tbody></table>
<p>比如我们想要实现根据用户名模糊匹配查找用户：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;</span><br><span class="line">    <span class="comment">//按照表中的规则进行名称拼接，不用刻意去记，IDEA会有提示</span></span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAllByUsernameLike</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    repository.findAllByUsernameLike(<span class="string">&quot;%明%&quot;</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/07/21/mioZaUk7Yj3QDxb.png" alt="image-20230721001035279"></p>
<p>又比如我们想同时根据用户名和ID一起查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;</span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAllByUsernameLike</span><span class="params">(String str)</span>;</span><br><span class="line"></span><br><span class="line">    Account <span class="title function_">findByIdAndUsername</span><span class="params">(<span class="type">int</span> id, String username)</span>;</span><br><span class="line">    <span class="comment">//也可以使用Optional类进行包装，Optional&lt;Account&gt; findByIdAndUsername(int id, String username);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(repository.findByIdAndUsername(<span class="number">1</span>, <span class="string">&quot;小明&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们想判断数据库中是否存在某个ID的用户：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;</span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAllByUsernameLike</span><span class="params">(String str)</span>;</span><br><span class="line">    Account <span class="title function_">findByIdAndUsername</span><span class="params">(<span class="type">int</span> id, String username)</span>;</span><br><span class="line">    <span class="comment">//使用exists判断是否存在</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">existsAccountById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意自定义条件操作的方法名称一定要遵循规则，不然会出现异常：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.data.repository.query.QueryCreationException: Could not create query <span class="keyword">for</span> public abstract  ...</span><br></pre></td></tr></table></figure>

<p>有了这些操作，我们在编写一些简单SQL的时候就很方便了，用久了甚至直接忘记SQL怎么写。</p>
<h4 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h4><p>在实际开发中，比较常见的场景还有关联查询，也就是我们会在表中添加一个外键字段，而此外键字段又指向了另一个表中的数据，当我们查询数据时，可能会需要将关联数据也一并获取，比如我们想要查询某个用户的详细信息，一般用户简略信息会单独存放一个表，而用户详细信息会单独存放在另一个表中。当然，除了用户详细信息之外，可能在某些电商平台还会有用户的购买记录、用户的购物车，交流社区中的用户帖子、用户评论等，这些都是需要根据用户信息进行关联查询的内容。</p>
<p><img src="https://s2.loli.net/2023/03/06/WnPEmdR2sDLuwGN.jpg" alt="img"></p>
<p>我们知道，在JPA中，每张表实际上就是一个实体类的映射，而表之间的关联关系，也可以看作对象之间的依赖关系，比如用户表中包含了用户详细信息的ID字段作为外键，那么实际上就是用户表实体中包括了用户详细信息实体对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users_detail&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDetail</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;id&quot;)</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;address&quot;)</span></span><br><span class="line">    String address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;email&quot;)</span></span><br><span class="line">    String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;phone&quot;)</span></span><br><span class="line">    String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;real_name&quot;)</span></span><br><span class="line">    String realName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而用户信息和用户详细信息之间形成了一对一的关系，那么这时我们就可以直接在类中指定这种关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;id&quot;)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;username&quot;)</span></span><br><span class="line">    String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;password&quot;)</span></span><br><span class="line">    String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;detail_id&quot;)</span>   <span class="comment">//指定存储外键的字段名称</span></span><br><span class="line">    <span class="meta">@OneToOne</span>    <span class="comment">//声明为一对一关系</span></span><br><span class="line">    AccountDetail detail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在修改实体类信息后，我们发现在启动时也进行了更新，日志如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: alter table users add column detail_id integer</span><br><span class="line">Hibernate: create table users_detail (id integer not null auto_increment, address varchar(255), email varchar(255), phone varchar(255), real_name varchar(255), primary key (id)) engine=InnoDB</span><br><span class="line">Hibernate: alter table users add constraint FK7gb021edkxf3mdv5bs75ni6jd foreign key (detail_id) references users_detail (id)</span><br></pre></td></tr></table></figure>

<p>是不是感觉非常方便！都懒得去手动改表结构了。</p>
<p>接着我们往用户详细信息中添加一些数据，一会我们可以直接进行查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pageAccount</span><span class="params">()</span> &#123;</span><br><span class="line">    repository.findById(<span class="number">1</span>).ifPresent(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询后，可以发现，得到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: select account0_.id as id1_0_0_, account0_.detail_id as detail_i4_0_0_, account0_.password as password2_0_0_, account0_.username as username3_0_0_, accountdet1_.id as id1_1_1_, accountdet1_.address as address2_1_1_, accountdet1_.email as email3_1_1_, accountdet1_.phone as phone4_1_1_, accountdet1_.real_name as real_nam5_1_1_ from users account0_ left outer join users_detail accountdet1_ on account0_.detail_id=accountdet1_.id where account0_.id=?</span><br><span class="line">Account(id=1, username=Test, password=123456, detail=AccountDetail(id=1, address=四川省成都市青羊区, email=8371289@qq.com, phone=1234567890, realName=本伟))</span><br></pre></td></tr></table></figure>

<p>也就是，在建立关系之后，我们查询Account对象时，会自动将关联数据的结果也一并进行查询。</p>
<p>那要是我们只想要Account的数据，不想要用户详细信息数据怎么办呢？我希望在我要用的时候再获取详细信息，这样可以节省一些网络开销，我们可以设置懒加载，这样只有在需要时才会向数据库获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JoinColumn(name = &quot;detail_id&quot;)</span></span><br><span class="line"><span class="meta">@OneToOne(fetch = FetchType.LAZY)</span>    <span class="comment">//将获取类型改为LAZY</span></span><br><span class="line">AccountDetail detail;</span><br></pre></td></tr></table></figure>

<p>接着我们测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>   <span class="comment">//懒加载属性需要在事务环境下获取，因为repository方法调用完后Session会立即关闭</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pageAccount</span><span class="params">()</span> &#123;</span><br><span class="line">    repository.findById(<span class="number">1</span>).ifPresent(account -&gt; &#123;</span><br><span class="line">        System.out.println(account.getUsername());   <span class="comment">//获取用户名</span></span><br><span class="line">        System.out.println(account.getDetail());  <span class="comment">//获取详细信息（懒加载）</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来看看控制台输出了什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: select account0_.id as id1_0_0_, account0_.detail_id as detail_i4_0_0_, account0_.password as password2_0_0_, account0_.username as username3_0_0_ from users account0_ where account0_.id=?</span><br><span class="line">Test</span><br><span class="line">Hibernate: select accountdet0_.id as id1_1_0_, accountdet0_.address as address2_1_0_, accountdet0_.email as email3_1_0_, accountdet0_.phone as phone4_1_0_, accountdet0_.real_name as real_nam5_1_0_ from users_detail accountdet0_ where accountdet0_.id=?</span><br><span class="line">AccountDetail(id=1, address=四川省成都市青羊区, email=8371289@qq.com, phone=1234567890, realName=卢本)</span><br></pre></td></tr></table></figure>

<p>可以看到，获取用户名之前，并没有去查询用户的详细信息，而是当我们获取详细信息时才进行查询并返回AccountDetail对象。</p>
<p>那么我们是否也可以在添加数据时，利用实体类之间的关联信息，一次性添加两张表的数据呢？可以，但是我们需要稍微修改一下级联关联操作设定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JoinColumn(name = &quot;detail_id&quot;)</span></span><br><span class="line"><span class="meta">@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)</span> <span class="comment">//设置关联操作为ALL</span></span><br><span class="line">AccountDetail detail;</span><br></pre></td></tr></table></figure>

<ul>
<li>ALL：所有操作都进行关联操作</li>
<li>PERSIST：插入操作时才进行关联操作</li>
<li>REMOVE：删除操作时才进行关联操作</li>
<li>MERGE：修改操作时才进行关联操作</li>
</ul>
<p>可以多个并存，接着我们来进行一下测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addAccount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    account.setUsername(<span class="string">&quot;Nike&quot;</span>);</span><br><span class="line">    account.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="type">AccountDetail</span> <span class="variable">detail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountDetail</span>();</span><br><span class="line">    detail.setAddress(<span class="string">&quot;重庆市渝中区解放碑&quot;</span>);</span><br><span class="line">    detail.setPhone(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">    detail.setEmail(<span class="string">&quot;73281937@qq.com&quot;</span>);</span><br><span class="line">    detail.setRealName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  	account.setDetail(detail);</span><br><span class="line">    account = repository.save(account);</span><br><span class="line">    System.out.println(<span class="string">&quot;插入时，自动生成的主键ID为：&quot;</span>+account.getId()+<span class="string">&quot;，外键ID为：&quot;</span>+account.getDetail().getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到日志结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: insert into users_detail (address, email, phone, real_name) values (?, ?, ?, ?)</span><br><span class="line">Hibernate: insert into users (detail_id, password, username) values (?, ?, ?)</span><br><span class="line">插入时，自动生成的主键ID为：6，外键ID为：3</span><br></pre></td></tr></table></figure>

<p>结束后会发现数据库中两张表都同时存在数据。</p>
<p>接着我们来看一对多关联，比如每个用户的成绩信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JoinColumn(name = &quot;uid&quot;)</span>  <span class="comment">//注意这里的name指的是Score表中的uid字段对应的就是当前的主键，会将uid外键设置为当前的主键</span></span><br><span class="line"><span class="meta">@OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)</span>   <span class="comment">//在移除Account时，一并移除所有的成绩信息，依然使用懒加载</span></span><br><span class="line">List&lt;Score&gt; scoreList;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users_score&quot;)</span>   <span class="comment">//成绩表，注意只存成绩，不存学科信息，学科信息id做外键</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;id&quot;)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToOne</span>   <span class="comment">//一对一对应到学科上</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;cid&quot;)</span></span><br><span class="line">    Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;socre&quot;)</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;uid&quot;)</span></span><br><span class="line">    <span class="type">int</span> uid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;subjects&quot;)</span>   <span class="comment">//学科信息表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;cid&quot;)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="type">int</span> cid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;name&quot;)</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;teacher&quot;)</span></span><br><span class="line">    String teacher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;time&quot;)</span></span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在数据库中填写相应数据，接着我们就可以查询用户的成绩信息了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    repository.findById(<span class="number">1</span>).ifPresent(account -&gt; &#123;</span><br><span class="line">        account.getScoreList().forEach(System.out::println);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功得到用户所有的成绩信息，包括得分和学科信息。</p>
<p>同样的，我们还可以将对应成绩中的教师信息单独分出一张表存储，并建立多对一的关系，因为多门课程可能由同一个老师教授（千万别搞晕了，一定要理清楚关联关系，同时也是考验你的基础扎不扎实）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line"><span class="meta">@JoinColumn(name = &quot;tid&quot;)</span>   <span class="comment">//存储教师ID的字段，和一对一是一样的，也会当前表中创个外键</span></span><br><span class="line">Teacher teacher;</span><br></pre></td></tr></table></figure>

<p>接着就是教师实体类了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;teachers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;id&quot;)</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;name&quot;)</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;sex&quot;)</span></span><br><span class="line">    String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们再进行一下测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    repository.findById(<span class="number">3</span>).ifPresent(account -&gt; &#123;</span><br><span class="line">        account.getScoreList().forEach(score -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;课程名称：&quot;</span>+score.getSubject().getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;得分：&quot;</span>+score.getScore());</span><br><span class="line">            System.out.println(<span class="string">&quot;任课教师：&quot;</span>+score.getSubject().getTeacher().getName());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功得到多对一的教师信息。</p>
<p>最后我们再来看最复杂的情况，现在我们一门课程可以由多个老师教授，而一个老师也可以教授多个课程，那么这种情况就是很明显的多对多场景，现在又该如何定义呢？我们可以像之前一样，插入一张中间表表示教授关系，这个表中专门存储哪个老师教哪个科目：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ManyToMany(fetch = FetchType.LAZY)</span>   <span class="comment">//多对多场景</span></span><br><span class="line"><span class="meta">@JoinTable(name = &quot;teach_relation&quot;,     //多对多中间关联表</span></span><br><span class="line"><span class="meta">        joinColumns = @JoinColumn(name = &quot;cid&quot;),    //当前实体主键在关联表中的字段名称</span></span><br><span class="line"><span class="meta">        inverseJoinColumns = @JoinColumn(name = &quot;tid&quot;)   //教师实体主键在关联表中的字段名称</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line">List&lt;Teacher&gt; teacher;</span><br></pre></td></tr></table></figure>

<p>接着，JPA会自动创建一张中间表，并自动设置外键，我们就可以将多对多关联信息编写在其中了。</p>
<h4 id="JPQL自定义SQL语句"><a href="#JPQL自定义SQL语句" class="headerlink" title="JPQL自定义SQL语句"></a>JPQL自定义SQL语句</h4><p>虽然SpringDataJPA能够简化大部分数据获取场景，但是难免会有一些特殊的场景，需要使用复杂查询才能够去完成，这时你又会发现，如果要实现，只能用回Mybatis了，因为我们需要自己手动编写SQL语句，过度依赖SpringDataJPA会使得SQL语句不可控。</p>
<p>使用JPA，我们也可以像Mybatis那样，直接编写SQL语句，不过它是JPQL语言，与原生SQL语句很类似，但是它是面向对象的，当然我们也可以编写原生SQL语句。</p>
<p>比如我们要更新用户表中指定ID用户的密码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span>    <span class="comment">//DML操作需要事务环境，可以不在这里声明，但是调用时一定要处于事务环境下</span></span><br><span class="line">    <span class="meta">@Modifying</span>     <span class="comment">//表示这是一个DML操作</span></span><br><span class="line">    <span class="meta">@Query(&quot;update Account set password = ?2 where id = ?1&quot;)</span> <span class="comment">//这里操作的是一个实体类对应的表，参数使用?代表，后面接第n个参数</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updatePasswordById</span><span class="params">(<span class="type">int</span> id, String newPassword)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateAccount</span><span class="params">()</span>&#123;</span><br><span class="line">    repository.updatePasswordById(<span class="number">1</span>, <span class="string">&quot;654321&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我想使用原生SQL来实现根据用户名称修改密码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Query(value = &quot;update users set password = :pwd where username = :name&quot;, nativeQuery = true)</span> <span class="comment">//使用原生SQL，和Mybatis一样，这里使用 :名称 表示参数，当然也可以继续用上面那种方式。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updatePasswordByUsername</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String username,   //我们可以使用<span class="meta">@Param</span>指定名称</span></span><br><span class="line"><span class="params">                             <span class="meta">@Param(&quot;pwd&quot;)</span> String newPassword)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateAccount</span><span class="params">()</span>&#123;</span><br><span class="line">    repository.updatePasswordByUsername(<span class="string">&quot;Admin&quot;</span>, <span class="string">&quot;654321&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过编写原生SQL，在一定程度上弥补了SQL不可控的问题。</p>
<p>虽然JPA能够为我们带来非常便捷的开发体验，但是正是因为太便捷了，保姆级的体验有时也会适得其反，尤其是一些国内用到复杂查询业务的项目，可能开发到后期特别庞大时，就只能从底层SQL语句开始进行优化，而由于JPA尽可能地在屏蔽我们对SQL语句的编写，所以后期优化是个大问题，并且Hibernate相对于Mybatis来说，更加重量级。不过，在微服务的时代，单体项目一般不会太大，JPA的劣势并没有太明显地体现出来。</p>
<h3 id="MybatisPlus框架"><a href="#MybatisPlus框架" class="headerlink" title="MybatisPlus框架"></a>MybatisPlus框架</h3><p>前面我们体验了JPA带来的快速开发体验，但是我们发现，面对一些复杂查询时，JPA似乎有点力不从心，反观稍微麻烦一点的Mybatis却能够手动编写SQL，使用起来更加灵活，那么有没有一种既能灵活掌控逻辑又能快速完成开发的持久层框架呢？</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a>（简称 MP）是一个 <a target="_blank" rel="noopener" href="https://www.mybatis.org/mybatis-3/">MyBatis</a>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<p>MybatisPlus的愿景是成为 MyBatis 最好的搭档，就像 <a target="_blank" rel="noopener" href="https://baomidou.com/img/contra.jpg">魂斗罗</a> 中的 1P、2P，基友搭配，效率翻倍。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/07/21/dUAkeOP9FfVarRL.png" alt="img"></p>
<p>官方网站地址：<a target="_blank" rel="noopener" href="https://baomidou.com/">https://baomidou.com</a></p>
<p>MybatisPlus具有以下特性：</p>
<ul>
<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li>
<li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li>
<li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li>
<li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li>
<li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li>
<li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li>
<li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li>
<li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li>
<li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li>
<li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li>
<li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li>
<li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li>
</ul>
<p>框架整体结构如下：</p>
<p><img src="https://s2.loli.net/2023/07/21/fwAQGv43HdRnyI7.jpg" alt="framework"></p>
<p>不过，光说还是不能体会到它带来的便捷性，我们接着就来上手体验一下。</p>
<h4 id="快速上手-1"><a href="#快速上手-1" class="headerlink" title="快速上手"></a>快速上手</h4><p>跟之前一样，还是添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件依然只需要配置数据源即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>然后依然是实体类，可以直接映射到数据库中的表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span>  <span class="comment">//对应的表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span>   <span class="comment">//对应的主键</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="meta">@TableField(&quot;name&quot;)</span>   <span class="comment">//对应的字段</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="meta">@TableField(&quot;email&quot;)</span></span><br><span class="line">    String email;</span><br><span class="line">    <span class="meta">@TableField(&quot;password&quot;)</span></span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，我们就可以编写一个Mapper来操作了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">  	<span class="comment">//使用方式与JPA极其相似，同样是继承一个基础的模版Mapper</span></span><br><span class="line">  	<span class="comment">//这个模版里面提供了预设的大量方法直接使用，跟JPA如出一辙</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们就来写一个简单测试用例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    UserMapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(mapper.selectById(<span class="number">1</span>));  <span class="comment">//同样可以直接selectById，非常快速方便</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个Mapper提供的方法还是很丰富的：</p>
<p><img src="https://s2.loli.net/2023/07/21/R7fhN5UtAOPFe4M.png" alt="image-20230721133315171"></p>
<p>后续的板块我们将详细介绍它的使用方式。</p>
<h4 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h4><p>对于一些复杂查询的情况，MybatisPlus支持我们自己构造QueryWrapper用于复杂条件查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();    <span class="comment">//复杂查询可以使用QueryWrapper来完成</span></span><br><span class="line">  	wrapper</span><br><span class="line">            .select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;email&quot;</span>, <span class="string">&quot;password&quot;</span>)    <span class="comment">//可以自定义选择哪些字段</span></span><br><span class="line">            .ge(<span class="string">&quot;id&quot;</span>, <span class="number">2</span>)     			<span class="comment">//选择判断id大于等于1的所有数据</span></span><br><span class="line">            .orderByDesc(<span class="string">&quot;id&quot;</span>);   <span class="comment">//根据id字段进行降序排序</span></span><br><span class="line">    System.out.println(mapper.selectList(wrapper));   <span class="comment">//Mapper同样支持使用QueryWrapper进行查询</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用上面的QueryWrapper对象进行查询，也就等价于下面的SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,email,password <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">2</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>

<p>我们可以在配置中开启SQL日志打印：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>

<p>最后得到的结果如下：</p>
<p><img src="https://s2.loli.net/2023/07/21/FxOfrnERhVPi8tu.png" alt="image-20230721160951500"></p>
<p>有些时候我们遇到需要批处理的情况，也可以直接使用批处理操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//支持批处理操作，我们可以一次性删除多个指定ID的用户</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mapper.deleteBatchIds(List.of(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/07/21/lwaJUF3g2opbWZG.png" alt="image-20230721190139253"></p>
<p>我们也可以快速进行分页查询操作，不过在执行前我们需要先配置一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">      	<span class="comment">//添加分页拦截器到MybatisPlusInterceptor中</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以愉快地使用分页功能了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这里我们将用户表分2页，并获取第一页的数据</span></span><br><span class="line">    Page&lt;User&gt; page = mapper.selectPage(Page.of(<span class="number">1</span>, <span class="number">2</span>), Wrappers.emptyWrapper());</span><br><span class="line">    System.out.println(page.getRecords());   <span class="comment">//获取分页之后的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/07/21/XMPLWB3N6VpHUkG.png" alt="image-20230721185519292"></p>
<p>对于数据更新操作，我们也可以使用UpdateWrapper非常方便的来完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    UpdateWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper</span><br><span class="line">            .set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lbw&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(mapper.update(<span class="literal">null</span>, wrapper));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以快速完成更新操作了：</p>
<p><img src="https://s2.loli.net/2023/07/21/W1e8fFuUwSpi7Cg.png" alt="image-20230721162409308"></p>
<p>QueryWrapper和UpdateWrapper还有专门支持Java 8新增的Lambda表达式的特殊实现，可以直接以函数式的形式进行编写，使用方法是一样的，这里简单演示几个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers</span><br><span class="line">                .&lt;User&gt;lambdaQuery()</span><br><span class="line">                .eq(User::getId, <span class="number">2</span>)   <span class="comment">//比如我们需要选择id为2的用户，前面传入方法引用，后面比的值</span></span><br><span class="line">                .select(User::getName, User::getId);   <span class="comment">//比如我们只需要选择name和id，那就传入对应的get方法引用</span></span><br><span class="line">        System.out.println(mapper.selectOne(wrapper));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过感觉可读性似乎没有不用Lambda高啊。</p>
<h4 id="接口基本操作"><a href="#接口基本操作" class="headerlink" title="接口基本操作"></a>接口基本操作</h4><p>虽然使用MybatisPlus提供的BaseMapper已经很方便了，但是我们的业务中，实际上很多时候也是一样的工作，都是去简单调用底层的Mapper做一个很简单的事情，那么能不能干脆把Service也给弄个模版？MybatisPlus为我们提供了很方便的CRUD接口，直接实现了各种业务中会用到的增删改查操作。</p>
<p>我们只需要继承即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">  	<span class="comment">//除了继承模版，我们也可以把它当成普通Service添加自己需要的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们还需要编写一个实现类，这个实现类就是UserService的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>   <span class="comment">//需要继承ServiceImpl才能实现那些默认的CRUD方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用起来也很方便，整合了超多方法：</p>
<p><img src="https://s2.loli.net/2023/07/21/l5Vkb9dgtJcyL4R.png" alt="image-20230721181359616"></p>
<p>比如我们想批量插入一组用户数据到数据库中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = List.of(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xxx&quot;</span>), <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;yyy&quot;</span>));</span><br><span class="line">  	<span class="comment">//预设方法中已经支持批量保存了，这相比我们直接用for效率高不少</span></span><br><span class="line">    service.saveBatch(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有更加方便快捷的保存或更新操作，当数据不存在时（通过主键ID判断）则插入新数据，否则就更新数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    service.saveOrUpdate(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;aaa&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以直接使用Service来进行链式查询，写法非常舒服：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">one</span> <span class="operator">=</span> service.query().eq(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>).one();</span><br><span class="line">    System.out.println(one);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新版代码生成器"><a href="#新版代码生成器" class="headerlink" title="新版代码生成器"></a>新版代码生成器</h4><p>最后我们再来隆重介绍一下MybatisPlus的代码生成器，这个东西可谓是拯救了千千万万学子的毕设啊。</p>
<p>它能够根据数据库做到代码的一键生成，能做到什么程度呢？</p>
<p><img src="https://s2.loli.net/2023/07/21/lGT4g5Y6Heqavsw.png" alt="image-20230721200757985"></p>
<p>你没看错，整个项目从Mapper到Controller，所有的东西全部都给你生成好了，你只管把需要补充的业务给写了就行，这是真正的把饭给喂到你嘴边的行为，是广大学子的毕设大杀器。</p>
<p>那么我们就来看看，这玩意怎么去用的，首先我们需要先把整个项目的数据库给创建好，创建好之后，我们继续下一步，这里我们从头开始创建一个项目，感受一下它的强大，首先创建一个普通的SpringBoot项目：</p>
<p><img src="https://s2.loli.net/2023/07/21/bIZ9D2cA7XsgSoU.png" alt="image-20230721202019230"></p>
<p>接着我们导入一会需要用到的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后再配置一下数据源：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>接着我们就可以开始编写自动生成脚本了，这里依然选择测试类，用到<code>FastAutoGenerator</code>作为生成器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">      FastAutoGenerator</span><br><span class="line">        			<span class="comment">//首先使用create来配置数据库链接信息</span></span><br><span class="line">              .create(<span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>.Builder(dataSource))</span><br><span class="line">              .execute();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>接着我们配置一下全局设置，这些会影响一会生成的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    FastAutoGenerator</span><br><span class="line">            .create(<span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>.Builder(dataSource))</span><br><span class="line">            .globalConfig(builder -&gt; &#123;</span><br><span class="line">                builder.author(<span class="string">&quot;lbw&quot;</span>);              <span class="comment">//作者信息，一会会变成注释</span></span><br><span class="line">                builder.commentDate(<span class="string">&quot;2024-01-01&quot;</span>);  <span class="comment">//日期信息，一会会变成注释</span></span><br><span class="line">                builder.outputDir(<span class="string">&quot;src/main/java&quot;</span>); <span class="comment">//输出目录设置为当前项目的目录</span></span><br><span class="line">            &#125;)</span><br><span class="line">            .execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是打包设置，也就是项目的生成的包等等，这里简单配置一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    FastAutoGenerator</span><br><span class="line">            ...</span><br><span class="line">      			<span class="comment">//打包设置，这里设置一下包名就行，注意跟我们项目包名设置为一致的</span></span><br><span class="line">      			.packageConfig(builder -&gt; builder.parent(<span class="string">&quot;com.example&quot;</span>))</span><br><span class="line">      			.strategyConfig(builder -&gt; &#123;</span><br><span class="line">                    <span class="comment">//设置为所有Mapper添加@Mapper注解</span></span><br><span class="line">                    builder</span><br><span class="line">                            .mapperBuilder()</span><br><span class="line">                            .mapperAnnotation(Mapper.class)</span><br><span class="line">                            .build();</span><br><span class="line">            &#125;)</span><br><span class="line">            .execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们就可以直接执行了这个脚本了：</p>
<p><img src="https://s2.loli.net/2023/07/21/SdDRqZPnNrkeKjG.png" alt="image-20230721203819514"></p>
<p>现在，可以看到我们的项目中已经出现自动生成代码了：</p>
<p><img src="https://s2.loli.net/2023/07/21/pKMnwFZEOBmLXDy.png" alt="image-20230721204011913"></p>
<p>我们也可以直接运行这个项目：</p>
<p><img src="https://s2.loli.net/2023/07/21/CEdRz5wgaoxUjFJ.png" alt="image-20230721210417345"></p>
<p>速度可以说是非常之快，一个项目模版就搭建完成了，我们只需要接着写业务就可以了，当然如果各位小伙伴需要更多定制化的话，可以在官网查看其他的配置：<a target="_blank" rel="noopener" href="https://baomidou.com/pages/981406/">https://baomidou.com/pages/981406/</a></p>
<p>对于一些有特殊要求的用户来说，我们希望能够以自己的模版来进行生产，怎么才能修改它自动生成的代码模版呢，我们可以直接找到<code>mybatis-plus-generator</code>的源码：</p>
<p><img src="https://s2.loli.net/2023/07/21/lxaBgGPubOkptCT.png" alt="image-20230721204530505"></p>
<p>生成模版都在在这个里面有写，我们要做的就是去修改这些模版，变成我们自己希望的样子，由于默认的模版解析引擎为Velocity，我们需要复制以<code>.vm</code>结尾的文件到<code>resource</code>随便一个目录中，然后随便改：</p>
<p><img src="https://s2.loli.net/2023/07/21/gZlbG9JDIa3kSMO.png" alt="image-20230721210716832"></p>
<p>接着我们配置一下模版：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    FastAutoGenerator</span><br><span class="line">            ...</span><br><span class="line">      			.strategyConfig(builder -&gt; &#123;</span><br><span class="line">                builder</span><br><span class="line">                        .mapperBuilder()</span><br><span class="line">                        .enableFileOverride()   <span class="comment">//开启文件重写，自动覆盖新的</span></span><br><span class="line">                        .mapperAnnotation(Mapper.class)</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;)</span><br><span class="line">            .templateConfig(builder -&gt; &#123;</span><br><span class="line">                builder.mapper(<span class="string">&quot;/template/mapper.java.vm&quot;</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">            .execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，新生成的代码中就是按照我们自己的模版来定义了:</p>
<p><img src="https://s2.loli.net/2023/07/21/K6DufSwG3hdqPsr.png" alt="image-20230721211002961"></p>
<p>有了代码生成器，我们工 (划) 作 (水) 效率更上一层楼啦~</p>
<h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><p>前后端分离是一种软件架构模式，它将前端和后端的开发职责分开，使得前端和后端可以独立进行开发、测试和部署。在之前，我们都是编写Web应用程序，但是随着时代发展，各种桌面App、手机端App还有小程序层出不穷，这都完全脱离我们之前的开发模式，客户端和服务端的划分越来越明显，前后端分离开发势在必行。</p>
<p>在前后端分离架构中，前端主要负责展示层的开发，包括用户界面的设计、用户交互的实现等。前端使用一些技术栈，如Vue、React等技术来实现用户界面，同时通过Ajax、Axios等技术与后端进行数据的交互，这样前端无论使用什么技术进行开发，都与后端无关，受到的限制会小很多。</p>
<p>后端主要负责业务逻辑的处理和数据的存储，包括用户认证、数据验证、数据处理、数据库访问等，我们在SSM阶段就已经给各位小伙伴介绍过了前后端开发的相关思路了，实际上后端只需要返回前端需要的数据即可，我们一般使用JSON格式进行返回。</p>
<p>前后端分离架构的优势包括：</p>
<ul>
<li>前后端可以同时独立进行开发，提高开发效率。</li>
<li>前端可以灵活选择技术栈和框架，提供更好的用户体验。</li>
<li>后端可以专注于业务逻辑的实现，提高代码的可维护性。</li>
<li>前后端通过接口进行通信，使得前端和后端可以分别进行部署，提高系统的可扩展性和灵活性。</li>
</ul>
<p><img src="https://s2.loli.net/2023/07/22/8Zxp5PVjN7zfn6b.png" alt="image-20230722122002573"></p>
<p>然而，前后端分离架构也存在一些挑战，包括接口设计的复杂性、前后端协作的沟通成本等。因此，在选择前后端分离架构时，需要综合考虑项目的特点和团队成员的技能，以及开发周期等因素。</p>
<p>我们介绍两种实现前后端分离的方案。</p>
<h3 id="基于Session的分离（有状态）"><a href="#基于Session的分离（有状态）" class="headerlink" title="基于Session的分离（有状态）"></a>基于Session的分离（有状态）</h3><p>基于Cookie的前后端分离是最简单的一种，也是更接近我们之前学习的一种。在之前，我们都是使用SpringSecurity提供的默认登录流程完成验证。</p>
<p>我们发现，实际上SpringSecurity在登录之后，会利用Session机制记录用户的登录状态，这就要求我们每次请求的时候都需要携带Cookie才可以，因为Cookie中存储了用于识别的JSESSIONID数据。因此，要实现前后端分离，我们只需要稍微修改一下就可以实现了，这对于小型的单端应用程序非常友好。</p>
<h4 id="学习环境搭建"><a href="#学习环境搭建" class="headerlink" title="学习环境搭建"></a>学习环境搭建</h4><p>考虑到各位小伙伴没有学习过Vue等前端框架，这里我们依然使用前端模版进行魔改。只不过现在我们的前端页面需要单独进行部署，而不是和后端揉在一起，这里我们需要先创建一个前端项目，依赖只需勾选SpringWeb即可，主要用作反向代理前端页面：</p>
<p><img src="https://s2.loli.net/2023/07/22/A7gTxwv6r89tKh3.png" alt="image-20230722151228110"></p>
<p>如果各位小伙伴学习了Nginx代理，使用Nginx代理前端项目会更好一些。</p>
<p>接着我们将所有的前端模版文件全部丢进对应的目录中，创建一个<code>web</code>目录到resource目录下，然后放入我们前端模版的全部文件：</p>
<p><img src="https://s2.loli.net/2023/07/22/DtLF21ue7RVMQPY.png" alt="image-20230722154349756"></p>
<p>然后配置一下静态资源代理，现在我们希望的是页面直接被代理，不用我们手动去写Controller来解析视图：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">static-locations:</span> <span class="string">classpath:/web</span></span><br></pre></td></tr></table></figure>

<p>然后启动服务器就行了：</p>
<p><img src="https://s2.loli.net/2023/07/22/65snkmhyjFENTxt.png" alt="image-20230722154452928"></p>
<p>接着我们就可以随便访问我们的网站了：</p>
<p><img src="https://s2.loli.net/2023/07/22/GEWekp2IwMZhx5c.png" alt="image-20230722154659328"></p>
<p>这样前端页面就部署完成了，接着我们还需要创建一个后端项目，用于去编写我们的后端，选上我们需要的一些依赖：</p>
<p><img src="https://s2.loli.net/2023/07/22/vt52ogbLp8YN1Im.png" alt="image-20230722155049948"></p>
<p>接着我们需要修改一下后端服务器的端口，因为现在我们要同时开两个服务器，一个是负责部署前端的，一个是负责部署后端的，这样就是标准的前后端分离了，所以说为了防止端口打架，我们就把端口开放在8081上：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>

<p>现在启动这两个服务器，我们的学习环境就搭建好了。</p>
<h4 id="实现登录授权和跨域处理"><a href="#实现登录授权和跨域处理" class="headerlink" title="实现登录授权和跨域处理"></a>实现登录授权和跨域处理</h4><p>在之前，我们的登录操作以及登录之后的页面跳转都是由SpringSecurity来完成，但是现在前后端分离之后，整个流程发生了变化，现在前端仅仅是调用登录接口进行一次校验即可，而后端只需要返回本次校验的结果，由前端来判断是否校验成功并跳转页面：</p>
<p><img src="https://s2.loli.net/2023/07/22/yZpHd4wcikVxhta.png" alt="image-20230722164431249"></p>
<p>因此，现在我们只需要让登录模块响应一个JSON数据告诉前端登录成功与否即可，当然，前端在发起请求的时候依然需要携带Cookie信息，否则后端不认识是谁。</p>
<p>现在我们就来尝试实现一下这种模式，首先我们配置一下SpringSecurity的相关接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> http</span><br><span class="line">                .authorizeHttpRequests(conf -&gt; &#123;</span><br><span class="line">                    conf.anyRequest().authenticated();</span><br><span class="line">                &#125;)</span><br><span class="line">                .formLogin(conf -&gt; &#123;</span><br><span class="line">                  	<span class="comment">//一般分离之后，为了统一规范接口，使用 /api/模块/功能 的形式命名接口</span></span><br><span class="line">                    conf.loginProcessingUrl(<span class="string">&quot;/api/auth/login&quot;</span>);</span><br><span class="line">                    conf.permitAll();</span><br><span class="line">                &#125;)</span><br><span class="line">                .csrf(AbstractHttpConfigurer::disable)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这样成功定义了登录接口相关内容，但是怎么才能让SpringSecurity在登录成功之后返回一个JSON数据给前端而不是默认的重定向呢？这时我们可以手动设置SuccessHandler和FailureHandler来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="keyword">return</span> http</span><br><span class="line">              ...</span><br><span class="line">              .formLogin(conf -&gt; &#123;</span><br><span class="line">                  conf.loginProcessingUrl(<span class="string">&quot;/api/auth/login&quot;</span>);</span><br><span class="line">                	<span class="comment">//使用自定义的成功失败处理器</span></span><br><span class="line">                  conf.failureHandler(<span class="built_in">this</span>::onAuthenticationFailure);</span><br><span class="line">                  conf.successHandler(<span class="built_in">this</span>::onAuthenticationSuccess);</span><br><span class="line">                  conf.permitAll();</span><br><span class="line">              &#125;)</span><br><span class="line">              ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义成功失败处理器</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                               HttpServletResponse response,</span></span><br><span class="line"><span class="params">                               AuthenticationException exception)</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                               HttpServletResponse response, </span></span><br><span class="line"><span class="params">                               Authentication authentication)</span> &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>现在我们需要返回一个标准的JSON格式数据作为响应，这里我们根据Rest API标准来进行编写：</p>
<blockquote>
<p>REST API是遵循REST（Representational State Transfer, 表述性状态转移）原则的Web服务接口，下面简单介绍一下REST接口规范以及对应的响应数据该如何编写:</p>
<h3 id="1-REST接口规范"><a href="#1-REST接口规范" class="headerlink" title="1. REST接口规范"></a>1. REST接口规范</h3><ul>
<li><strong>使用HTTP方法</strong>：GET（检索资源）、POST（创建资源）、PUT（更新资源）、DELETE（删除资源）。</li>
<li><strong>无状态</strong>: REST接口要求实现无状态从而使其独立于之前的请求。</li>
<li><strong>使用正确的HTTP状态码</strong>：在HTTP响应中反馈操作的结果（例如，200表示成功，404表示资源不存在等）。</li>
<li><strong>URI 应该清晰易懂</strong>：URI应能清晰地指示出所引用资源的类型和编号，并能易于理解和使用。</li>
</ul>
<h3 id="2-响应数据格式"><a href="#2-响应数据格式" class="headerlink" title="2. 响应数据格式"></a>2. 响应数据格式</h3><p>REST应答一般使用的格式为JSON，以下是一个标准的JSON响应数据样例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Tom&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">18</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;查询成功&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>字段的含义分别为：</p>
<ul>
<li><strong>code</strong>：HTTP状态码，表示请求的结果。常见的有200（成功）、400（客户端错误）、500（服务器错误）等。</li>
<li><strong>data</strong>：响应的真实数据。在上例中，是一个包含用户信息的对象。</li>
<li><strong>message</strong>：请求响应信息，常用于描述请求处理结果。</li>
</ul>
<p>上述都是建议的最佳实践，实际应用中可以根据具体的业务需求进行适当的调整。</p>
</blockquote>
<p>这里我们创建一个实体类来装载响应数据，可以使用记录类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">RestBean</span>&lt;T&gt; (<span class="type">int</span> code, T data, String message) &#123;</span><br><span class="line">		<span class="comment">//写几个工具方法，用于快速创建RestBean对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestBean&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestBean</span>&lt;&gt;(<span class="number">200</span>, data, <span class="string">&quot;请求成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestBean&lt;T&gt; <span class="title function_">failure</span><span class="params">(<span class="type">int</span> code, String message)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestBean</span>&lt;&gt;(code, <span class="literal">null</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestBean&lt;T&gt; <span class="title function_">failure</span><span class="params">(<span class="type">int</span> code)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> failure(code, <span class="string">&quot;请求失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//将当前对象转换为JSON格式的字符串用于返回</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">asJsonString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JSONObject.toJSONString(<span class="built_in">this</span>, JSONWriter.Feature.WriteNulls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们稍微设置一下对应的Handler即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                               HttpServletResponse response,</span></span><br><span class="line"><span class="params">                               AuthenticationException exception)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    	response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">      <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">      writer.write(RestBean.failure(<span class="number">401</span>, exception.getMessage()).asJsonString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                               HttpServletResponse response,</span></span><br><span class="line"><span class="params">                               Authentication authentication)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    	response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">      <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">      writer.write(RestBean.success(authentication.getName()).asJsonString());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>现在我们就可以使用API测试工具来调试一下了：</p>
<p><img src="https://s2.loli.net/2023/07/23/EiMUuCjcKpnOmRb.png" alt="image-20230723193442527"></p>
<p>可以看到响应的结果是标准的JSON格式数据，而不是像之前那样重定向到一个页面，这样前端发起的异步请求就可以进行快速判断了。</p>
<p>我们来尝试写一个简单的前端逻辑试试看，这里依然引入Axios框架来发起异步请求：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios@1.1.2/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        axios.<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:8081/api/auth/login&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">username</span>: <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username&#x27;</span>).<span class="property">value</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">password</span>: <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;password&#x27;</span>).<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">        &#125;, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">headers</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">          	<span class="attr">withCredentials</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">        &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(data.<span class="property">code</span> === <span class="number">200</span>) &#123;  <span class="comment">//通过状态码进行判断</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;/index.html&#x27;</span>  <span class="comment">//登录成功进入主页</span></span></span><br><span class="line"><span class="language-javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&#x27;登录失败：&#x27;</span>+data.<span class="property">message</span>)   <span class="comment">//登录失败返回弹窗</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可能会有小伙伴好奇，这个前端不是每个页面都能随便访问吗，这登录跟不登录有啥区别？实际上我们的前端开发者会在前端做相应的路由以及拦截来控制页面的跳转，我们后端开发者无需担心，我们只需要保证自己返回的数据是准确无误的即可，其他的交给前端小姐姐就好，这里我们只是做个样子。</p>
<p>当点击按钮时就能发起请求了，但是我们现在遇到了一个新的问题：</p>
<p><img src="https://s2.loli.net/2023/07/23/KYULQNoFsHbm3zg.png" alt="image-20230723190406008"></p>
<p>我们在发起登录请求时，前端得到了一个跨域请求错误，这是因为我们前端的站点和后端站点不一致导致的，浏览器为了用户的安全，防止网页中一些恶意脚本跨站请求数据，会对未经许可的跨域请求发起拦截。那么，我们怎么才能让这个请求变成我们许可的呢？对于跨域问题，是属于我们后端需要处理的问题，跟前端无关，我们需要在响应的时候，在响应头中添加一些跨域属性，来告诉浏览器从哪个站点发来的跨域请求是安全的，这样浏览器就不会拦截了。</p>
<p>那么如何进行配置呢，我们现在使用了SpringSecurity框架，可以直接进行跨域配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> http</span><br><span class="line">            ...</span><br><span class="line">            .cors(conf -&gt; &#123;</span><br><span class="line">                <span class="type">CorsConfiguration</span> <span class="variable">cors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">              	<span class="comment">//添加前端站点地址，这样就可以告诉浏览器信任了</span></span><br><span class="line">              	cors.addAllowedOrigin(<span class="string">&quot;http://localhost:8080&quot;</span>);</span><br><span class="line">                <span class="comment">//虽然也可以像这样允许所有 cors.addAllowedOriginPattern(&quot;*&quot;);</span></span><br><span class="line">              	<span class="comment">//但是这样并不安全，我们应该只许可给我们信任的站点</span></span><br><span class="line">                cors.setAllowCredentials(<span class="literal">true</span>);  <span class="comment">//允许跨域请求中携带Cookie</span></span><br><span class="line">                cors.addAllowedHeader(<span class="string">&quot;*&quot;</span>);   <span class="comment">//其他的也可以配置，为了方便这里就 * 了</span></span><br><span class="line">                cors.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                cors.addExposedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">                source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, cors);  <span class="comment">//直接针对于所有地址生效</span></span><br><span class="line">                conf.configurationSource(source);</span><br><span class="line">            &#125;)</span><br><span class="line">            ...</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当我们再次重启服务器，返回的响应头中都会携带跨域相关的信息，这样浏览器就不会进行拦截了：</p>
<p><img src="https://s2.loli.net/2023/07/23/QVFEWknMdujomqi.png" alt="image-20230723192217101"></p>
<p>这样就可以实现前后端分离的登录模式了：</p>
<p><img src="https://s2.loli.net/2023/07/23/1GpZuQUawM48eVq.png" alt="image-20230723194030641"></p>
<p>由于记住我功能和退出登录操作跟之前是一样的配置，这里我们就不进行演示了。</p>
<h4 id="响应JSON化"><a href="#响应JSON化" class="headerlink" title="响应JSON化"></a>响应JSON化</h4><p>前面我们完成了前后端分离的登录模式，我们来看看一般的业务接口该如何去实现，比如这里我们写一个非常简单的的用户名称获取接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>   <span class="comment">//为了方便，我们一律使用RestController，这样每个请求默认都返回JSON对象</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/user&quot;)</span>   <span class="comment">//用户相关的接口，路径可以设置为/api/user/xxxx</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/name&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestBean&lt;String&gt; <span class="title function_">username</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">        <span class="keyword">return</span> RestBean.success(user.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样前端就可以在登录之后获取到这个接口的结果了，注意一定要在请求时携带Cookie，否则服务端无法识别身份，会直接被拦截并重定向：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:8081/api/user/name&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">withCredentials</span>: <span class="literal">true</span>  <span class="comment">//携带Cookie访问，不然服务器不认识我们</span></span></span><br><span class="line"><span class="language-javascript">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username&#x27;</span>).<span class="property">innerText</span> = data.<span class="property">data</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意一定要登录之后再请求，成功的请求结果如下：</p>
<p><img src="https://s2.loli.net/2023/07/24/L4PcVKpO2nmHG7e.png" alt="image-20230724000237828"></p>
<p>不过我们发现，我们的一些响应还是不完善，比如用户没有登录，默认还是会302重定向，但是实际上我们只需要告诉前端没有登录就行了，所以说我们修改一下未登录状态下返回的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> http</span><br><span class="line">            ...</span><br><span class="line">            .exceptionHandling(conf -&gt; &#123;</span><br><span class="line">              	<span class="comment">//配置授权相关异常处理器</span></span><br><span class="line">                conf.accessDeniedHandler(<span class="built_in">this</span>::onAccessDeny);</span><br><span class="line">              	<span class="comment">//配置验证相关异常的处理器</span></span><br><span class="line">                conf.authenticationEntryPoint(<span class="built_in">this</span>::onAuthenticationFailure);</span><br><span class="line">            &#125;)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在有三个方法，但是实际上功能都是一样的，我们可以把它们整合为同一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleProcess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                     HttpServletResponse response,</span></span><br><span class="line"><span class="params">                     Object exceptionOrAuthentication)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">      <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">      <span class="keyword">if</span>(exceptionOrAuthentication <span class="keyword">instanceof</span> AccessDeniedException exception) &#123;</span><br><span class="line">          writer.write(RestBean.failure(<span class="number">403</span>, exception.getMessage()).asJsonString());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(exceptionOrAuthentication <span class="keyword">instanceof</span> Exception exception) &#123;</span><br><span class="line">          writer.write(RestBean.failure(<span class="number">401</span>, exception.getMessage()).asJsonString());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(exceptionOrAuthentication <span class="keyword">instanceof</span> Authentication authentication)&#123;</span><br><span class="line">          writer.write(RestBean.success(authentication.getName()).asJsonString());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这样，用户在没有登录的情况下，请求接口就会返回我们的自定义JSON信息了：</p>
<p><img src="https://s2.loli.net/2023/07/24/Rf9BSVLvih1lOE2.png" alt="image-20230724002459523"></p>
<p>对于我们页面中的一些常见的异常，我们也可以编写异常处理器来将其规范化返回，比如404页面，我们可以直接配置让其抛出异常：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">throw-exception-if-no-handler-found:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">add-mappings:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>然后编写异常处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> RestBean&lt;String&gt; <span class="title function_">error</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> NoHandlerFoundException exception)  <span class="comment">//这里就大概处理一下404就行</span></span><br><span class="line">            <span class="keyword">return</span> RestBean.failure(<span class="number">404</span>, e.getMessage());  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ServletException exception)  <span class="comment">//其他的Servlet异常就返回400状态码</span></span><br><span class="line">            <span class="keyword">return</span> RestBean.failure(<span class="number">400</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> RestBean.failure(<span class="number">500</span>, e.getMessage());  <span class="comment">//其他异常直接返回500</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们的后端就返回的是非常统一的JSON格式数据了，前端开发人员只需要根据我们返回的数据编写统一的处理即可，基于Session的前后端分离实现起来也是最简单的，几乎没有多少的学习成本，跟我们之前的使用是一样的，只是现在前端单独编写了而已。</p>
<h3 id="基于Token的分离（无状态）"><a href="#基于Token的分离（无状态）" class="headerlink" title="基于Token的分离（无状态）"></a>基于Token的分离（无状态）</h3><p>基于Token的前后端分离主打无状态，无状态服务是指在处理每个请求时，服务本身不会维持任何与请求相关的状态信息。每个请求被视为独立的、自包含的操作，服务只关注处理请求本身，而不关心前后请求之间的状态变化。也就是说，用户在发起请求时，服务器不会记录其信息，而是通过用户携带的Token信息来判断是哪一个用户：</p>
<ul>
<li>有状态：用户请求接口 -&gt;  从Session中读取用户信息  -&gt;   根据当前的用户来处理业务   -&gt;  返回</li>
<li>无状态：用户携带Token请求接口    -&gt;   从请求中获取用户信息   -&gt;   根据当前的用户来处理业务   -&gt;  返回</li>
</ul>
<p>无状态服务的优点包括：</p>
<ol>
<li>服务端无需存储会话信息：传统的会话管理方式需要服务端存储用户的会话信息，包括用户的身份认证信息和会话状态。而使用Token，服务端无需存储任何会话信息，所有的认证信息都包含在Token中，使得服务端变得无状态，减轻了服务器的负担，同时也方便了服务的水平扩展。</li>
<li>减少网络延迟：传统的会话管理方式需要在每次请求中都携带会话标识，即使是无状态的RESTful API也需要携带身份认证信息。而使用Token，身份认证信息已经包含在Token中，只需要在请求的Authorization头部携带Token即可，减少了每次请求的数据量，减少了网络延迟。</li>
<li>客户端无需存储会话信息：传统的会话管理方式中，客户端需要存储会话标识，以便在每次请求中携带。而使用Token，客户端只需要保存Token即可，方便了客户端的存储和管理。</li>
<li>跨域支持：Token可以在各个不同的域名之间进行传递和使用，因为Token是通过签名来验证和保护数据完整性的，可以防止未经授权的修改。</li>
</ol>
<p>这一部分，我们将深入学习目前比较主流的基于Token的前后端分离方案。</p>
<h4 id="认识JWT令牌"><a href="#认识JWT令牌" class="headerlink" title="认识JWT令牌"></a>认识JWT令牌</h4><p>在认识Token前后端分离之前，我们需要先学习最常见的JWT令牌，官网：<a target="_blank" rel="noopener" href="https://jwt.io/">https://jwt.io</a></p>
<p>JSON Web Token令牌（JWT）是一个开放标准（<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7519">RFC 7519</a>），它定义了一种紧凑和自成一体的方式，用于在各方之间作为JSON对象安全地传输信息。这些信息可以被验证和信任，因为它是数字签名的。JWT可以使用密钥（使用<strong>HMAC</strong>算法）或使用<strong>RSA</strong>或<strong>ECDSA</strong>进行公钥&#x2F;私钥对进行签名。</p>
<p>JWT令牌的格式如下：</p>
<p><img src="https://s2.loli.net/2023/03/07/Xu8lxYhKoJNr6it.png" alt="image-20230307000004710"></p>
<p>一个JWT令牌由3部分组成：标头(Header)、有效载荷(Payload)和签名(Signature)。在传输的时候，会将JWT的钱2部分分别进行Base64编码后用<code>.</code>进行连接形成最终需要传输的字符串。</p>
<ul>
<li>标头：包含一些元数据信息，比如JWT签名所使用的加密算法，还有类型，这里统一都是JWT。</li>
<li>有效载荷：包括用户名称、令牌发布时间、过期时间、JWT ID等，当然我们也可以自定义添加字段，我们的用户信息一般都在这里存放。</li>
<li>签名：首先需要指定一个密钥，该密钥仅仅保存在服务器中，保证不能让其他用户知道。然后使用Header中指定的算法对Header和Payload进行base64加密之后的结果通过密钥计算哈希值，然后就得出一个签名哈希。这个会用于之后验证内容是否被篡改。</li>
</ul>
<p>这里还是补充一下一些概念，因为很多东西都是我们之前没有接触过的：</p>
<ul>
<li><p><strong>Base64：</strong>就是包括小写字母a-z、大写字母A-Z、数字0-9、符号”+”、”&#x2F;“一共64个字符的字符集（末尾还有1个或多个<code>=</code>用来凑够字节数），任何的符号都可以转换成这个字符集中的字符，这个转换过程就叫做Base64编码，编码之后会生成只包含上述64个字符的字符串。相反，如果需要原本的内容，我们也可以进行Base64解码，回到原有的样子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;你们可能不知道只用20万赢到578万是什么概念&quot;</span>;</span><br><span class="line">  	<span class="comment">//Base64不只是可以对字符串进行编码，任何byte[]数据都可以，编码结果可以是byte[]，也可以是字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">encodeStr</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(str.getBytes());</span><br><span class="line">    System.out.println(<span class="string">&quot;Base64编码后的字符串：&quot;</span>+encodeStr);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;解码后的字符串：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(Base64.getDecoder().decode(encodeStr)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意Base64不是加密算法，只是一种信息的编码方式而已。</p>
</li>
<li><p><strong>加密算法：</strong>加密算法分为对称加密和非对称加密，其中<strong>对称加密（Symmetric Cryptography）</strong>比较好理解，就像一把锁配了两把钥匙一样，这两把钥匙你和别人都有一把，然后你们直接传递数据，都会把数据用锁给锁上，就算传递的途中有人把数据窃取了，也没办法解密，因为钥匙只有你和对方有，没有钥匙无法进行解密，但是这样有个问题，既然解密的关键在于钥匙本身，那么如果有人不仅窃取了数据，而且对方那边的治安也不好，于是顺手就偷走了钥匙，那你们之间发的数据不就凉凉了吗。</p>
<p>因此，<strong>非对称加密（Asymmetric Cryptography）</strong>算法出现了，它并不是直接生成一把钥匙，而是生成一个公钥和一个私钥，私钥只能由你保管，而公钥交给对方或是你要发送的任何人都行，现在你需要把数据传给对方，那么就需要使用私钥进行加密，但是，这个数据只能使用对应的公钥进行解密，相反，如果对方需要给你发送数据，那么就需要用公钥进行加密，而数据只能使用私钥进行解密，这样的话就算对方的公钥被窃取，那么别人发给你的数据也没办法解密出来，因为需要私钥才能解密，而只有你才有私钥。</p>
<p>因此，非对称加密的安全性会更高一些，包括HTTPS的隐私信息正是使用非对称加密来保障传输数据的安全（当然HTTPS并不是单纯地使用非对称加密完成的，感兴趣的可以去了解一下）</p>
<p>对称加密和非对称加密都有很多的算法，比如对称加密，就有：DES、IDEA、RC2，非对称加密有：RSA、DAS、ECC</p>
</li>
<li><p><strong>不可逆加密算法：</strong>常见的不可逆加密算法有MD5, HMAC, SHA-1, SHA-224, SHA-256, SHA-384, 和SHA-512, 其中SHA-224、SHA-256、SHA-384，和SHA-512我们可以统称为SHA2加密算法，SHA加密算法的安全性要比MD5更高，而SHA2加密算法比SHA1的要高，其中SHA后面的数字表示的是加密后的字符串长度，SHA1默认会产生一个160位的信息摘要。经过不可逆加密算法得到的加密结果，是无法解密回去的，也就是说加密出来是什么就是什么了。本质上，其就是一种哈希函数，用于对一段信息产生摘要，以<strong>防止被篡改</strong>。</p>
<p>实际上这种算法就常常被用作信息摘要计算，同样的数据通过同样的算法计算得到的结果肯定也一样，而如果数据被修改，那么计算的结果肯定就不一样了。</p>
</li>
</ul>
<p>因此，JWT令牌实际上是一种经过加密的JSON数据，其中包含了用户名字、用户ID等信息，我们可以直接解密JWT令牌得到用户的信息，我们可以写一个小测试来看看，导入JWT支持库依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要生成一个JWT令牌非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwtKey</span> <span class="operator">=</span> <span class="string">&quot;abcdefghijklmn&quot;</span>;                 <span class="comment">//使用一个JWT秘钥进行加密</span></span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(jwtKey);  <span class="comment">//创建HMAC256加密算法对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> JWT.create()</span><br><span class="line">                .withClaim(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>)   <span class="comment">//向令牌中塞入自定义的数据</span></span><br><span class="line">                .withClaim(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lbw&quot;</span>)</span><br><span class="line">                .withClaim(<span class="string">&quot;role&quot;</span>, <span class="string">&quot;nb&quot;</span>)</span><br><span class="line">                .withExpiresAt(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2024</span>, Calendar.FEBRUARY, <span class="number">1</span>))  <span class="comment">//JWT令牌的失效时间</span></span><br><span class="line">                .withIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())   <span class="comment">//JWT令牌的签发时间</span></span><br><span class="line">                .sign(algorithm);    <span class="comment">//使用上面的加密算法进行加密，完成签名</span></span><br><span class="line">        System.out.println(jwtToken);   <span class="comment">//得到最终的JWT令牌</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后得到的JWT令牌就长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjoibmIiLCJuYW1lIjoibGJ3IiwiaWQiOjEsImV4cCI6NjE2NjQ4NjA4MDAsImlhdCI6MTY5MDEzMTQ3OH0.KUuGKM0OynL_DEUnRIETDBlmGjoqbt_5dP2r21ZDE1s</span><br></pre></td></tr></table></figure>

<p>我们可以使用Base64将其还原为原本的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> <span class="string">&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjoibmIiLCJuYW1lIjoibGJ3IiwiaWQiOjEsImV4cCI6NjE2NjQ4NjA4MDAsImlhdCI6MTY5MDEzMTQ3OH0.KUuGKM0OynL_DEUnRIETDBlmGjoqbt_5dP2r21ZDE1s&quot;</span>;</span><br><span class="line">        String[] split = jwtToken.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; split.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> split[i];</span><br><span class="line">            <span class="type">byte</span>[] decode = Base64.getDecoder().decode(s);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(decode));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析前面两个部分得到：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span><span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span><span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span><span class="string">&quot;HS256&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;role&quot;</span><span class="punctuation">:</span><span class="string">&quot;nb&quot;</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;lbw&quot;</span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span><span class="number">61664860800</span><span class="punctuation">,</span><span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span><span class="number">1690131478</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到确实是经过Base64加密的JSON格式数据，包括我们的自定义数据也在其中，而我们可以直接使用JWT令牌来作为我们权限校验的核心，我们可以像这样设计我们的系统：</p>
<p><img src="https://s2.loli.net/2023/07/24/4bThtMwA9XsP5uc.png" alt="image-20230724010807761"></p>
<p>首先用户还是按照正常流程进行登录，只不过用户在登录成功之后，服务端会返回一个JWT令牌用于后续请求使用，由于JWT令牌具有时效性，所以说当过期之后又需要重新登录。就像我们进入游乐园需要一张门票一样，只有持有游乐园门票才能进入游乐园游玩，如果没有门票就会被拒之门外，而游乐园门票也有时间限制，如果已经过期，我们也是没有办法进入游乐园的。</p>
<p>所以，我们只需要在后续请求中携带这个Token即可（可以放在Cookie中，也可以放在请求头中）这样服务器就可以直接从Token中解密读取到我们用户的相关信息以及判断用户是否登录过期了。</p>
<p>不过这个时候会有小伙伴疑问，既然现在用户信息都在JWT中，那要是用户随便修改里面的内容，岂不是可以以任意身份访问服务器了？这会不会存在安全隐患？对于这个问题，前面我们已经说的很清楚了，JWT实际上最后会有一个加密的签名，这个是根据秘钥+JWT本体内容计算得到的，用户在没有持有秘钥的情况下，是不可能计算得到正确的签名的，所以说服务器会在收到JWT时对签名进行重新计算，比较是否一致，来验证JWT是否被用户恶意修改，如果被修改肯定也是不能通过的。</p>
<p><img src="https://s2.loli.net/2023/07/24/17dmiHXEG4rLO6W.png" alt="image-20230724011814993"></p>
<h4 id="SpringSecurity实现JWT校验"><a href="#SpringSecurity实现JWT校验" class="headerlink" title="SpringSecurity实现JWT校验"></a>SpringSecurity实现JWT校验</h4><p>前面我们介绍了JWT的基本原理以及后端的基本校验流程，那么我们现在就来看看如何实现这样的流程。</p>
<p>SpringSecurity中并没有为我们提供预设的JWT校验模块（只有OAuth2模块才有，但是知识太超前了，我们暂时不讲解）这里我们只能手动进行整合，JWT可以存放在Cookie或是请求头中，不过不管哪种方式，我们都可以通过Request获取到对应的JWT令牌，这里我们使用比较常见的请求头携带JWT的方案，客户端发起的请求中会携带这样的的特殊请求头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer eyJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJzZWxmIiwic3ViIjoidXNlciIsImV4cCI6MTY5MDIxODE2NCwiaWF0IjoxNjkwMTgyMTY0LCJzY29wZSI6ImFwcCJ9.Z5-WMeulZyx60WeNxrQg2z2GiVquEHrsBl9V4dixbRkAD6rFp-6gCrcAXWkebs0i-we4xTQ7TZW0ltuhGYZ1GmEaj4F6BP9VN8fLq2aT7GhCJDgjikaTs-w5BbbOD2PN_vTAK_KeVGvYhWU4_l81cvilJWVXAhzMtwgPsz1Dkd04cWTCpI7ZZi-RQaBGYlullXtUrehYcjprla8N-bSpmeb3CBVM3kpAdehzfRpAGWXotN27PIKyAbtiJ0rqdvRmvlSztNY0_1IoO4TprMTUr-wjilGbJ5QTQaYUKRHcK3OJrProz9m8ztClSq0GRvFIB7HuMlYWNYwf7lkKpGvKDg</span><br></pre></td></tr></table></figure>

<p>这里的Authorization请求头就是携带JWT的专用属性，值的格式为”Bearer Token”，前面的Bearer代表身份验证方式，默认情况下有两种：</p>
<blockquote>
<p>Basic 和 Bearer 是两种不同的身份验证方式。</p>
<p>Basic 是一种基本的身份验证方式，它将用户名和密码进行base64编码后，放在 Authorization 请求头中，用于向服务器验证用户身份。这种方式不够安全，因为它将密码以明文的形式传输，容易受到中间人攻击。</p>
<p>Bearer 是一种更安全的身份验证方式，它基于令牌（Token）来验证用户身份。Bearer 令牌是由身份验证服务器颁发给客户端的，客户端在每个请求中将令牌放在 Authorization 请求头的 Bearer 字段中。服务器会验证令牌的有效性和权限，以确定用户的身份。Bearer 令牌通常使用 JSON Web Token (JWT) 的形式进行传递和验证。</p>
</blockquote>
<p>一会我们会自行编写JWT校验拦截器来处理这些信息。</p>
<p>首先我们先把用于处理JWT令牌的工具类完成一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line">  	<span class="comment">//Jwt秘钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;abcdefghijklmn&quot;</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//根据用户信息创建Jwt令牌</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJwt</span><span class="params">(UserDetails user)</span>&#123;</span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(key);</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        calendar.add(Calendar.SECOND, <span class="number">3600</span> * <span class="number">24</span> * <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">return</span> JWT.create()</span><br><span class="line">                .withClaim(<span class="string">&quot;name&quot;</span>, user.getUsername())  <span class="comment">//配置JWT自定义信息</span></span><br><span class="line">                .withClaim(<span class="string">&quot;authorities&quot;</span>, user.getAuthorities().stream().map(GrantedAuthority::getAuthority).toList())</span><br><span class="line">                .withExpiresAt(calendar.getTime())  <span class="comment">//设置过期时间</span></span><br><span class="line">                .withIssuedAt(now)    <span class="comment">//设置创建创建时间</span></span><br><span class="line">                .sign(algorithm);   <span class="comment">//最终签名</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//根据Jwt验证并解析用户信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDetails <span class="title function_">resolveJwt</span><span class="params">(String token)</span>&#123;</span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(key);</span><br><span class="line">        <span class="type">JWTVerifier</span> <span class="variable">jwtVerifier</span> <span class="operator">=</span> JWT.require(algorithm).build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DecodedJWT</span> <span class="variable">verify</span> <span class="operator">=</span> jwtVerifier.verify(token);  <span class="comment">//对JWT令牌进行验证，看看是否被修改</span></span><br><span class="line">            Map&lt;String, Claim&gt; claims = verify.getClaims();  <span class="comment">//获取令牌中内容</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().after(claims.get(<span class="string">&quot;exp&quot;</span>).asDate())) <span class="comment">//如果是过期令牌则返回null</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              	<span class="comment">//重新组装为UserDetails对象，包括用户名、授权信息等</span></span><br><span class="line">                <span class="keyword">return</span> User</span><br><span class="line">                        .withUsername(claims.get(<span class="string">&quot;name&quot;</span>).asString())</span><br><span class="line">                        .password(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                        .authorities(claims.get(<span class="string">&quot;authorities&quot;</span>).asArray(String.class))</span><br><span class="line">                        .build();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JWTVerificationException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们需要自行实现一个JwtAuthenticationFilter加入到SpringSecurity默认提供的过滤器链（有关SpringSecurity的实现原理介绍，我们在SSM中已经详细讲解过，各位小伙伴可以回顾一下）中，用于处理请求头中携带的JWT令牌，并配置登录状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;  </span><br><span class="line"><span class="comment">//继承OncePerRequestFilter表示每次请求过滤一次，用于快速编写JWT校验规则</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">      	<span class="comment">//首先从Header中取出JWT</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">      	<span class="comment">//判断是否包含JWT且格式正确</span></span><br><span class="line">        <span class="keyword">if</span> (authorization != <span class="literal">null</span> &amp;&amp; authorization.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> authorization.substring(<span class="number">7</span>);	</span><br><span class="line">          	<span class="comment">//开始解析成UserDetails对象，如果得到的是null说明解析失败，JWT有问题</span></span><br><span class="line">            <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> JwtUtils.resolveJwt(token);</span><br><span class="line">            <span class="keyword">if</span>(user != <span class="literal">null</span>) &#123;</span><br><span class="line">              	<span class="comment">//验证没有问题，那么就可以开始创建Authentication了，这里我们跟默认情况保持一致</span></span><br><span class="line">              	<span class="comment">//使用UsernamePasswordAuthenticationToken作为实体，填写相关用户信息进去</span></span><br><span class="line">                <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user, <span class="literal">null</span>, user.getAuthorities());</span><br><span class="line">                authentication.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line">              	<span class="comment">//然后直接把配置好的Authentication塞给SecurityContext表示已经完成验证</span></span><br><span class="line">                SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//最后放行，继续下一个过滤器</span></span><br><span class="line">      	<span class="comment">//可能各位小伙伴会好奇，要是没验证成功不是应该拦截吗？这个其实没有关系的</span></span><br><span class="line">      	<span class="comment">//因为如果没有验证失败上面是不会给SecurityContext设置Authentication的，后面直接就被拦截掉了</span></span><br><span class="line">      	<span class="comment">//而且有可能用户发起的是用户名密码登录请求，这种情况也要放行的，不然怎么登录，所以说直接放行就好</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们来配置一下SecurityConfiguration配置类，其实配置方法跟之前还是差不多，用户依然可以使用表单进行登录，并且登录方式也是一样的，就是有两个新增的部分需要我们注意一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> http</span><br><span class="line">          			<span class="comment">//其他跟之前一样，就省略掉了</span></span><br><span class="line">                ...  </span><br><span class="line">                <span class="comment">//将Session管理创建策略改成无状态，这样SpringSecurity就不会创建会话了，也不会采用之前那套机制记录用户，因为现在我们可以直接从JWT中获取信息</span></span><br><span class="line">                .sessionManagement(conf -&gt; &#123;</span><br><span class="line">                    conf.sessionCreationPolicy(SessionCreationPolicy.STATELESS);</span><br><span class="line">                &#125;)</span><br><span class="line">          			<span class="comment">//添加我们用于处理JWT的过滤器到Security过滤器链中，注意要放在UsernamePasswordAuthenticationFilter之前</span></span><br><span class="line">                .addFilterBefore(<span class="keyword">new</span> <span class="title class_">JwtAuthenticationFilter</span>(), UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//这个跟之前一样的写法，整合到一起处理，统一返回JSON格式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleProcess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                               HttpServletResponse response,</span></span><br><span class="line"><span class="params">                               Object exceptionOrAuthentication)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="keyword">if</span>(exceptionOrAuthentication <span class="keyword">instanceof</span> AccessDeniedException exception) &#123;</span><br><span class="line">            writer.write(RestBean.failure(<span class="number">403</span>, exception.getMessage()).asJsonString());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(exceptionOrAuthentication <span class="keyword">instanceof</span> AuthenticationException exception) &#123;</span><br><span class="line">            writer.write(RestBean.failure(<span class="number">401</span>, exception.getMessage()).asJsonString());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(exceptionOrAuthentication <span class="keyword">instanceof</span> Authentication authentication)&#123;</span><br><span class="line">          	<span class="comment">//不过这里需要注意，在登录成功的时候需要返回我们生成的JWT令牌，这样客户端下次访问就可以携带这个令牌了，令牌过期之后就需要重新登录才可以</span></span><br><span class="line">            writer.write(RestBean.success(JwtUtils.createJwt((User) authentication.getPrincipal())).asJsonString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们创建一个测试使用的Controller来看看效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么现在采用JWT之后，我们要怎么使用呢？首先我们还是使用工具来测试一下：</p>
<p><img src="https://s2.loli.net/2023/07/24/L1O8m6auYc2IFWR.png" alt="image-20230724200235358"></p>
<p>登录成功之后，可以看到现在返回给我们了一个JWT令牌，接着我们就可以使用这个令牌了。比如现在我们要访问某个接口获取数据，那么就可以携带这个令牌进行访问：</p>
<p><img src="https://s2.loli.net/2023/07/24/Hn7X5qeDf9htk6P.png" alt="image-20230724200341917"></p>
<p>注意需要在请求头中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer 刚刚获取的Token</span><br></pre></td></tr></table></figure>

<p>如果以后没有登录或者携带一个错误的JWT访问服务器，都会返回401错误：</p>
<p><img src="https://s2.loli.net/2023/07/24/ID96yY7lkr5VsPS.png" alt="image-20230724200533964"></p>
<p>我们现在来模拟一下前端操作：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  	<span class="comment">//其他都是跟之前一样的</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        axios.<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:8081/api/auth/login&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">username</span>: <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username&#x27;</span>).<span class="property">value</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">password</span>: <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;password&#x27;</span>).<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">        &#125;, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">headers</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(data.<span class="property">code</span> === <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//将得到的JWT令牌存到sessionStorage用于本次会话</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;access_token&quot;</span>, data.<span class="property">data</span>)</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;/index.html&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&#x27;登录失败：&#x27;</span>+data.<span class="property">message</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着是首页，获取信息的时候携带上JWT即可，不需要依赖Cookie了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:8081/api/user/name&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">headers</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&quot;Bearer &quot;</span>+<span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;access_token&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username&#x27;</span>).<span class="property">innerText</span> = data.<span class="property">data</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样我们就实现了基于SpringSecurity的JWT校验，整个流程还是非常清晰的。</p>
<h4 id="退出登录JWT处理"><a href="#退出登录JWT处理" class="headerlink" title="退出登录JWT处理"></a>退出登录JWT处理</h4><p>虽然我们使用JWT已经很方便了，但是有一个很严重的问题就是，我们没办法像Session那样去踢用户下线，什么意思呢？我们之前可以使用退出登录接口直接退出，用户Session中的验证信息也会被销毁，但是现在是无状态的，用户来管理Token令牌，服务端只认Token是否合法，那这个时候该怎么让用户正确退出登录呢？</p>
<p>首先我们从最简单的方案开始，我们可以直接让客户端删除自己的JWT令牌，这样不就相当于退出登录了吗，这样甚至不需要请求服务器，直接就退了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">		...</span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">logout</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//直接删除存在sessionStorage中的JWT令牌</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">sessionStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&quot;access_token&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//然后回到登录界面</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;/login.html&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样虽然是最简单粗暴的，但是存在一个问题，用户可以自行保存这个Token拿来使用。虽然客户端已经删除掉了，但是这个令牌仍然是可用的，如果用户私自保存过，那么依然可以正常使用这个令牌，这显然是有问题的。</p>
<p>目前有两种比较好的方案：</p>
<ul>
<li>黑名单方案：所有黑名单中的JWT将不可使用。</li>
<li>白名单方案：不在白名单中的JWT将不可使用。</li>
</ul>
<p>这里我们以黑名单机制为例，让用户退出登录之后，无法再次使用之前的JWT进行操作，首先我们需要给JWT额外添加一个用于判断的唯一标识符，这里就用UUID好了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;abcdefghijklmn&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJwt</span><span class="params">(UserDetails user)</span>&#123;</span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(key);</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        calendar.add(Calendar.SECOND, <span class="number">3600</span> * <span class="number">24</span> * <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">return</span> JWT.create()</span><br><span class="line">          			<span class="comment">//额外添加一个UUID用于记录黑名单，将其作为JWT的ID属性jti</span></span><br><span class="line">          			.withJWTId(UUID.randomUUID().toString())</span><br><span class="line">                .withClaim(<span class="string">&quot;name&quot;</span>, user.getUsername())</span><br><span class="line">                .withClaim(<span class="string">&quot;authorities&quot;</span>, user.getAuthorities().stream().map(GrantedAuthority::getAuthority).toList())</span><br><span class="line">                .withExpiresAt(calendar.getTime())</span><br><span class="line">                .withIssuedAt(now)</span><br><span class="line">                .sign(algorithm);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们发出去的所有令牌都会携带一个UUID作为唯一凭据，接着我们可以创建一个专属的表用于存储黑名单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;	</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashSet&lt;String&gt; blackList = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//加入黑名单方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">invalidate</span><span class="params">(String token)</span>&#123;</span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(key);</span><br><span class="line">        <span class="type">JWTVerifier</span> <span class="variable">jwtVerifier</span> <span class="operator">=</span> JWT.require(algorithm).build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DecodedJWT</span> <span class="variable">verify</span> <span class="operator">=</span> jwtVerifier.verify(token);</span><br><span class="line">            Map&lt;String, Claim&gt; claims = verify.getClaims();</span><br><span class="line">          	<span class="comment">//取出UUID丢进黑名单中</span></span><br><span class="line">            <span class="keyword">return</span> blackList.add(verify.getId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JWTVerificationException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> UserDetails <span class="title function_">resolveJwt</span><span class="params">(String token)</span>&#123;</span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(key);</span><br><span class="line">        <span class="type">JWTVerifier</span> <span class="variable">jwtVerifier</span> <span class="operator">=</span> JWT.require(algorithm).build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DecodedJWT</span> <span class="variable">verify</span> <span class="operator">=</span> jwtVerifier.verify(token);</span><br><span class="line">            <span class="comment">//判断是否存在于黑名单中，如果存在，则返回null表示失效</span></span><br><span class="line">            <span class="keyword">if</span>(blackList.contains(verify.getId()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            Map&lt;String, Claim&gt; claims = verify.getClaims();</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().after(claims.get(<span class="string">&quot;exp&quot;</span>).asDate()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> User</span><br><span class="line">                    .withUsername(claims.get(<span class="string">&quot;name&quot;</span>).asString())</span><br><span class="line">                    .password(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                    .authorities(claims.get(<span class="string">&quot;authorities&quot;</span>).asArray(String.class))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JWTVerificationException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来SecurityConfiguration中配置一下退出登录操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                 HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                 Authentication authentication)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(authorization != <span class="literal">null</span> &amp;&amp; authorization.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> authorization.substring(<span class="number">7</span>);</span><br><span class="line">          	<span class="comment">//将Token加入黑名单</span></span><br><span class="line">            <span class="keyword">if</span>(JwtUtils.invalidate(token)) &#123;</span><br><span class="line">              	<span class="comment">//只有成功加入黑名单才会退出成功</span></span><br><span class="line">                writer.write(RestBean.success(<span class="string">&quot;退出登录成功&quot;</span>).asJsonString());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        writer.write(RestBean.failure(<span class="number">400</span>, <span class="string">&quot;退出登录失败&quot;</span>).asJsonString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就成功安排上了黑名单机制，即使用户提前保存，这个Token依然是失效的：</p>
<p><img src="https://s2.loli.net/2023/07/24/4o76q5yNHkabuip.png" alt="image-20230724214624046"></p>
<p>虽然这种黑名单机制很方便，但是如果到了后面的微服务阶段，可能多个服务器都需要共享这个黑名单，这个时候我们再将黑名单存储在单个应用中就不太行了，后续我们可以考虑使用Redis服务器来存放黑名单列表，这样就可以实现多个服务器共享，并且根据JWT的过期时间合理设定黑名单中UUID的过期时间，自动清理。</p>
<h4 id="自动续签JWT令牌"><a href="#自动续签JWT令牌" class="headerlink" title="自动续签JWT令牌"></a>自动续签JWT令牌</h4><p>在有些时候，我们可能希望用户能够一直使用我们的网站，而不是JWT令牌到期之后就需要重新登录，这种情况下前端就可以配置JWT自动续签，在发起请求时如果令牌即将到期，那么就向后端发起续签请求得到一个新的JWT令牌。</p>
<p>这里我们写一个接口专门用于令牌刷新：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/auth&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/refresh&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestBean&lt;String&gt; <span class="title function_">refreshToken</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> JwtUtils.createJwt(user);</span><br><span class="line">        <span class="keyword">return</span> RestBean.success(jwt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，前端在发现令牌可用时间不足时，就会先发起一个请求自动完成续期，得到一个新的Token：</p>
<p><img src="https://s2.loli.net/2023/07/24/cqEgnQOZtFp1w7o.png" alt="image-20230724232152613"></p>
<p>我们可能还需要配置一下这种方案的请求频率，不然用户疯狂请求刷新Token就不太好了，我们同样可以借助Redis进行限流等操作，防止频繁请求，这里就不详细编写了，各位小伙伴可以自行实现。</p>
<p>我们最后可以来对比一下两种前后端分离方式的优缺点如何：</p>
<p><strong>JWT校验方案的优点：</strong></p>
<ol>
<li>无状态: JWT是无状态的，服务器不需要在后端维护用户的会话信息，可以在分布式系统中进行水平扩展，减轻服务器的负担。</li>
<li>基于Token: JWT使用token作为身份认证信息，该token可以存储用户相关的信息和权限。这样可以减少与数据库的频繁交互，提高性能。</li>
<li>安全性: JWT使用数字签名或加密算法保证token的完整性和安全性。每次请求都会验证token的合法性，防止伪造或篡改。</li>
<li>跨域支持: JWT可以在不同域之间进行数据传输，适合前后端分离的架构。</li>
</ol>
<p><strong>JWT校验方案的缺点：</strong></p>
<ol>
<li>无法做到即时失效: JWT中的token通常具有较长的有效期，一旦签发，就无法立即失效。如果需要即时失效，需要在服务端进行额外的处理。</li>
<li>信息无法撤销: JWT中的token一旦签发，除非到期或者客户端清除，无法撤销。无法中途取消和修改权限。</li>
<li>Token增大的问题: JWT中包含了用户信息和权限等，token的体积较大，每次请求都需要携带，增加了网络传输的开销。</li>
<li>动态权限管理问题: JWT无法处理动态权限管理，一旦签发的token权限发生变化，仍然有效，需要其他手段进行处理。</li>
</ol>
<p><strong>传统Session校验方案的优点：</strong></p>
<ol>
<li>即时失效: Session在服务器端管理，可以通过设置过期时间或手动删除实现即时失效，保护会话的安全性。</li>
<li>信息即时撤销: 服务器端可以随时撤销或修改Session的信息和权限。</li>
<li>灵活的权限管理: Session方案可以更灵活地处理动态权限管理，可以根据具体场景进行即时调整。</li>
</ol>
<p><strong>传统Session校验方案的缺点：</strong></p>
<ol>
<li>状态维护: 传统Session需要在服务器端维护会话状态信息，增加了服务器的负担，不利于系统的横向扩展。</li>
<li>性能开销: 每次请求都需要在服务器端进行会话状态的校验和读写操作，增加了性能开销。</li>
<li>跨域问题: Session方案在跨域时存在一些问题，需要进行额外的处理。</li>
<li>无法分布式共享: 传统Session方案不适用于多个服务器之间共享会话信息的场景，需要额外的管理和同步机制。</li>
</ol>
<p>综上所述，JWT校验方案适用于无状态、分布式系统，几乎所有常见的前后端分离的架构都可以采用这种方案。而传统Session校验方案适用于需要即时失效、即时撤销和灵活权限管理的场景，适合传统的服务器端渲染应用，以及客户端支持Cookie功能的前后端分离架构。在选择校验方案时，需要根据具体的业务需求和技术场景进行选择。</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> SpringBoot</li>
        <li><strong>Author:</strong> Yie</li>
        <li><strong>Created at
                :</strong> 2023-10-07 21:59:00</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2023-10-07 21:59:00
            </li>
        
        <li>
            <strong>Link:</strong> https://yie007.github.io/2023/10/07/SpringBoot/
        </li>
        <li>
            <strong>
                License:
            </strong>
            
            This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>.
            

        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/SpringBoot/">#SpringBoot</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                        rel="prev"
                        href="/2023/10/07/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">Cookie、Session、Token、JWT</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                        rel="next"
                        href="/2023/09/30/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">设计原则与设计模式</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">SpringBoot</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringBoot"><span class="nav-text">SpringBoot</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B"><span class="nav-text">快速上手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%81%E9%80%9F%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="nav-text">极速创建项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E5%BF%AB%E9%80%9F%E6%95%B4%E5%90%88"><span class="nav-text">常用模块快速整合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E8%A1%8C%E5%99%A8"><span class="nav-text">自定义运行器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="nav-text">配置文件介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%BB%E6%9D%BE%E6%89%93%E5%8C%85%E8%BF%90%E8%A1%8C"><span class="nav-text">轻松打包运行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D"><span class="nav-text">日志系统介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E9%97%A8%E9%9D%A2%E5%92%8C%E6%97%A5%E5%BF%97%E5%AE%9E%E7%8E%B0"><span class="nav-text">日志门面和日志实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E9%A1%B9%E7%9B%AE%E6%97%A5%E5%BF%97%E4%BF%A1%E6%81%AF"><span class="nav-text">打印项目日志信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AELogback%E6%97%A5%E5%BF%97"><span class="nav-text">配置Logback日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Banner%E5%B1%95%E7%A4%BA"><span class="nav-text">自定义Banner展示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-text">多环境配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D"><span class="nav-text">常用框架介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E6%A8%A1%E5%9D%97"><span class="nav-text">邮件发送模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E8%A7%84%E5%88%99%E6%A0%A1%E9%AA%8C"><span class="nav-text">接口规则校验</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92"><span class="nav-text">数据交互</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC%E4%BA%A4%E4%BA%92%E6%A1%86%E6%9E%B6"><span class="nav-text">JDBC交互框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JPA%E6%A1%86%E6%9E%B6"><span class="nav-text">JPA框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MybatisPlus%E6%A1%86%E6%9E%B6"><span class="nav-text">MybatisPlus框架</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB"><span class="nav-text">前后端分离</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8ESession%E7%9A%84%E5%88%86%E7%A6%BB%EF%BC%88%E6%9C%89%E7%8A%B6%E6%80%81%EF%BC%89"><span class="nav-text">基于Session的分离（有状态）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-REST%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83"><span class="nav-text">1. REST接口规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="nav-text">2. 响应数据格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EToken%E7%9A%84%E5%88%86%E7%A6%BB%EF%BC%88%E6%97%A0%E7%8A%B6%E6%80%81%EF%BC%89"><span class="nav-text">基于Token的分离（无状态）</span></a></li></ol></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">Yie</a>
        </div>
        
            <script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.5.0</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>



    
<script src="/js/tools/localSearch.js" type="module"></script>




    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>







<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/libs/anime.min.js"></script>

        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


</body>
</html>
