<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cookie、Session、Token、JWT</title>
    <url>/2023/10/07/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT/</url>
    <content><![CDATA[<h1 id="Cookie、Session、Token、JWT"><a href="#Cookie、Session、Token、JWT" class="headerlink" title="Cookie、Session、Token、JWT"></a>Cookie、Session、Token、JWT</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>参考文章：</p>
<p><a href="https://juejin.cn/post/7167718864447340558">https://juejin.cn/post/7167718864447340558</a></p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="为什么会出现Cookie"><a href="#为什么会出现Cookie" class="headerlink" title="为什么会出现Cookie"></a>为什么会出现Cookie</h3><p>HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息)：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</p>
<h3 id="创建-Cookie"><a href="#创建-Cookie" class="headerlink" title="创建 Cookie"></a>创建 Cookie</h3><p>当接收到客户端发出的 HTTP 请求时，服务器可以发送带有响应的 <code>Set-Cookie</code> 标头，<strong>Cookie 通常由浏览器存储</strong>，然后将 Cookie 与 HTTP 标头一同向服务器发出请求。</p>
<p><code>Set-Cookie</code> HTTP 响应标头将 cookie 从服务器发送到用户代理。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e399c20870a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"> 此标头告诉客户端存储 Cookie</p>
<p>现在，随着对服务器的每个新请求，浏览器将使用 Cookie 头将所有以前存储的 Cookie 发送回服务器。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17147e399aefd856~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="什么是Session"><a href="#什么是Session" class="headerlink" title="什么是Session"></a>什么是Session</h3><p>session 是另一种记录服务器和客户端会话状态的机制，是<strong>基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie中</strong></p>
<h3 id="Session认证流程"><a href="#Session认证流程" class="headerlink" title="Session认证流程"></a>Session认证流程</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/29/16f523a04d0b3cf5~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="session.png"></p>
<ul>
<li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 <code>Session</code></li>
<li>请求返回时将此 Session 的唯一标识信息 <code>SessionID</code> 返回给浏览器</li>
<li>浏览器接收到服务器返回的 <code>SessionID</code> 信息后，会将此信息存入到 <code>Cookie</code> 中，同时 <code>Cookie</code> 记录此 <code>SessionID</code> 属于哪个域名</li>
<li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 <code>Cookie</code> 信息，如果存在自动将 <code>Cookie</code> 信息也发送给服务端，服务端会从 <code>Cookie</code> 中获取<code> SessionID</code>，再根据 <code>SessionID</code> 查找对应的 <code>Session</code> 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 <code>Session</code> 证明用户已经登录可执行后面操作。</li>
</ul>
<p>根据以上流程可知，<strong>SessionID 是连接 Cookie 和 Session 的一道桥梁</strong>，大部分系统也是根据此原理来验证用户登录状态。</p>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><h3 id="什么是Token"><a href="#什么是Token" class="headerlink" title="什么是Token"></a>什么是Token</h3><p>访问资源接口（API）时所需要的资源凭证，<strong>存储在客户端</strong></p>
<p>简单 token 的组成：  <code>uid</code>(用户唯一的身份标识)、<code>time</code>(当前时间的时间戳)、<code>sign</code>（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</p>
<h3 id="Token-的身份验证流程"><a href="#Token-的身份验证流程" class="headerlink" title="Token 的身份验证流程"></a>Token 的身份验证流程</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/29/16f523a04d9c745f~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p>
<ul>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，去验证用户名与密码</li>
<li>验证成功后，<code>服务端</code>会签发一个 <code>token</code>并把这个 <code>token</code> 发送给客户端</li>
<li>客户端收到 <code>token</code> 以后，会把它存储起来，比如放在 <code>cookie</code> 里或者 <code>localStorage</code> 里</li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 <code>token</code></li>
<li>服务端收到请求，然后去验证客户端请求里面带着的 <code>token</code> ，如果验证成功，就向客户端返回请求的数据</li>
</ul>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h3><p>JSON Web Token（简称 JWT）是目前最流行的<strong>跨域认证</strong>解决方案。</p>
<h3 id="JWT的认证流程"><a href="#JWT的认证流程" class="headerlink" title="JWT的认证流程"></a>JWT的认证流程</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5351322f0b024190ad0613185354d000~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p>
<ul>
<li>第一步,用户登陆，用户通过用户名和密码登陆，如果登陆成功，服务器就会返回一个加密文档，这个文档就是<code>jwt</code>，其中包含除了用户密码以外的全部的认证信息，包括用户名、email、角色、权限等等，而客户端在拿到<code>jwt</code>以后就可以把它保存起来了，可以保存<code>cookie</code>中，也可以保存在<code>LocalStorage</code>里面，而生成<code>jwt</code>以后不需要在服务器上保存。</li>
<li>第二步，用户需要访问某些资源，这个时候用户需要把<code>jwt</code>放在http请求的<code>header</code>中，与http请求一同发送给服务器。服务器取得<code>jwt</code>以后，会使用自己的私钥来给给<code>jwt</code>文档解密，如果解密成功而且数据依然有效，则代表用户已经登陆了，如果<code>jwt</code>所描述的用户权限允许该用户访问资源，服务器就会把资源信息通过http响应发送回到客户端。</li>
</ul>
<h2 id="什么时候用JWT"><a href="#什么时候用JWT" class="headerlink" title="什么时候用JWT"></a>什么时候用JWT</h2><p>那么在真实工作中，我们要不要使用<code>jwt</code>呢？ 考虑一下下面的场景，大家应该都用过学校的学生系统吧，学生登录系统以后可以使用这个系统选课、查成绩什么的，如果现在学校又新建了一个图书馆系统，而且学校希望这个系统可以无缝衔接学生系统，使用同一套账户，在学生系统中登录以后就能直接进入图书馆系统。使用传统的<code>session</code>验证方式，必须在学生系统和图书馆系统都各自创建一套<code>session</code>才能实现登录，而各自的<code>session</code>无法形成有效的联系，所以在最底层创建一个单点登录系统，不管学生访问哪个系统，都会连接到单点登录系统进行<code>session</code>的验证，当学生的登录信息验证成功以后，单点登录系统会做一个重定向，把流量引导至相应的系统中。这样就可以实现这学生系统和图书馆系统的无缝连接。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c20ccbeeeb4942e58f4ee4f584980533~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p>
<p>但是，单点登录系统在使用分布式部署的时候又要考虑不同的服务器之间<code>session</code>的一致性，从而导致系统架构非常复杂。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a692410e1c5f4ffc95bc70c48f075af9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p>
<p>如果学校在建设学生系统的时候使用的是<code>jwt</code>，那么想要拓展系统简直就是易如反掌。因为<code>jwt</code>不会保存在服务器上，所以服务器如何部署完全不会影响到<code>jwt</code>的使用。学生登录完成以后，把<code>jwt</code>信息保存在浏览器中，需要访问学习系统或图书馆系统的时候，会向服务器发送带有<code>jwt</code>的请求，学生系统和图书馆系统只需要使用相同的私钥来验证<code>token</code>，验证成功以后，就可以通过<code>token</code>中用户的权限给不同的用户输出不同的数据。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed0eaaadb1fc4ddaaa9de8cbc51ea3b1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p>
]]></content>
      <categories>
        <category>快速弄懂</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
        <tag>Token</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS</title>
    <url>/2023/09/30/CSS/</url>
    <content><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="CSS概述"><a href="#CSS概述" class="headerlink" title="CSS概述"></a>CSS概述</h2><p>CSS（层叠样式表）是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS 不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。</p>
<p>使用CSS可以实现内容与样式的分离，便于团队开发；样式复用，便于网站的后期维护；页面的精确控制，让页面更精美。</p>
<p>CSS 定义如何显示 HTML 元素，就像 HTML 中的字体标签和颜色属性所起的作用那样。样式通常保存在外部的 .css 文件中，我们只需要编辑一个简单的 CSS 文档然后引用该文档就可以改变所有页面的布局和外观。</p>
<p><strong>在前端开发中，CSS用于描述网页的外观和布局。它与 HTML 结合使用，控制网页的样式和排版。</strong></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>CSS 规则由两个主要的部分构成：选择器以及一条或多条声明</p>
<p>例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释是用来解释你的代码并且可以随意编辑它，但是浏览器会忽略它。CSS注释以 <strong>&#x2F;*</strong> 开始, 以 ***&#x2F;** 结束。</p>
<h3 id="如何创建并引用"><a href="#如何创建并引用" class="headerlink" title="如何创建并引用"></a>如何创建并引用</h3><ol>
<li><p>外部样式表（外联式）</p>
<p>main.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入外部样式表--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;main.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>外部样式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>main.css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内部样式表（内联式）</p>
<p>main.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入内部样式表--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>外部样式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>	</span><br></pre></td></tr></table></figure>
</li>
<li><p>内联样式（行内式）</p>
<p>main.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入内联样式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red;text-align: center&quot;</span>&gt;</span>外部样式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="三种引入的优先级"><a href="#三种引入的优先级" class="headerlink" title="三种引入的优先级"></a>三种引入的优先级</h3><ul>
<li>如果三种引入方式内容属性不冲突：三种方式会同时起作用。</li>
<li>如果三种引入方式内容属性会冲突：<ul>
<li>内联式和外联式冲突，内联式位于外联式上方。— 由外联式决定</li>
<li>内联式和外联式冲突，外联式位于内联式上方。— 由内联式决定</li>
<li>三种方式并存且冲突。 — 由行内式决定</li>
</ul>
</li>
</ul>
<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式，一般来说，<strong>一个页面中标签的id的名称，必须唯一且不能重复</strong>。</p>
<p><strong>例子：</strong>为id为part1的段落添加红色字体样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;part1&quot;</span>&gt;</span>段落1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;part2&quot;</span>&gt;</span>段落2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#part1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="class选择器"><a href="#class选择器" class="headerlink" title="class选择器"></a>class选择器</h3><p>class 选择器可以为标有特定 class 的 HTML 元素指定特定的样式，一般来说，<strong>一个页面中标签的class的名称，可以不唯一且可以重复</strong>。</p>
<p><strong>例子：</strong>为class为green的段落添加绿色字体样式，为class为bold的段落添加加粗字体样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;green&quot;</span>&gt;</span>段落1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;bold&quot;</span>&gt;</span>段落2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;green bold&quot;</span>&gt;</span>段落3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.green</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bold</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>可以使用标签选择器对指定的所有标签指定样式</p>
<p><strong>例子：</strong>为所有段落标签添加黄色字体样式，为所有超链接标签添加红色字体样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com/&quot;</span>&gt;</span>打开百度，你就知道！<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h3><p>子代选择器可以选择当前元素的所有儿子元素。定义的时候用 &gt; 隔开。</p>
<p><strong>例子：</strong>为div标签下所有h1儿子节点设置为红色文本样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>儿子标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>孙子标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>儿子标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&gt;<span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p>标签元素除了并列书写还可以嵌套书写，后代选择器就是用于选择嵌套标签元素的一种选择器。定义的时候用 空格 隔开。</p>
<p><strong>例子：</strong>为所有段落标签中的超链接标签添加红色文本</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;part&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com/&quot;</span>&gt;</span>打开百度，你就知道！<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com/&quot;</span>&gt;</span>打开百度，你就知道！<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.part</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h3><p>相邻兄弟选择器可选择紧接在另一元素后的元素，且二者有相同父元素。定义的时候用 + 隔开。</p>
<p><strong>例子：</strong>为div之后的第一个p标签元素设置为黄色文本样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>DIV 内部段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>DIV 之后的第一个 P 元素。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>DIV 之后的第二个 P 元素。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> + <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后续兄弟选择器"><a href="#后续兄弟选择器" class="headerlink" title="后续兄弟选择器"></a>后续兄弟选择器</h3><p>后续兄弟选择器选取所有指定元素之后的相邻兄弟元素。定义的时候用 ~ 隔开。</p>
<p><strong>例子</strong>：为div之后的所有p标签元素设置为黄色文本样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>DIV 内部段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>DIV 之后的第一个 P 元素。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>DIV 之后的第二个 P 元素。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> ~ <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h3><p>选择的元素必须同时满足多个条件才可以被选择，交集选择器就是干这个的。定义的时候用 标签名.ID名&#x2F;类名 。</p>
<p><strong>例子：</strong>为所有p标签且class为part的段落添加绿色文本样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;part&quot;</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;part&quot;</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.part</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><p>多种元素共享某种属性，这时候就可以使用并集选择器。定义的时候用 逗号 隔开。</p>
<p><strong>例子：</strong>为p标签、h1标签、class&#x3D;‘link’、id&#x3D;’click’的这几种元素添加红色文本样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com/&quot;</span> <span class="attr">class</span>=<span class="string">&quot;link&quot;</span>&gt;</span>打开百度，你就知道！<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;click&quot;</span>&gt;</span>我是按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>, <span class="selector-tag">h1</span>, <span class="selector-class">.link</span>, <span class="selector-id">#click</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h3><p>通配符选择器可以匹配任何标签，我们常用于统一页面样式。</p>
<p><strong>例子：</strong>将页面所有元素的字体设置为红色文本样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>DIV文本<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>P文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span>打开百度，你就知道！<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>CSS伪类是用来添加一些选择器的特殊效果。</p>
<ol>
<li><p>anchor伪类</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com/&quot;</span>&gt;</span>打开百度，你就知道！<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>:<span class="number">#FF0000</span>;&#125; <span class="comment">/* 未访问时的链接样式 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>:<span class="number">#00FF00</span>;&#125; <span class="comment">/* 已访问时的链接样式 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>:<span class="number">#FF00FF</span>;&#125; <span class="comment">/* 鼠标划过时链接样式 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>:<span class="number">#0000FF</span>;&#125; <span class="comment">/* 已选中时的链接样式 */</span></span><br></pre></td></tr></table></figure>

<p><strong>注：推荐使用顺序为link、visited、hover、active</strong></p>
</li>
<li><p>input伪类</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>示例</th>
<th>示例说明</th>
</tr>
</thead>
<tbody><tr>
<td>:focus</td>
<td>input:focus</td>
<td>选择元素输入后具有焦点</td>
</tr>
<tr>
<td>:checked</td>
<td>input:checked</td>
<td>选择所有选中的表单元素</td>
</tr>
<tr>
<td>:disabled</td>
<td>input:disabled</td>
<td>选择所有禁用的表单元素</td>
</tr>
<tr>
<td>:enabled</td>
<td>input:enabled</td>
<td>选择所有启用的表单元素</td>
</tr>
<tr>
<td>:in-range</td>
<td>input:in-range</td>
<td>选择元素指定范围内的值</td>
</tr>
<tr>
<td>:out-of-range</td>
<td>input:out-of-range</td>
<td>选择元素指定范围外的值</td>
</tr>
<tr>
<td>:invalid</td>
<td>input:invalid</td>
<td>选择所有无效值的元素</td>
</tr>
<tr>
<td>:valid</td>
<td>input:valid</td>
<td>选择所有有效值的元素</td>
</tr>
<tr>
<td>:optional</td>
<td>input:optional</td>
<td>选择没有”required”属性的元素</td>
</tr>
<tr>
<td>:required</td>
<td>input:required</td>
<td>选择含有”required”属性的元素</td>
</tr>
<tr>
<td>:read-only</td>
<td>input:read-only</td>
<td>选择只读属性的元素</td>
</tr>
<tr>
<td>:read-write</td>
<td>input:read-write</td>
<td>选择可写属性的元素</td>
</tr>
</tbody></table>
</li>
<li><p>其他伪类</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>示例</th>
<th>示例说明</th>
</tr>
</thead>
<tbody><tr>
<td>:not(selector)</td>
<td>:not(p)</td>
<td>选择所有p元素以外的元素</td>
</tr>
<tr>
<td>:empty</td>
<td>p:empty</td>
<td>选择所有没有子元素的p元素</td>
</tr>
<tr>
<td>:first-child</td>
<td>p:first-child</td>
<td>选择所有p元素的第一个子元素</td>
</tr>
<tr>
<td>:first-of-type</td>
<td>p:first-of-type</td>
<td>选择的每个p元素是其父元素的第一个p元素</td>
</tr>
<tr>
<td>:last-child</td>
<td>p:last-child</td>
<td>选择所有p元素的最后一个子元素</td>
</tr>
<tr>
<td>:last-of-type</td>
<td>p:last-of-type</td>
<td>选择每个p元素是其父元素的最后一个p元素</td>
</tr>
<tr>
<td>:nth-child(n)</td>
<td>p:nth-child(2)</td>
<td>选择所有p元素的父元素的正数第二个子元素</td>
</tr>
<tr>
<td>:nth-of-type(n)</td>
<td>p:nth-of-type(2)</td>
<td>选择所有p元素正数的第二个为p的子元素</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td>p:nth-last-child(2)</td>
<td>选择所有p元素的父元素的倒数第二个子元素</td>
</tr>
<tr>
<td>:nth-last-of-type(n)</td>
<td>p:nth-last-of-type(2)</td>
<td>选择所有p元素倒数的第二个为p的子元素</td>
</tr>
<tr>
<td>:only-child</td>
<td>p:only-child</td>
<td>选择所有仅有一个子元素的p元素</td>
</tr>
<tr>
<td>:only-of-type</td>
<td>p:only-of-type</td>
<td>选择所有仅有一个子元素为p的元素</td>
</tr>
<tr>
<td>:first-letter</td>
<td>p:first-letter</td>
<td>选择每个p元素的第一个字母</td>
</tr>
<tr>
<td>:first-line</td>
<td>p:first-line</td>
<td>选择每个p元素的第一行</td>
</tr>
<tr>
<td>:before</td>
<td>p:before</td>
<td>在每个p元素之前插入内容</td>
</tr>
<tr>
<td>:after</td>
<td>p:after</td>
<td>在每个p元素之后插入内容</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>属性选择器可以根据元素的属性及属性值来选择元素。</p>
<p><strong>例子：</strong>为类型为text和button的input标签设置一下样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;文本框&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;text&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;button&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">35px</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong>如果title中包含多个单词并且以空格分隔，只要其中有hello，则为当前标签设置为蓝色字体样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>将会适用:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">title</span>=<span class="string">&quot;hello world&quot;</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">title</span>=<span class="string">&quot;student hello&quot;</span>&gt;</span>Hello CSS students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>将不适用:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">title</span>=<span class="string">&quot;student&quot;</span>&gt;</span>Hi CSS students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[title~=hello]</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong>如果title中包含一个单词，只要其中有zh，则为当前标签设置为蓝色字体样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>将会适用:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">lang</span>=<span class="string">&quot;zh-cn&quot;</span>&gt;</span>Hi!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>将不适用:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">lang</span>=<span class="string">&quot;us&quot;</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Hi!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[lang|=zh]</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子串匹配属性选择器"><a href="#子串匹配属性选择器" class="headerlink" title="子串匹配属性选择器"></a>子串匹配属性选择器</h3><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[abc^&#x3D;“def”]</td>
<td>选择 abc 属性值以 “def” 开头的所有元素</td>
</tr>
<tr>
<td>[abc$&#x3D;“def”]</td>
<td>选择 abc 属性值以 “def” 结尾的所有元素</td>
</tr>
<tr>
<td>[abc*&#x3D;“def”]</td>
<td>选择 abc 属性值中包含子串 “def” 的所有元素</td>
</tr>
</tbody></table>
<p><strong>例子：</strong>希望对指向 baidu 的所有链接应用样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;baidu.com&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CSS常见样式"><a href="#CSS常见样式" class="headerlink" title="CSS常见样式"></a>CSS常见样式</h2><h3 id="背景样式"><a href="#背景样式" class="headerlink" title="背景样式"></a>背景样式</h3><p>CSS 背景属性用于定义HTML元素背景的样式。元素的背景是元素的总大小。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-background.html">background</a></td>
<td>简写属性，作用是将背景属性设置在一个声明中。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-background-attachment.html">background-attachment</a></td>
<td>背景图像是否固定或者随着页面的其余部分滚动。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-background-color.html">background-color</a></td>
<td>设置元素的背景颜色。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-background-image.html">background-image</a></td>
<td>把图像设置为背景。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-background-position.html">background-position</a></td>
<td>设置背景图像的起始位置。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-background-repeat.html">background-repeat</a></td>
<td>设置背景图像是否及如何重复。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-background-clip.html">background-clip</a></td>
<td>规定背景的绘制区域。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-background-origin.html">background-origin</a></td>
<td>规定背景图片的定位区域。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-background-size.html">background-size</a></td>
<td>规定背景图片的尺寸。</td>
</tr>
</tbody></table>
<h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><p>CSS 文本属性用于定义HTML文本内容的样式。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/cssref/pr-text-color.html">color</a></td>
<td>设置文本颜色。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-text-direction.html">direction</a></td>
<td>设置文本方向。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-text-letter-spacing.html">letter-spacing</a></td>
<td>设置字符间距。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-dim-line-height.html">line-height</a></td>
<td>设置行高。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-text-text-align.html">text-align</a></td>
<td>对齐元素中的文本。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-text-text-decoration.html">text-decoration</a></td>
<td>向文本添加修饰。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-text-text-indent.html">text-indent</a></td>
<td>缩进元素中文本的首行。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-text-shadow.html">text-shadow</a></td>
<td>设置文本阴影。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-text-text-transform.html">text-transform</a></td>
<td>控制元素中的字母。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-text-unicode-bidi.html">unicode-bidi</a></td>
<td>设置或返回文本是否被重写。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-pos-vertical-align.html">vertical-align</a></td>
<td>设置元素的垂直对齐。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-text-white-space.html">white-space</a></td>
<td>设置元素中空白的处理方式。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-text-word-spacing.html">word-spacing</a></td>
<td>设置字间距。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-hanging-punctuation.html">hanging-punctuation</a></td>
<td>规定标点字符是否位于线框之外。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-punctuation-trim.html">punctuation-trim</a></td>
<td>规定是否对标点字符进行修剪。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-text-align-last.html">text-align-last</a></td>
<td>设置如何对齐最后一行或紧挨着强制换行符之前的行。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/css3/css3-pr-text-emphasis.html">text-emphasis</a></td>
<td>向元素的文本应用重点标记以及重点标记的前景色。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-text-justify.html">text-justify</a></td>
<td>规定当 text-align 设置为 “justify” 时所使用的对齐方法。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-text-outline.html">text-outline</a></td>
<td>规定文本的轮廓。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-text-overflow.html">text-overflow</a></td>
<td>规定当文本溢出包含元素时发生的事情。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-text-shadow.html">text-shadow</a></td>
<td>向文本添加阴影。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-text-wrap.html">text-wrap</a></td>
<td>规定文本的换行规则。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-word-break.html">word-break</a></td>
<td>规定非中日韩文本的换行规则。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-word-wrap.html">word-wrap</a></td>
<td>允许对长的不可分割的单词进行分割并换行到下一行。</td>
</tr>
</tbody></table>
<h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><p>CSS 字体属性用于定义HTML内容字体的样式。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/cssref/pr-font-font.html">font</a></td>
<td>在一个声明中设置所有的字体属性。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-font-font-family.html">font-family</a></td>
<td>指定文本的字体系列。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-font-font-size.html">font-size</a></td>
<td>指定文本的字体大小。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-font-font-style.html">font-style</a></td>
<td>指定文本的字体样式。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-font-font-variant.html">font-variant</a></td>
<td>以小型大写字体或者正常字体显示文本。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-font-weight.html">font-weight</a></td>
<td>指定字体的粗细。</td>
</tr>
</tbody></table>
<h3 id="链接样式"><a href="#链接样式" class="headerlink" title="链接样式"></a>链接样式</h3><p>推荐使用顺序为link、visited、hover、active</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>:<span class="number">#FF0000</span>;&#125; <span class="comment">/* 未访问的链接样式 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>:<span class="number">#00FF00</span>;&#125; <span class="comment">/* 已访问的链接样式 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>:<span class="number">#FF00FF</span>;&#125; <span class="comment">/* 鼠标划过链接样式 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>:<span class="number">#0000FF</span>;&#125; <span class="comment">/* 已选中的链接样式 */</span></span><br></pre></td></tr></table></figure>

<h3 id="列表样式"><a href="#列表样式" class="headerlink" title="列表样式"></a>列表样式</h3><p>CSS 列表属性用于定义HTML常见列表的样式。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/cssref/pr-list-style.html">list-style</a></td>
<td>简写属性，用于把所有用于列表的属性设置于一个声明中。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-list-style-image.html">list-style-image</a></td>
<td>将图像设置为列表项标志。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-list-style-position.html">list-style-position</a></td>
<td>设置列表中列表项标志的位置。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-list-style-type.html">list-style-type</a></td>
<td>设置列表项标志的类型。</td>
</tr>
</tbody></table>
<h3 id="表格样式"><a href="#表格样式" class="headerlink" title="表格样式"></a>表格样式</h3><p>CSS 表格属性用于定义HTML表格的样式。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_tab_border-collapse.asp">border-collapse</a></td>
<td>设置是否把表格边框合并为单一的边框。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_tab_border-spacing.asp">border-spacing</a></td>
<td>设置分隔单元格边框的距离。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_tab_caption-side.asp">caption-side</a></td>
<td>设置表格标题的位置。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_tab_empty-cells.asp">empty-cells</a></td>
<td>设置是否显示表格中的空单元格。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_tab_table-layout.asp">table-layout</a></td>
<td>设置显示单元、行和列的算法。</td>
</tr>
</tbody></table>
<h3 id="轮廓样式"><a href="#轮廓样式" class="headerlink" title="轮廓样式"></a>轮廓样式</h3><p>轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_outline.asp">outline</a></td>
<td>在一个声明中设置所有的轮廓属性。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_outline-color.asp">outline-color</a></td>
<td>设置轮廓的颜色。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_outline-style.asp">outline-style</a></td>
<td>设置轮廓的样式。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_outline-width.asp">outline-width</a></td>
<td>设置轮廓的宽度。</td>
</tr>
</tbody></table>
<h2 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。</p>
<p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。</p>
<p>盒模型由从外到内分为四个部分：</p>
<ul>
<li><strong>Margin(外边距)</strong> - 清除边框外的区域，外边距是透明的。</li>
<li><strong>Border(边框)</strong> - 围绕在内边距和内容外的边框。</li>
<li><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的。</li>
<li><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像。</li>
</ul>
<p>当指定一个 CSS 元素的宽度和高度属性时，只是设置内容区域的宽度和高度。要知道，完整大小的元素，你还必须添加内边距、边框和外边距。</p>
<ul>
<li><strong>最终元素的总宽度计算公式是这样的：</strong>总元素的宽度&#x3D;宽度+左填充+右填充+左边框+右边框+左边距+右边距</li>
<li><strong>最终元素的总高度计算公式是这样的：</strong>总元素的高度&#x3D;高度+顶部填充+底部填充+上边框+下边框+上边距+下边距</li>
</ul>
<h3 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h3><p>当元素的 padding（填充）内边距被清除时，所释放的区域将会受到元素背景颜色的填充。</p>
<p>单独使用 padding 属性可以改变上下左右的填充。</p>
<p>常用的属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_padding.asp">padding</a></td>
<td>简写属性。作用是在一个声明中设置元素的所内边距属性。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_padding-bottom.asp">padding-bottom</a></td>
<td>设置元素的下内边距。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_padding-left.asp">padding-left</a></td>
<td>设置元素的左内边距。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_padding-right.asp">padding-right</a></td>
<td>设置元素的右内边距。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_padding-top.asp">padding-top</a></td>
<td>设置元素的上内边距。</td>
</tr>
</tbody></table>
<h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>元素的边框 (border) 是围绕元素内容和内边距的一条或多条线，CSS边框属性允许你指定一个元素边框的样式和颜色。</p>
<p>常用的属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border.asp">border</a></td>
<td>简写属性，用于把针对四个边的属性设置在一个声明。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-style.asp">border-style</a></td>
<td>用于设置元素所有边框的样式，或者单独地为各边设置边框样式。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-width.asp">border-width</a></td>
<td>简写属性，用于为元素的所有边框设置宽度，或者单独地为各边边框设置宽度。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-color.asp">border-color</a></td>
<td>简写属性，设置元素的所有边框中可见部分的颜色，或为 4 个边分别设置颜色。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-bottom.asp">border-bottom</a></td>
<td>简写属性，用于把下边框的所有属性设置到一个声明中。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-bottom_color.asp">border-bottom-color</a></td>
<td>设置元素的下边框的颜色。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-bottom_style.asp">border-bottom-style</a></td>
<td>设置元素的下边框的样式。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-bottom_width.asp">border-bottom-width</a></td>
<td>设置元素的下边框的宽度。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-left.asp">border-left</a></td>
<td>简写属性，用于把左边框的所有属性设置到一个声明中。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-left_color.asp">border-left-color</a></td>
<td>设置元素的左边框的颜色。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-left_style.asp">border-left-style</a></td>
<td>设置元素的左边框的样式。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-left_width.asp">border-left-width</a></td>
<td>设置元素的左边框的宽度。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-right.asp">border-right</a></td>
<td>简写属性，用于把右边框的所有属性设置到一个声明中。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-right_color.asp">border-right-color</a></td>
<td>设置元素的右边框的颜色。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-right_style.asp">border-right-style</a></td>
<td>设置元素的右边框的样式。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-right_width.asp">border-right-width</a></td>
<td>设置元素的右边框的宽度。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-top.asp">border-top</a></td>
<td>简写属性，用于把上边框的所有属性设置到一个声明中。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-top_color.asp">border-top-color</a></td>
<td>设置元素的上边框的颜色。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-top_style.asp">border-top-style</a></td>
<td>设置元素的上边框的样式。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_border-top_width.asp">border-top-width</a></td>
<td>设置元素的上边框的宽度。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-border-image.html">border-image</a></td>
<td>设置所有边框图像的速记属性。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-border-radius.html">border-radius</a></td>
<td>一个用于设置所有四个边框- *-半径属性的速记属性</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-box-shadow.html">box-shadow</a></td>
<td>附加一个或多个下拉框的阴影</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-border-radius.html">border-radius</a></td>
<td>所有四个边角 border-radius 属性的缩写。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-border-top-left-radius.html">border-top-left-radius</a></td>
<td>定义了左上角的弧度。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-border-top-right-radius.html">border-top-right-radius</a></td>
<td>定义了右上角的弧度。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-border-bottom-right-radius.html">border-bottom-right-radius</a></td>
<td>定义了右下角的弧度。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-border-bottom-left-radius.html">border-bottom-left-radius</a></td>
<td>定义了左下角的弧度。</td>
</tr>
</tbody></table>
<h3 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h3><p>margin 清除周围的（外边距）元素区域，margin 没有背景颜色，是完全透明的。margin 可以单独改变元素的上，下，左，右边距，也可以一次改变所有的属性。</p>
<p>常用的属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_margin.asp">margin</a></td>
<td>简写属性。在一个声明中设置所有外边距属性。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_margin-bottom.asp">margin-bottom</a></td>
<td>设置元素的下外边距。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_margin-left.asp">margin-left</a></td>
<td>设置元素的左外边距。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_margin-right.asp">margin-right</a></td>
<td>设置元素的右外边距。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_margin-top.asp">margin-top</a></td>
<td>设置元素的上外边距。</td>
</tr>
</tbody></table>
<h3 id="外边距合并"><a href="#外边距合并" class="headerlink" title="外边距合并"></a>外边距合并</h3><p>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。外边距合并（叠加）是一个相当简单的概念。但是，在实践中对网页进行布局时，它会造成许多混淆。</p>
<p>只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。</p>
<h2 id="CSS显示特性"><a href="#CSS显示特性" class="headerlink" title="CSS显示特性"></a>CSS显示特性</h2><h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><p><strong>块级元素(block)特性：</strong></p>
<ul>
<li>总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示</li>
<li>宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制</li>
</ul>
<p><strong>块级元素主要有：</strong></p>
<p>address , blockquote , center , dir , div , dl , fieldset , form , h1 , h2 , h3 , h4 , h5 , h6 , hr , isindex , menu , noframes , noscript , ol , p , pre , table , ul , li</p>
<h3 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h3><p><strong>内联元素(inline)特性：</strong></p>
<p>和相邻的内联元素在同一行宽度(width)、高度(height)、内边距的top&#x2F;bottom(padding-top&#x2F;padding-bottom)和外边距的top&#x2F;bottom(margin-top&#x2F;margin-bottom)都不可改变，就是里面文字或图片的大小</p>
<p><strong>内联元素主要有：</strong></p>
<p>a , abbr , acronym , b , bdo , big , br , cite , code , dfn , em , font , i , img , input , kbd , label , q , s , samp , select , small , span , strike , strong , sub , sup ,textarea , tt , u , var</p>
<h3 id="可变元素"><a href="#可变元素" class="headerlink" title="可变元素"></a>可变元素</h3><p><strong>可变元素特性：</strong></p>
<p>根据上下文关系确定该元素是块元素还是内联元素</p>
<p><strong>可变元素主要有：</strong></p>
<p>applet ,button ,del ,iframe , ins ,map ,object , script</p>
<h3 id="类别修改"><a href="#类别修改" class="headerlink" title="类别修改"></a>类别修改</h3><p>利用CSS我们可以摆脱上面表格里HTML标签归类的限制，自由地在不同标签或元素上应用我们需要的属性。</p>
<p>主要用的CSS样式有以下三个：</p>
<ul>
<li>display:block – 显示为块级元素</li>
<li>display:inline – 显示为内联元素</li>
<li>display:inline-block – 显示为内联块元素，表现为同行显示并可修改宽高内外边距等属性</li>
</ul>
<p>我们常将所有&lt;li&gt;元素加上display:inline-block样式，原本垂直的列表就可以水平显示了。</p>
<h3 id="元素隐藏"><a href="#元素隐藏" class="headerlink" title="元素隐藏"></a>元素隐藏</h3><p>隐藏一个元素可以通过把display属性设置为”none”，或把visibility属性设置为”hidden”。但是请注意，这两种方法会产生不同的结果。</p>
<p>但两者的区别在于：</p>
<ul>
<li><strong>display:none</strong> ：使元素在网页上不可见，元素不再占用空间。</li>
<li><strong>visibility:hidden</strong> ：使元素在网页上不可见，元素仍会占用空间。</li>
</ul>
<h2 id="CSS定位"><a href="#CSS定位" class="headerlink" title="CSS定位"></a>CSS定位</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>CSS 为定位和浮动提供了一些属性，利用这些属性，可以建立列式布局，将布局的一部分与另一部分重叠。这允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。</p>
<p><strong>CSS定位机制</strong></p>
<p>CSS 有三种基本的定位机制：普通流（相对定位）、绝对定位和浮动定位。</p>
<p>除非专门指定，否则所有框都在普通流中定位。也就是说，普通流中的元素的位置由元素在 HTML 中的位置决定。</p>
<p>块级框从上到下一个接一个地排列，框之间的垂直距离是由框的垂直外边距计算出来。</p>
<p>行内框在一行中水平布置。可以使用水平内边距、边框和外边距调整它们的间距。但是，垂直内边距、边框和外边距不影响行内框的高度。由一行形成的水平框称为行框（Line Box），行框的高度总是足以容纳它包含的所有行内框。不过，设置行高可以增加这个框的高度。</p>
<p><strong>CSS定位属性</strong></p>
<p>通过使用 position 属性，我们可以选择 4 种不同类型的定位，这会影响元素框生成的方式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#box_relative</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>absolute</td>
<td>生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td>
</tr>
<tr>
<td>fixed</td>
<td>生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td>
</tr>
<tr>
<td>relative</td>
<td>生成相对定位的元素，相对于其正常位置进行定位。因此，“left: 20” 会向元素的 left 位置添加 20 像素。</td>
</tr>
<tr>
<td>static</td>
<td>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 position 属性的值。</td>
</tr>
</tbody></table>
<p><strong>注：相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。</strong></p>
<h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。</p>
<p><strong>注：在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。</strong></p>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>绝对定位使元素的位置与文档流无关，因此不占据空间。这一点与相对定位不同，相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。<strong>普通流中其它元素的布局就像绝对定位的元素不存在一样。</strong></p>
<p>绝对定位的元素的位置相对于最近的已定位祖先元素，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e7e883f4cb9bd33f9672453301d66dc2.png"></p>
<p>因为绝对定位的框与文档流无关，所以它们可以覆盖页面上的其它元素。可以通过设置 z-index 属性来控制这些框的堆放次序。</p>
<blockquote>
<p>z-index：auto|inherit|number，数字越大堆叠顺序越高，排在越上面</p>
</blockquote>
<h3 id="浮动定位"><a href="#浮动定位" class="headerlink" title="浮动定位"></a>浮动定位</h3><p>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。浮动框不在文档的普通流中，所以<strong>文档的普通流中的块框表现得就像浮动框不存在一样。</strong></p>
<p>如果包含框太窄，无法容纳水平排列的多个浮动元素，那么其它浮动块向下移动，直到有足够的空间。如果浮动元素的高度不同，那么当它们向下移动时可能被其它浮动元素“卡住”：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/dafaea6c1c47659791728858f0919ea9.png"></p>
<p><strong>CSS浮动属性</strong></p>
<p>在 CSS 中，我们通过 float 属性实现元素的浮动。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>元素向左浮动。</td>
</tr>
<tr>
<td>right</td>
<td>元素向右浮动。</td>
</tr>
<tr>
<td>none</td>
<td>默认值。元素不浮动，并会显示在其在文本中出现的位置。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 float 属性的值。</td>
</tr>
</tbody></table>
<p><strong>行框和清理</strong></p>
<p>浮动框旁边的行框被缩短，从而给浮动框留出空间，行框围绕浮动框。因此，创建浮动框可以使文本围绕图像：<img src="https://img-blog.csdnimg.cn/img_convert/b743de0006db1122205458a010b61556.png"></p>
<p>要想阻止行框围绕浮动框，需要对该框应用 <a href="https://www.w3school.com.cn/cssref/pr_class_clear.asp">clear 属性</a>。clear 属性的值可以是 left、right、both 或 none，它表示框的哪些边不应该挨着浮动框。具体来说，它会使元素下方的内容不与浮动元素相邻，而是另起一行。为了实现这种效果，在被清理的元素的上外边距上添加足够的空间，使元素的顶边缘垂直下降到浮动框下面：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/af3a405b92b47f4b3cec50d9dfffc283.png"></p>
<p><strong>应用例子</strong></p>
<p>假设希望让一个图片浮动到文本块的左边，并且希望这幅图片和文本包含在另一个具有背景颜色和边框的元素中。</p>
<p>因为浮动元素脱离了文档流，所以包围图片和文本的 div 不占据空间。为了让包围元素在视觉上包围浮动元素，可以在这个元素中的某个地方应用 clear：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/12190724a595fff5632b0e0876cb2248.png"></p>
<p>或者对容器 div 进行浮动。</p>
<p>不幸的是，下一个元素会受到这个浮动元素的影响。为了解决这个问题，有些人选择对布局中的所有东西进行浮动，然后使用适当的有意义的元素（常常是站点的页脚）对这些浮动进行清理，这有助于减少或消除不必要的标记。</p>
<h2 id="CSS3渐变"><a href="#CSS3渐变" class="headerlink" title="CSS3渐变"></a>CSS3渐变</h2><p>CSS3 渐变（gradients）可以让你在两个或多个指定的颜色之间显示平稳的过渡。</p>
<p>以前必须使用图像来实现这些效果。但是，通过使用 CSS3 渐变（gradients），你可以减少下载的时间和宽带的使用。此外，渐变效果的元素在放大时看起来效果更好，因为渐变（gradient）是由浏览器生成的。</p>
<p>CSS3 定义了两种类型的渐变（gradients）：</p>
<ul>
<li>线性渐变（Linear Gradients）- 向下&#x2F;向上&#x2F;向左&#x2F;向右&#x2F;对角方向</li>
<li>径向渐变（Radial Gradients）- 由它们的中心定义</li>
</ul>
<h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><p>为了创建一个线性渐变，你必须至少定义两种颜色节点。颜色节点即你想要呈现平稳过渡的颜色。同时，你也可以设置一个起点和一个方向（或一个角度）。</p>
<p>默认情况下，颜色节点分布是均匀的。但可以设置百分数让颜色节点分布不均匀，百分数表示相对于渐变轴长度的位置。</p>
<p><strong>线性渐变从左到右</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to right, red, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：方向还有to bottom、to top、to left、to bottom right等等</p>
<p><strong>线性渐变上使用角度</strong></p>
<p>如果你想要在渐变的方向上做更多的控制，你可以定义一个角度，而不用预定义方向。0deg将创建一个从左到右的渐变，90deg 将创建一个从下到上的渐变，以此类推。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(-<span class="number">90deg</span>, red, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设置多个颜色节点</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to right, red, orange, yellow, green, blue, indigo, violet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重复的线性渐变</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">repeating-linear-gradient</span>(red, yellow <span class="number">10%</span>, green <span class="number">20%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，红色（red）将从渐变轴的起点开始，到达轴长度的10%处，然后过渡到黄色（yellow）。接着，黄色将持续到轴长度的20%处，并过渡到绿色（green）。</p>
<h3 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h3><p>径向渐变由它的中心定义。为了创建一个径向渐变，你也必须至少定义两种颜色节点。颜色节点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。</p>
<p><strong>颜色节点不均匀分布的径向渐变</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(red <span class="number">5%</span>, yellow <span class="number">15%</span>, green <span class="number">60%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设置形状</strong></p>
<p>shape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。默认值是 ellipse。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(circle, red, yellow, green);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设置渐变大小</strong></p>
<p>size 参数定义了渐变的大小。它可以是以下四个值：</p>
<ul>
<li>closest-side</li>
<li>farthest-side</li>
<li>closest-corner</li>
<li>farthest-corner</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(closest-side at <span class="number">60%</span> <span class="number">55%</span>, red, yellow, black);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设置渐变中心</strong></p>
<p>可以使用具体像素值或百分比来指定渐变的中心</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(circle at <span class="number">20%</span> <span class="number">30%</span>, red, yellow, black);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重复的径向渐变</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">repeating-radial-gradient</span>(red, yellow <span class="number">10%</span>, green <span class="number">15%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CSS3-2D转换"><a href="#CSS3-2D转换" class="headerlink" title="CSS3 2D转换"></a>CSS3 2D转换</h2><p>CSS3 转换可以对元素进行移动、缩放、转动、拉长或拉伸。</p>
<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>translate()方法，根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动。</p>
<p>translate(50px, 100px)是从左边元素移动50个像素，并从顶部移动100像素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>, <span class="number">100px</span>);<span class="comment">/*Safari/Chrome浏览器支持*/</span></span><br><span class="line">    -moz-<span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>, <span class="number">100px</span>);<span class="comment">/*Firefox浏览器支持*/</span></span><br><span class="line">    -ms-<span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>, <span class="number">100px</span>);<span class="comment">/*IE浏览器支持*/</span></span><br><span class="line">    -o-<span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>, <span class="number">100px</span>);<span class="comment">/*Opera浏览器支持*/</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">50px</span>, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外还有：translateX(<em>n</em>)、translateY(<em>n</em>)</p>
<h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>rotate()方法，在一个给定度数顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转。</p>
<p>rotate(30deg)代表元素顺时针旋转30度。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">    -moz-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">    -ms-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">    -o-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>scale()方法，该元素增加或减少的大小，取决于宽度（X轴）和高度（Y轴）的参数。</p>
<p>scale(2, 3)转变宽度为原来的大小的2倍，和其原始大小3倍的高度。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    -moz-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    -ms-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    -o-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外还有：scaleX(<em>n</em>)、scaleY(<em>n</em>)</p>
<h3 id="倾斜"><a href="#倾斜" class="headerlink" title="倾斜"></a>倾斜</h3><p>skew() 方法包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜。</p>
<p>skew(30deg, 20deg)元素在X轴和Y轴上倾斜20度30度。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>, <span class="number">20deg</span>);</span><br><span class="line">    -moz-<span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>, <span class="number">20deg</span>);</span><br><span class="line">    -ms-<span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>, <span class="number">20deg</span>);</span><br><span class="line">    -o-<span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>, <span class="number">20deg</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>, <span class="number">20deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外还有：skewX(<em>angle</em>)、skewY(<em>angle</em>)</p>
<h2 id="CSS3-3D转换"><a href="#CSS3-3D转换" class="headerlink" title="CSS3 3D转换"></a>CSS3 3D转换</h2><p>CSS3 允许您使用 3D 转换来对元素进行格式化。</p>
<h3 id="3D转换属性"><a href="#3D转换属性" class="headerlink" title="3D转换属性"></a>3D转换属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-transform.html">transform</a></td>
<td>向元素应用 2D 或 3D 转换。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-transform-origin.html">transform-origin</a></td>
<td>允许你改变被转换元素的位置。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-transform-style.html">transform-style</a></td>
<td>规定被嵌套元素如何在 3D 空间中显示。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-perspective.html">perspective</a></td>
<td>规定 3D 元素的透视效果。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-perspective-origin.html">perspective-origin</a></td>
<td>规定 3D 元素的底部位置。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-backface-visibility.html">backface-visibility</a></td>
<td>定义元素在不面对屏幕时是否可见。</td>
</tr>
</tbody></table>
<h3 id="3D转换方法"><a href="#3D转换方法" class="headerlink" title="3D转换方法"></a>3D转换方法</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>translate3d(<em>x</em>,<em>y</em>,<em>z</em>)</td>
<td>定义 3D 转化。</td>
</tr>
<tr>
<td>translateX(<em>x</em>)</td>
<td>定义 3D 转化，仅使用用于 X 轴的值。</td>
</tr>
<tr>
<td>translateY(<em>y</em>)</td>
<td>定义 3D 转化，仅使用用于 Y 轴的值。</td>
</tr>
<tr>
<td>translateZ(<em>z</em>)</td>
<td>定义 3D 转化，仅使用用于 Z 轴的值。</td>
</tr>
<tr>
<td>scale3d(<em>x</em>,<em>y</em>,<em>z</em>)</td>
<td>定义 3D 缩放转换。</td>
</tr>
<tr>
<td>scaleX(<em>x</em>)</td>
<td>定义 3D 缩放转换，通过给定一个 X 轴的值。</td>
</tr>
<tr>
<td>scaleY(<em>y</em>)</td>
<td>定义 3D 缩放转换，通过给定一个 Y 轴的值。</td>
</tr>
<tr>
<td>scaleZ(<em>z</em>)</td>
<td>定义 3D 缩放转换，通过给定一个 Z 轴的值。</td>
</tr>
<tr>
<td>rotate3d(<em>x</em>,<em>y</em>,<em>z</em>,<em>angle</em>)</td>
<td>定义 3D 旋转。</td>
</tr>
<tr>
<td>rotateX(<em>angle</em>)</td>
<td>定义沿 X 轴的 3D 旋转。</td>
</tr>
<tr>
<td>rotateY(<em>angle</em>)</td>
<td>定义沿 Y 轴的 3D 旋转。</td>
</tr>
<tr>
<td>rotateZ(<em>angle</em>)</td>
<td>定义沿 Z 轴的 3D 旋转。</td>
</tr>
<tr>
<td>perspective(<em>n</em>)</td>
<td>定义 3D 转换元素的透视视图。</td>
</tr>
</tbody></table>
<h2 id="CSS3过渡"><a href="#CSS3过渡" class="headerlink" title="CSS3过渡"></a>CSS3过渡</h2><p>CSS3中，我们为了添加某种效果可以从一种样式转变到另一个的时候，无需使用Flash动画或JavaScript。</p>
<p>CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。</p>
<p>要实现这一点，必须规定两项内容：</p>
<ul>
<li>指定要添加效果的CSS属性</li>
<li>指定效果的持续时间</li>
</ul>
<h3 id="过渡属性"><a href="#过渡属性" class="headerlink" title="过渡属性"></a><strong>过渡属性</strong></h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-transition.html">transition</a></td>
<td>简写属性，用于在一个属性中设置四个过渡属性。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-transition-property.html">transition-property</a></td>
<td>规定应用过渡的 CSS 属性的名称。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-transition-duration.html">transition-duration</a></td>
<td>定义过渡效果花费的时间。默认是 0。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-transition-timing-function.html">transition-timing-function</a></td>
<td>规定过渡效果的时间曲线。默认是 “ease”。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-transition-delay.html">transition-delay</a></td>
<td>规定过渡效果何时开始。默认是 0。</td>
</tr>
</tbody></table>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h3><p>当鼠标悬停到一个div元素上时，div宽度变为300px，高度变为300px</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">transition</span>: width <span class="number">2s</span>, height <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CSS3动画"><a href="#CSS3动画" class="headerlink" title="CSS3动画"></a>CSS3动画</h2><p>CSS3 可以创建动画，它可以取代许多网页动画图像、Flash 动画和 JavaScript 实现的效果。要创建 CSS3 动画，需要了解 @keyframes 规则。**@keyframes 规则是创建动画，指定一个 CSS 样式和动画将逐步从目前的样式更改为新的样式。**</p>
<p>当在 @keyframes 创建动画，把它绑定到一个选择器，否则动画不会有任何效果。</p>
<p>指定至少这两个CSS3的动画属性绑定向一个选择器：</p>
<ul>
<li>规定动画的名称</li>
<li>规定动画的时长</li>
</ul>
<h3 id="动画属性"><a href="#动画属性" class="headerlink" title="动画属性"></a><strong>动画属性</strong></h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-keyframes.html">@keyframes</a></td>
<td>规定动画。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation.html">animation</a></td>
<td>所有动画属性的简写属性。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-name.html">animation-name</a></td>
<td>规定 @keyframes 动画的名称。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-duration.html">animation-duration</a></td>
<td>规定动画完成一个周期所花费的秒或毫秒。默认是 0。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-timing-function.html">animation-timing-function</a></td>
<td>规定动画的速度曲线。默认是 “ease”。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-fill-mode.html">animation-fill-mode</a></td>
<td>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-delay.html">animation-delay</a></td>
<td>规定动画何时开始。默认是 0。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-iteration-count.html">animation-iteration-count</a></td>
<td>规定动画被播放的次数。默认是 1。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-direction.html">animation-direction</a></td>
<td>规定动画是否在下一周期逆向地播放。默认是 “normal”。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-play-state.html">animation-play-state</a></td>
<td>规定动画是否正在运行或暂停。默认是 “running”。</td>
</tr>
</tbody></table>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>把 “myfirst” 动画捆绑到 div 元素，时长：5 秒：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> myfirst &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">    <span class="number">25%</span> &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">    <span class="number">50%</span> &#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">    <span class="number">100%</span> &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background</span>: black;</span><br><span class="line"></span><br><span class="line">    -webkit-<span class="attribute">animation</span>: myfirst <span class="number">5s</span>;</span><br><span class="line">    -o-<span class="attribute">animation</span>: myfirst <span class="number">5s</span>;</span><br><span class="line">    <span class="attribute">animation</span>: myfirst <span class="number">5s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：百分比规定变化发生的时间，0% 是动画的开始，100% 是动画的完成。</strong></p>
<h2 id="CSS3多列"><a href="#CSS3多列" class="headerlink" title="CSS3多列"></a>CSS3多列</h2><p>CSS3 可以将文本内容设计成像报纸一样的多列布局，如下实例：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b6f47b4b924e7969e58210571fe46200.png"></p>
<p>下表列出了所有 CSS3 的多列属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-column-count.html">column-count</a></td>
<td>指定元素应该被分割的列数。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-column-fill.html">column-fill</a></td>
<td>指定如何填充列。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-column-gap.html">column-gap</a></td>
<td>指定列与列之间的间隙。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-column-rule.html">column-rule</a></td>
<td>所有 column-rule-* 属性的简写。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-column-rule-color.html">column-rule-color</a></td>
<td>指定两列间边框的颜色。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-column-rule-style.html">column-rule-style</a></td>
<td>指定两列间边框的样式。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-column-rule-width.html">column-rule-width</a></td>
<td>指定两列间边框的厚度。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-column-span.html">column-span</a></td>
<td>指定元素要跨越多少列。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-column-width.html">column-width</a></td>
<td>指定列的宽度。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-columns.html">columns</a></td>
<td>column-width 与 column-count 的简写属性。</td>
</tr>
</tbody></table>
<h2 id="CSS3弹性盒子"><a href="#CSS3弹性盒子" class="headerlink" title="CSS3弹性盒子"></a>CSS3弹性盒子</h2><p>CSS3 弹性盒（ Flexible Box 或 flexbox），是<strong>一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。</strong>引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。</p>
<p>弹性盒子由弹性容器(Flex container)和弹性子元素(Flex item)组成。弹性容器内包含了一个或多个弹性子元素。</p>
<p>弹性容器通过设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器。</p>
<p>注意：弹性容器外及弹性子元素内是正常渲染的，弹性盒子只定义了弹性子元素如何在弹性容器内布局。弹性子元素通常在弹性盒子内一行显示。默认情况每个容器只有一行。</p>
<p>下表列出了在弹性盒子中常用到的属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/cssref/pr-class-display.html">display</a></td>
<td>指定 HTML 元素盒子类型。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-flex-direction.html">flex-direction</a></td>
<td>指定了弹性容器中子元素的排列方式。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-justify-content.html">justify-content</a></td>
<td>设置弹性盒子元素在主轴（横轴）方向上的对齐方式。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-align-items.html">align-items</a></td>
<td>设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-flex-wrap.html">flex-wrap</a></td>
<td>设置弹性盒子的子元素超出父容器时是否换行。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-align-content.html">align-content</a></td>
<td>修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-flex-flow.html">flex-flow</a></td>
<td>flex-direction 和 flex-wrap 的简写。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-order.html">order</a></td>
<td>设置弹性盒子的子元素排列顺序。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-align-self.html">align-self</a></td>
<td>在弹性子元素上使用。覆盖容器的 align-items 属性。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-flex.html">flex</a></td>
<td>设置弹性盒子的子元素如何分配空间。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2023/09/30/Markdown/</url>
    <content><![CDATA[<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Markdown是一种轻量级的标记语言，它的设计初衷是简化写作和排版的过程，使文本具备易读性和可扩展性。</p>
<p>Markdown的语法简洁明了，易于学习和使用，并且可以转换为HTML等其他格式。它被广泛应用于撰写文档、写作博客、GitHub的README文件等地方，以简单且易读的方式呈现文本，并可以方便地转换为其他格式。</p>
<p>建议使用Typora工具编辑Markdown文档</p>
<h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>参考文章：</p>
<p><a href="https://blog.csdn.net/u014061630/article/details/81359144?ops_request_misc=%7B%22request_id%22:%22168178221116800222817867%22,%22scm%22:%2220140713.130102334..%22%7D&amp;request_id=168178221116800222817867&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81359144-null-null.142%5Ev84%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=markdown%E8%AF%AD%E6%B3%95&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/u014061630/article/details/81359144?ops_request_misc=%7B%22request%5Fid%22%3A%22168178221116800222817867%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168178221116800222817867&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81359144-null-null.142^v84^control_2,239^v2^insert_chatgpt&amp;utm_term=markdown语法&amp;spm=1018.2226.3001.4187</a></p>
<h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h3><p>使用*（星号）、_（下划线）、**（两个星号）、***（三个星号）、~~（两个波浪号）包围文字</p>
<p>分别将字体设置为倾斜、倾斜、加粗、倾斜加粗、删除线</p>
<h3 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h3><p>使用1~6个#号，后加空格，分别设置一级标题六级标题</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>语法是： ![图片描述，可不写](图片的相对路径或绝对路径)</p>
<p>也可以：&lt;这里放链接&gt;</p>
<p>也可以：直接写，Markdown会自动转换</p>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>使用三个以上的*（星号）、-（减号）、_（下划线）来建立一个分割线</p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>使用一个`（与波浪键同键）将代码引起来，创建行内式代码</p>
<p>使用三个`将多行代码引起来，创建代码块</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在被引用的文本前加上&gt;（大于号）符号以及一个空格</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>在文字前使用*（星号）、+（加号）、-（减号）以及一个空格，创建无序列表</p>
<p>在文字前使用数字和一个英文句点以及一个空格表示有序列表</p>
<p>双击两次回车键取消列表或Shift+Tab减少缩进</p>
<h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>对于Markdown中的语法符号，在前面加上反斜线便可显示符号本身</p>
<h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>Tab增加缩进</p>
<p>Shift+Tab减少缩进</p>
<h2 id="数学公式-LaTex"><a href="#数学公式-LaTex" class="headerlink" title="数学公式(LaTex)"></a>数学公式(LaTex)</h2><p><strong>使用$，将数学公式写在两个$之间。写在两个$$之间是把公式居中。</strong></p>
<p><strong>下面只介绍一些常用的</strong></p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p>参考文章：</p>
<p><a href="https://zhuanlan.zhihu.com/p/441454622">https://zhuanlan.zhihu.com/p/441454622</a></p>
<h3 id="数学运算符号"><a href="#数学运算符号" class="headerlink" title="数学运算符号"></a>数学运算符号</h3><ol>
<li>加号：$+$</li>
<li>减号：$-$</li>
<li>乘号：$\times$</li>
<li>点乘：$·$ 或 $\cdot$</li>
<li>除号：$\div$</li>
<li>加减号：$\pm$</li>
<li>减加号：$\mp$</li>
<li>等于：$&#x3D;$</li>
<li>不等于：$\neq$</li>
<li>小于：$&lt;$</li>
<li>小于等于：$\leq$</li>
<li>大于：$&gt;$</li>
<li>大于等于：$\geq$</li>
<li>约等于：$\approx$</li>
<li>恒等于：$\equiv$</li>
</ol>
<h3 id="上标下标"><a href="#上标下标" class="headerlink" title="上标下标"></a>上标下标</h3><p>^ 表示上标， _ 表示下标，如果上标或下标内容多于一个字符，则使用 {} 括起来</p>
<p>例：</p>
<p>$(x^2 + x^y )^{x^y}+ x_1^2&#x3D; y_1 - y_2^{x_1-y_1^2}$</p>
<p><img src="https://pic2.zhimg.com/80/v2-766391bcc4500cdbd5519d5158bed641_720w.webp" alt="img"></p>
<h3 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h3><p>\frac{分子}{分母}，或 分子 \over 分母</p>
<p>例 ： </p>
<p>$\ frac{1-x}{y+1}$</p>
<p><img src="https://pic3.zhimg.com/80/v2-d8a0e1d79acd1318d0ff2b6c392db40e_720w.webp" alt="img"></p>
<p>$x \over x+y$</p>
<p><img src="https://pic1.zhimg.com/80/v2-880ef8076ddd69abd82eed0764eefae4_720w.webp" alt="img"></p>
<h3 id="开方"><a href="#开方" class="headerlink" title="开方"></a>开方</h3><p>\sqrt[n]{a}</p>
<p>例 ： $\sqrt[3]{4}$</p>
<p><img src="https://pic3.zhimg.com/80/v2-3a06cfdf6f8d566d52943d9fc1fa8f62_720w.webp" alt="img"></p>
<p> $\sqrt{9}$</p>
<p><img src="https://pic2.zhimg.com/80/v2-1242882d14e897e8ba9707ff0ece5ee5_720w.webp" alt="img"></p>
<h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><p>() [] 直接写就行，而 {} 则需要转义</p>
<p>例 ： </p>
<p>$f(x, y) &#x3D; x^2 + y^2, x \epsilon [0, 100], y \epsilon {1,2,3}$</p>
<p><img src="https://pic2.zhimg.com/80/v2-a32b36a9cb1538df45400642b75c4699_720w.webp" alt="img"></p>
<p>大括号，需要括号前加\left和\right</p>
<p>例：</p>
<p> $(\sqrt{1 \over 2})^2$ </p>
<p><img src="https://pic1.zhimg.com/80/v2-bf8cbebae7825cd557cb2c1fff6a4d54_720w.webp" alt="img"></p>
<p>加大括号后 $\left(\sqrt{1 \over 2}\right)$  </p>
<p><img src="https://pic1.zhimg.com/80/v2-fe2dd9146956be718c24b22554781eb0_720w.webp" alt="img"></p>
<h3 id="省略号与点乘号"><a href="#省略号与点乘号" class="headerlink" title="省略号与点乘号"></a>省略号与点乘号</h3><p>\ldots 表示底线对其的省略号，\cdots 表示中线对其的省略号，\cdot点乘号</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity</title>
    <url>/2023/09/30/SpringSecurity/</url>
    <content><![CDATA[<h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><p>安全是开发者永远绕不开的话题，一个不安全的网站，往往存在着各种致命漏洞，只要被不法分子稍加利用，就能直接击溃整个网站，甚至破坏网站宝贵的用户数据。而用户的授权校验，则是网站安全系统的典型代表，这也是用户访问网站的第一关，我们需要一个更加安全和可靠的授权校验框架，才能让我们的网站更加稳定。</p>
<p>SpringSecurity是一个基于Spring开发的非常强大的权限验证框架，其核心功能包括：</p>
<ul>
<li>认证 （用户登录）</li>
<li>授权 （此用户能够做哪些事情）</li>
<li>攻击防护 （防止伪造身份攻击）</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>参考博主：IT柏码</p>
<p>博主官网：<a href="https://itbaima.net/#/">柏码 - 让每一行代码都闪耀智慧的光芒！ (itbaima.net)</a></p>
<h2 id="网络安全基础"><a href="#网络安全基础" class="headerlink" title="网络安全基础"></a>网络安全基础</h2><p>网络安全是当今互联网时代非常重要的一个议题。在信息爆炸的今天，网络安全问题频频发生，给个人和组织带来了严重的损失和威胁，随着技术的发展和互联网的普及，我们越来越意识到网络安全已经成为一个全球性的挑战。本部分，我们会给各位小伙伴介绍网络安全的相关概念，以及常见的Web服务器攻击形式，如果你已经了解相关内容，可以直接跳过本板块。</p>
<p>其中比较典型的案例有以下几个：</p>
<p><img src="https://s2.loli.net/2023/07/01/W3oCIbqvLUn492J.png" alt="image-20230701174518205"></p>
<p>在2017年，一款名叫WannaCry的勒索软件席卷全球，导致全球大量计算机受到影响，得益于全球网络的发达，这款病毒从小规模很快发展至全球范围，勒索病毒是自熊猫烧香以来影响力最大的病毒之一。</p>
<blockquote>
<p>WannaCry（又叫Wanna Decryptor），一种“蠕虫式”的<a href="https://baike.baidu.com/item/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/16623990?fromModule=lemma_inlink">勒索病毒</a>软件，大小3.3MB，由不法分子利用<a href="https://baike.baidu.com/item/NSA/1128824?fromModule=lemma_inlink">NSA</a>（National Security Agency，<a href="https://baike.baidu.com/item/%E7%BE%8E%E5%9B%BD%E5%9B%BD%E5%AE%B6%E5%AE%89%E5%85%A8%E5%B1%80/300052?fromModule=lemma_inlink">美国国家安全局</a>）泄露的危险漏洞“EternalBlue”（永恒之蓝）进行传播 [1] 。勒索病毒肆虐，俨然是一场全球性互联网灾难，给广大电脑用户造成了巨大损失。最新统计数据显示，100多个国家和地区超过10万台电脑遭到了勒索病毒攻击、感染。 [2] 勒索病毒是自熊猫烧香以来影响力最大的<a href="https://baike.baidu.com/item/%E7%97%85%E6%AF%92/4811584?fromModule=lemma_inlink">病毒</a>之一。WannaCry勒索病毒全球大爆发，至少150个国家、30万名用户中招，造成损失达80亿美元，已经影响到金融，能源，医疗等众多行业，造成严重的危机管理问题。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/07/01/wBdynQcKU2g7LjN.png" alt="image-20230701175101126"></p>
<p>除了病毒在网络上传播外，还有非常恶心的DDOS攻击，这种攻击方式成本低，效率高，只要持续一段时间就能导致没有特殊防御的网站无法正常运作：</p>
<blockquote>
<p>2022年4月，郑州警方接到报警称，某政府网站平台于近日遭受多次DDoS攻击，导致平台访问量瞬间暴增多倍，造成数十家政府网站和政务新媒体账号无法正常访问。接到报警后，郑州警方立即开展侦查调查，第一时间锁定犯罪嫌疑人张某某，仅22小时就将犯罪嫌疑人张某某抓捕到案。</p>
<p>经审查，张某某为某医院网络安全部技术维护人员，2022年4月2日，其个人网站被DDoS攻击，导致网站无法登陆。为减少攻击对其个人网站的影响，张某某私自将个人网站域名解析地址变更为某政府网站平台地址，“转嫁”攻击流量，致使该政府网站平台被恶意网络流量攻击，多家政府网站、政务新媒体账号不能正常使用。</p>
<p>目前，张某某因涉嫌破坏计算机信息系统犯罪被公安机关移送起诉，案件正在进一步侦办中。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/07/01/5aHJDMTiLOSzERn.png" alt="image-20230701175235964"></p>
<p>信息泄露也是非常严重的网络安全问题，我们的个人信息是我们的隐私，而在网络发达的今天，在各大APP上填写的信息很有可能会被第三方获取，从中谋取利益。</p>
<blockquote>
<p>今年早些时候便已发现相关安全漏洞的网络安全专家称， 一个常见漏洞导致了这场有记录以来最大规模的个人数据泄露，也是中国所遭遇最大规模的网络安全事件，造成数据被公开在互联网上，供人取用。</p>
<p>据这些网络安全专家称，上海警方的这些记录是被安全存储的，其中包含个人姓名、身份证号码、电话号码以及警情信息，涉及近10亿中国公民的数据。他们说，但一个用于管理和访问该数据库的显示界面(dashboard)被设置在一个公开网址上，没有加设密码，任何有相对基本技术知识的人都可以轻松访问、复制或窃取库中的海量信息。</p>
<p>暗网情报公司Shadowbyte的创始人Vinny Troia说：“他们把这么多数据暴露在外，这太疯狂了。”这家公司专门在网上扫描搜寻存在安全漏洞的数据库，早在今年1月扫描时发现了上海警方的这个数据库。</p>
</blockquote>
<p>个人信息数据一旦泄露，相当于别人可以通过网络直接定位你的住址、电话号码、各种社交账号、身份证信息甚至是机票、火车票、酒店开房信息等，做的再绝一定，如果这个酒店被人偷偷放了针孔摄像头，甚至还能根据记录查到你开房视频，这些事情光是想想都可怕，这等同于在互联网上“裸奔”。</p>
<p>网络安全问题非同小可，而我们作为网站的开发者，更应该首当其冲解决这些潜在问题。接下来，我们会介绍几个常见的Web网站攻击方式，以及在后续使用SpringSecurity时如何去防范这些攻击行为。</p>
<h3 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a>测试环境搭建</h3><p>为了测试我们之前的网站安全性，这里我们基于Mvc框架重新搭建一个采用之前的验证方式的简易网站，首先是登录界面部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录白马银行<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">      用户名：</span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">      密码：</span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;status&#125;&quot;</span>&gt;</span>登录失败，用户名或密码错误！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着是登录之后的首页：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>白马银行 - 首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着是Controller部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="comment">//处理登录操作并跳转</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(<span class="meta">@RequestParam</span> String username,</span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam</span> String password,</span></span><br><span class="line"><span class="params">                        HttpSession session,</span></span><br><span class="line"><span class="params">                        Model model)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;test&quot;</span>.equals(username) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(password)) &#123;</span><br><span class="line">            session.setAttribute(<span class="string">&quot;login&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:/&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            model.addAttribute(<span class="string">&quot;status&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理首页或是登录界面跳转</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(session.getAttribute(<span class="string">&quot;login&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以进行简单登录了：</p>
<p><img src="https://s2.loli.net/2023/07/01/7jW5Nzki8urUhaf.png" alt="image-20230701184920238"></p>
<p>接着我们在首页加一个转账操作，要求填写转账人账号名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/pay&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">pay</span><span class="params">(<span class="meta">@RequestParam</span> String account,</span></span><br><span class="line"><span class="params">                      HttpSession session)</span>&#123;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    <span class="comment">//登录之后才能转账</span></span><br><span class="line">    <span class="keyword">if</span>(session.getAttribute(<span class="string">&quot;login&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;转账给&quot;</span>+account+<span class="string">&quot;成功，交易已完成！&quot;</span>);</span><br><span class="line">        object.put(<span class="string">&quot;success&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;转账给&quot;</span>+account+<span class="string">&quot;失败，用户未登录！&quot;</span>);</span><br><span class="line">        object.put(<span class="string">&quot;success&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们在页面中添加一个简单的转账操作按键：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>白马银行 - 首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios@1.1.2/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">            转账账号：</span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;account&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;pay()&quot;</span>&gt;</span>立即转账<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">pay</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> account = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;account&quot;</span>).<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">    axios.<span class="title function_">post</span>(<span class="string">&#x27;/mvc/pay&#x27;</span>, &#123; <span class="attr">account</span>: account &#125;, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">headers</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(data.<span class="property">success</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;转账成功&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">else</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;转账失败&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样我们就成功搭建好网络安全的测试项目了，各位小伙伴请将这个项目进行保存，后面需要重复使用。</p>
<p><img src="https://s2.loli.net/2023/07/01/khHj6YqSJimGKec.png" alt="image-20230701224909319"></p>
<h3 id="CSRF跨站请求伪造攻击"><a href="#CSRF跨站请求伪造攻击" class="headerlink" title="CSRF跨站请求伪造攻击"></a>CSRF跨站请求伪造攻击</h3><p>CSRF是我们要介绍的第一种攻击形式，这种攻击方式非常好理解。</p>
<p><img src="https://s2.loli.net/2023/07/01/4ibrwFIPnSE81lx.png" alt="image-20230701181244150"></p>
<p>我们时常会在QQ上收到别人发送的钓鱼网站链接，只要你在上面登陆了你的QQ账号，那么不出意外，你的号已经在别人手中了。实际上这一类网站都属于恶意网站，专门用于盗取他人信息，执行非法操作，甚至获取他人账户中的财产，非法转账等。而这里，我们需要了解一种比较容易发生的恶意操作，从不法分子的角度去了解整个流程。</p>
<p>我们在JavaWeb阶段已经了解了Session和Cookie的机制，在一开始的时候，服务端会给浏览器一个名为JSESSIONID的Cookie信息作为会话的唯一凭据，只要用户携带此Cookie访问我们的网站，那么我们就可以认定此会话属于哪个浏览器用户。因此，只要此会话的用户执行了登录操作，那么就可以随意访问个人信息等内容。</p>
<p>我们来尝试模拟一下这种操作，来编写一个钓鱼网站：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>坤坤炒粉放鸡精视频在线观看<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios@1.1.2/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">&quot;hiddenIframe&quot;</span> <span class="attr">hidden</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:8080/mvc/pay&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">target</span>=<span class="string">&quot;hiddenIframe&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span> <span class="attr">value</span>=<span class="string">&quot;黑客&quot;</span> <span class="attr">hidden</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>点击下载全套视频<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个页面并不是我们官方提供的页面，而是不法分子搭建的恶意网站。我们发现此页面中有一个表单，但是表单中的输入框被隐藏了，而我们看到的只有一个按钮，我们不知道这是一个表单，也不知道表单会提交给那个地址，这时整个页面就非常有迷惑性了。如果我们点击此按钮，那么整个表单的数据会以POST的形式发送给我们的服务端（会携带之前登陆我们网站的Cookie信息），但是这里很明显是另一个网站跳转，通过这样的方式，恶意网站就成功地在我们毫不知情的情况下引导我们执行了转账操作，当你发现上当受骗时，钱已经被转走了。</p>
<p>我们首先作为用户，先在正常的网站进行登录：</p>
<p><img src="https://s2.loli.net/2023/07/01/4wQ2iB5uhcLMJHa.png" alt="image-20230701233127287"></p>
<p>接着我们假装自己上当，进入到我们的钓鱼网站：</p>
<p><img src="https://s2.loli.net/2023/07/01/OstNZg4doCz6S5G.png" alt="image-20230701233202016"></p>
<p>现在我们毫不知情，如果是正常人思维的话，就会直接点击下载全套视频，恭喜，此时后台已经转账成功了，留下一脸懵逼的你：</p>
<p><img src="https://s2.loli.net/2023/07/01/mtGLhuNHxPUr6Os.png" alt="image-20230701233317019"></p>
<p>而这种构建恶意页面，引导用户访问对应网站执行操作的方式称为：<strong>跨站请求伪造</strong>（CSRF，Cross Site Request Forgery）</p>
<p>显然，我们之前编写的图书管理系统就存在这样的安全漏洞，而SpringSecurity就解决了这样的问题。</p>
<p>当然，除了通过我们自己SpringSecurity使用去解决之外，随着现在的浏览器不断发展，安全性越来越受到重视，很多浏览器都有SameSite保护机制，当用户在两个不同域名的站点操作时，默认情况下Cookie就会被自动屏蔽：</p>
<p><img src="https://s2.loli.net/2023/07/01/qiLDnrFyQxpt3UB.png" alt="a3421f74c3cee6b67d214809adb743a5"></p>
<p>SameSite是一种安全机制，旨在防止跨站点请求伪造（CSRF）攻击，它通过限制第三方Cookie的使用来实现这一目的。在Chrome浏览器中，SameSite默认为Lax，这意味着第三方Cookie只能在用户导航到与原始站点相同的站点时发送。这同样大大提升了用户的安全性，让黑客少了许多可乘之机，不过这个机制对做实施的同学（可能）不太友好。</p>
<h3 id="SFA会话固定攻击"><a href="#SFA会话固定攻击" class="headerlink" title="SFA会话固定攻击"></a>SFA会话固定攻击</h3><p>这同样是利用Cookie中相同的JSESSIONID进行的攻击，会话固定攻击（Session fixation attack）是一种针对Web应用程序的安全漏洞攻击，攻击者利用这种漏洞，将一个有效的会话ID分配给用户，并诱使用户在该会话中进行操作，然后攻击者可以利用该会话ID获取用户的权限，或者通过此会话继续进行其他攻击。</p>
<p>简单来说，就是黑客把他的JSESSIONID直接给你，你一旦使用这个ID登录，那么在后端这个ID就被认定为已登录状态，那么也就等同于他直接进入了已登录状态，从而直接访问你账号的任意内容，执行任意操作。</p>
<p>攻击者通常使用以下几种方式进行会话固定攻击：</p>
<ol>
<li>会话传递：攻击者通过URL参数、表单隐藏字段、cookie等方式将会话ID传递给用户。当用户使用该会话ID登录时，攻击者就能利用该会话ID获取用户的权限。</li>
<li>会话劫持：攻击者利用劫持用户与服务器之间的通信流量，获取到用户的会话ID，然后利用该会话ID冒充用户进行操作。</li>
<li>会话劫持：攻击者事先获取到会话ID，并将其分配给用户，之后通过其他方式欺骗用户登录该会话。这样，攻击者就可以利用会话ID获取用户的权限。</li>
</ol>
<p>这里我们来尝试一下第一种方案，这里我们首先用另一个浏览器访问目标网站，此时需要登录，开始之前记得先清理一下两个浏览器的缓存，否则可能无法生效：</p>
<p><img src="https://s2.loli.net/2023/07/02/LFchsWkevUwb58E.png" alt="image-20230702001501063"></p>
<p>这里我们直接记录下这个JSESSIONID，然后将其编写到我们的诈骗网站中，这里有一个恶意脚本，会自动将对应用户的Cookie进行替换，变成我们的JSESSIONID值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>冠希哥全套视频<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios@1.1.2/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  	<span class="comment">//第三方网站恶意脚本，自动修改Cookie信息</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;JSESSIONID=6AAF677EC2B630704A80D36311F08E01; path=/mvc; domain=localhost&quot;</span></span></span><br><span class="line"><span class="language-javascript">  	<span class="comment">//然后给你弄到原来的网站</span></span></span><br><span class="line"><span class="language-javascript">  	location.<span class="property">href</span> = <span class="string">&#x27;http://localhost:8080/mvc/&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着我们访问这个恶意网站，然后再作为用户，去正常访问目标网站进行登录操作：</p>
<p><img src="https://s2.loli.net/2023/07/02/d4YSeut3xQ7rRqh.png" alt="image-20230702001831904"></p>
<p>可以看到此时用户的浏览器JSESSIONID值为刚刚恶意网站伪造的值，现在我们来进行登录操作：</p>
<p><img src="https://s2.loli.net/2023/07/02/aDwTcW6d58tPLBG.png" alt="image-20230702002007450"></p>
<p>此时我们回到一开始的浏览器，刷新之后，我们发现这个浏览器同样已经登录成功了，原理其实很简单，相当于让用户直接帮我们登录了，是不是感觉特别危险？</p>
<p>当然，现在的浏览器同样有着对应的保护机制，Tomcat发送的SESSIONID默认是勾选了HttpOnly选项的，一旦被设定是无法被随意修改的，当然前提是先得正常访问一次网站才行，否则仍然存在安全隐患。</p>
<blockquote>
<p>HttpOnly是Cookie中一个属性，用于防止客户端脚本通过document.cookie属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HttpOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/07/02/8IaHk2FEMwyoXem.png" alt="image-20230702002624508"></p>
<p>为了彻底杜绝这个问题，登录成功之后应该重新给用户分配一个新的JSESSIONID才行，而这些都由SpringSecurity帮我们实现了。</p>
<h3 id="XSS跨站脚本攻击"><a href="#XSS跨站脚本攻击" class="headerlink" title="XSS跨站脚本攻击"></a>XSS跨站脚本攻击</h3><p>前面我们介绍了两种攻击方式，不过都是从外部干涉，在外部无法干涉的情况下，我们也可以从内部击溃网站，接下来我们隆重介绍XSS跨站脚本攻击方式。</p>
<p>XSS（跨站脚本攻击）是一种常见的网络安全漏洞，攻击者通过在合法网站中注入恶意脚本代码来攻击用户。当用户访问受到注入攻击的页面时，恶意代码会在用户的浏览器中执行，从而导致攻击者能够窃取用户的敏感信息、诱导用户操作、甚至控制用户的账号。</p>
<p>XSS攻击常见的方式有三种：</p>
<ol>
<li>存储型XSS攻击：攻击者将恶意代码存储到目标网站的数据库中，当其他用户访问包含恶意代码的页面时，恶意代码会被执行。</li>
<li>反射型XSS攻击：攻击者将恶意代码嵌入到URL中，当用户点击包含恶意代码的URL时，恶意代码会被执行。</li>
<li>DOM-based XSS攻击：攻击者利用前端JavaScript代码的漏洞，通过修改页面的DOM结构来执行恶意代码。</li>
</ol>
<p>在一些社交网站上，用户可以自由发帖，而帖子是以富文本形式进行编辑和上传的，发送给后台的帖子往往是直接以HTML代码的形式，这个时候就会给黑客可乘之机了。</p>
<p><img src="https://s2.loli.net/2023/07/02/jTcOaNdwDeP9qB2.png" alt="image-20230702003831742"></p>
<p>正常情况下，用户发帖会向后端上传以下内容，这些是经过转换得到的正常HTML代码，方便后续直接展示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content ql-editor&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>萨达睡觉了大数据<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>撒大大撒大声地<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而现在，黑客不走常规的方式发帖，而是发送以下内容给服务端：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content ql-editor&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">οnlοad</span>=<span class="string">&quot;alert(&#x27;xss&#x27;)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>萨达睡觉了大数据<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>撒大大撒大声地<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>p</code>标签上添加了一段JS恶意脚本，黑客可以利用这种特性，获取用户的各种信息，甚至直接发送到他的后台，这样，我们的个人信息就从网站内部被泄露了。</p>
<p>XSS漏洞最早被发现是在1996年，由于JavaScript的出现，导致在Web应用程序中存在了一些安全问题。在1997年，高智文(Gareth Owen)也就是“XSS之父”，在他的博客中描述了一种称为“脚本注入”(script injection)的攻击技术，这就是XSS漏洞的前身。从那时起，XSS漏洞便成为了Web应用程序中的一种常见安全漏洞。</p>
<p><img src="https://s2.loli.net/2023/07/02/DkzJWPxQ5BUl2tC.png" alt="image-20230702004827194"></p>
<p>这种攻击一般需要前端配合后端进行防御，或者后端对前端发送的内容进行安全扫描并处理，有机会我们会分享如何防范此类攻击。</p>
<p>在了解这么多攻击方式之后，想必各位小伙伴肯定有了一定的网络安全意识，不过我们并不是网络安全专业的课程，至于更多的攻击形式，还请各位小伙伴自行了解，从下一个板块开始，我们将会正式开始SpringSecurity框架的介绍。</p>
<hr>
<h2 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h2><p>我们继续使用之前的测试项目进行教学，首先我们需要导入SpringSecurity的相关依赖，它不仅仅是一个模块，我们可以根据需求导入需要的模块，常用的是以下两个：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着我们需要配置SpringSecurity，与Mvc一样，需要一个初始化器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractSecurityWebApplicationInitializer</span> &#123;</span><br><span class="line">    <span class="comment">//不用重写任何内容</span></span><br><span class="line">  	<span class="comment">//这里实际上会自动注册一个Filter，SpringSecurity底层就是依靠N个过滤器实现的，我们之后再探讨</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们需要再创建一个配置类用于配置SpringSecurity：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span>   <span class="comment">//开启WebSecurity相关功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在根容器中添加此配置文件即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;MainConfiguration.class, SecurityConfiguration.class&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，SpringSecurity的配置就完成了，我们再次运行项目，会发现无法进入的我们的页面中，无论我们访问哪个页面，都会进入到SpringSecurity为我们提供的一个默认登录页面，之后我们会讲解如何进行配置。</p>
<p><img src="https://s2.loli.net/2023/07/02/dWkGc5YhNAIbP8j.png" alt="image-20230702135644834"></p>
<p>至此，项目环境搭建完成。</p>
<hr>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>认证是我们网站的第一步，用户需要登录之后才能进入，这一部分我们将详细介绍如何使用SpringSecurity实现用户登录。</p>
<h3 id="基于内存验证"><a href="#基于内存验证" class="headerlink" title="基于内存验证"></a>基于内存验证</h3><p>首先我们来看看最简单的基于内存的配置，也就是说我们直接以代码的形式配置我们网站的用户和密码，配置方式非常简单，只需要在Security配置类中注册一个Bean即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//UserDetailsService就是获取用户信息的服务</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="comment">//每一个UserDetails就代表一个用户信息，其中包含用户的用户名和密码以及角色</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> User.withDefaultPasswordEncoder()</span><br><span class="line">                .username(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .roles(<span class="string">&quot;USER&quot;</span>)  <span class="comment">//角色目前我们不需要关心，随便写就行，后面会专门讲解</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">admin</span> <span class="operator">=</span> User.withDefaultPasswordEncoder()</span><br><span class="line">                .username(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .roles(<span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(user, admin); </span><br><span class="line">      	<span class="comment">//创建一个基于内存的用户信息管理器作为UserDetailsService</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后，我们就可以前往登录界面，进行登录操作了：</p>
<p><img src="https://s2.loli.net/2023/07/02/tSGxZmv6jUDMy95.png" alt="image-20230702144938540"></p>
<p>登录成功后，就可以访问到我们之前的界面了：</p>
<p><img src="https://s2.loli.net/2023/07/02/Z8fxKehX26AMaJI.png" alt="image-20230702145011992"></p>
<p>并且为了防止我们之前提到的会话固定问题，在登录之后，JSESSIONID会得到重新分配：</p>
<p><img src="https://s2.loli.net/2023/07/03/mQpWZMljCt2XTd7.png" alt="image-20230703192441811"></p>
<p>当我们想要退出时，也可以直接访问：<a href="http://localhost:8080/mvc/logout">http://localhost:8080/mvc/logout</a> 地址，我们会进入到一个退出登录界面：</p>
<p><img src="https://s2.loli.net/2023/07/02/iHQy63RxgUkvKsw.png" alt="image-20230702145432892"></p>
<p>退出登录后就需要重新登录才能访问我们的网站了。</p>
<p>可以发现，在有了SpringSecurity之后，我们网站的登录验证模块相当于直接被接管了，因此，从现在开始，我们的网站不需要再自己编写登录模块了，这里我们可以直接去掉，只留下主页面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在所有接口不需要任何验证了，因为Security已经帮我们做了，没登录是根本进不来的</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/pay&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JSONObject <span class="title function_">pay</span><span class="params">(<span class="meta">@RequestParam</span> String account)</span>&#123;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;转账给&quot;</span>+account+<span class="string">&quot;成功，交易已完成！&quot;</span>);</span><br><span class="line">        object.put(<span class="string">&quot;success&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们的网站就成功用上了更加安全的SpringSecurity框架了。细心的小伙伴可能发现了，我们在配置用户信息的时候，报了黄标，实际上这种方式存储密码并不安全：</p>
<p><img src="https://s2.loli.net/2023/07/02/yuYe5pODwqBTQh7.png" alt="image-20230702151123338"></p>
<p>这是因为SpringSecurity的密码校验不推荐直接使用原文进行比较，而是使用加密算法将密码进行加密（更准确地说应该进行Hash处理，此过程是不可逆的，无法解密），最后将用户提供的密码以同样的方式加密后与密文进行比较。对于我们来说，用户提供的密码属于隐私信息，直接明文存储并不好，而且如果数据库内容被窃取，那么所有用户的密码将全部泄露，这是我们不希望看到的结果，我们需要一种既能隐藏用户密码也能完成认证的机制，而Hash处理就是一种很好的解决方案，通过将用户的密码进行Hash值计算，计算出来的结果一般是单向的，无法还原为原文，如果需要验证是否与此密码一致，那么需要以同样的方式加密再比较两个Hash值是否一致，这样就很好的保证了用户密码的安全性。</p>
<p>因此，我们在配置用户信息的时候，可以使用官方提供的BCrypt加密工具：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">//这里将BCryptPasswordEncoder直接注册为Bean，Security会自动进行选择</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">(PasswordEncoder encoder)</span> &#123;</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> User</span><br><span class="line">                .withUsername(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .password(encoder.encode(<span class="string">&quot;password&quot;</span>))   <span class="comment">//这里将密码进行加密后存储</span></span><br><span class="line">                .roles(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">      	System.out.println(encoder.encode(<span class="string">&quot;password&quot;</span>));  <span class="comment">//一会观察一下加密出来之后的密码长啥样</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">admin</span> <span class="operator">=</span> User</span><br><span class="line">                .withUsername(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                .password(encoder.encode(<span class="string">&quot;password&quot;</span>))   <span class="comment">//这里将密码进行加密后存储</span></span><br><span class="line">                .roles(<span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(user, admin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们存储的密码就是更加安全的密码了：</p>
<p><img src="https://s2.loli.net/2023/07/02/Vacp97MlgfNrYnR.png" alt="image-20230702152150157"></p>
<p><img src="https://s2.loli.net/2023/07/02/tk5pGDrNHWfaJXU.png" alt="image-20230702152216162"></p>
<p>这样，一个简单的权限校验就配置完成了，是不是感觉用起来还是挺简单的？</p>
<p>不过，可能会有小伙伴发现，所有的POST请求都被403了：</p>
<p><img src="https://s2.loli.net/2023/07/02/F94URzLh6oIBrCJ.png" alt="image-20230702183040922"></p>
<p>这是因为SpringSecurity自带了csrf防护，需求我们在POST请求中携带页面中的csrfToken才可以，否则一律进行拦截操作，这里我们可以将其嵌入到页面中，随便找一个地方添加以下内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:id</span>=<span class="string">&quot;$&#123;_csrf.getParameterName()&#125;&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span> <span class="attr">hidden</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着在axios发起请求时，携带这个input的value值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pay</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> account = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;account&quot;</span>).<span class="property">value</span></span><br><span class="line">    <span class="keyword">const</span> csrf = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;_csrf&quot;</span>).<span class="property">value</span></span><br><span class="line">    axios.<span class="title function_">post</span>(<span class="string">&#x27;/mvc/pay&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">account</span>: account,</span><br><span class="line">        <span class="attr">_csrf</span>: csrf   <span class="comment">//携带此信息即可，否则会被拦截</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<p>如果后续各位小伙伴遇到那种需要再form表单中提交的情况，也可以直接像下面这样给塞到表单里：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/xxxx&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  	...</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:name</span>=<span class="string">&quot;$&#123;_csrf.getParameterName()&#125;&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span> <span class="attr">hidden</span>&gt;</span></span><br><span class="line">  	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实际上现在的浏览器已经很安全了，完全不需要使用自带的csrf防护，后面我们会讲解如何通过配置关闭csrf防护。这里温馨提醒一下，在后续各位小伙伴跟我们的实战项目时，如果遇到诸如401、403这种错误时，优先查看你的SpringSecurity配置是否错误。</p>
<blockquote>
<p>从Spring Security 4.0开始，默认情况下会启用CSRF保护，以防止CSRF攻击应用程序，Spring Security CSRF会针对PATCH，POST，PUT和DELETE方法的请求（不仅仅只是登陆请求，这里指的是任何请求路径）进行防护，而这里的登陆表单正好是一个POST类型的请求。在默认配置下，无论是否登陆，页面中只要发起了PATCH，POST，PUT和DELETE请求一定会被拒绝，并返回<strong>403</strong>错误<strong>（注意，这里是个究极大坑，这个没有任何提示，直接403，因此如果你不知道的话根本不清楚是什么问题，就一直卡这里了）</strong>，需要在请求的时候加入csrfToken才行，也就是”83421936-b84b-44e3-be47-58bb2c14571a”，正是csrfToken，如果提交的是表单类型的数据，那么表单中必须包含此Token字符串，键名称为”_csrf”；如果是JSON数据格式发送的，那么就需要在请求头中包含此Token字符串。</p>
</blockquote>
<h3 id="基于数据库验证"><a href="#基于数据库验证" class="headerlink" title="基于数据库验证"></a>基于数据库验证</h3><p>前面我们已经实现了直接认证的方式，但是实际项目中往往都是将用户信息存储在数据库中，那么如何将其连接到数据库，通过查询数据库中的用户信息来进行用户登录呢？</p>
<p>官方默认提供了可以直接使用的用户和权限表设计，根本不需要我们来建表，直接在Navicat中执行以下查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users(username <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,password <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">not</span> <span class="keyword">null</span>,enabled <span class="type">boolean</span> <span class="keyword">not</span> <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> authorities (username <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,authority <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,<span class="keyword">constraint</span> fk_authorities_users <span class="keyword">foreign</span> key(username) <span class="keyword">references</span> users(username));</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index ix_auth_username <span class="keyword">on</span> authorities (username,authority);</span><br></pre></td></tr></table></figure>

<p>接着我们添加Mybatis和MySQL相关的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着我们编写配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">      	<span class="comment">//数据源配置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PooledDataSource</span>(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>,</span><br><span class="line">                <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">(DataSource dataSource,</span></span><br><span class="line"><span class="params">                                                 PasswordEncoder encoder)</span> &#123;</span><br><span class="line">        <span class="type">JdbcUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcUserDetailsManager</span>(dataSource);</span><br><span class="line">      	<span class="comment">//仅首次启动时创建一个新的用户用于测试，后续无需创建</span></span><br><span class="line">   			manager.createUser(User.withUsername(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                      .password(encoder.encode(<span class="string">&quot;password&quot;</span>)).roles(<span class="string">&quot;USER&quot;</span>).build());</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动后，可以看到两张表中已经自动添加好对应的数据了：</p>
<p><img src="https://s2.loli.net/2023/07/02/VG19mSConefsilH.png" alt="image-20230702181131252"></p>
<p><img src="https://s2.loli.net/2023/07/02/6uqerwFo13p9jxJ.png" alt="image-20230702181119809"></p>
<p>我们可以直接尝试进行登录，使用方式和之前是完全一样的：</p>
<p><img src="https://s2.loli.net/2023/07/02/dVM5ltzF1ua8Y3E.png" alt="image-20230702181211157"></p>
<p>这样，当我们下次需要快速创建一个用户登录的应用程序时，直接使用这种方式就能快速完成了，是不是感觉特别方便。</p>
<p>无论是我们上节课认识的InMemoryUserDetailsManager还是现在认识的JdbcUserDetailsManager，他们都是实现自UserDetailsManager接口，这个接口中有着一套完整的增删改查操作，方便我们直接对用户进行处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetailsManager</span> <span class="keyword">extends</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">//创建一个新的用户</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(UserDetails user)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//更新用户信息</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(UserDetails user)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//删除用户</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//修改用户密码</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">changePassword</span><span class="params">(String oldPassword, String newPassword)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断是否存在指定用户</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">userExists</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用UserDetailsManager对象，我们就能快速执行用户相关的管理操作，比如我们可以直接在网站上添加一个快速重置密码的接口，首先需要配置一下JdbcUserDetailsManager，为其添加一个AuthenticationManager用于原密码的校验：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//手动创建一个AuthenticationManager用于处理密码校验</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager <span class="title function_">authenticationManager</span><span class="params">(UserDetailsManager manager,</span></span><br><span class="line"><span class="params">                                                        PasswordEncoder encoder)</span>&#123;</span><br><span class="line">        <span class="type">DaoAuthenticationProvider</span> <span class="variable">provider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DaoAuthenticationProvider</span>();</span><br><span class="line">        provider.setUserDetailsService(manager);</span><br><span class="line">        provider.setPasswordEncoder(encoder);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProviderManager</span>(provider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsManager <span class="title function_">userDetailsService</span><span class="params">(DataSource dataSource,</span></span><br><span class="line"><span class="params">                                                 PasswordEncoder encoder)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">JdbcUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcUserDetailsManager</span>(dataSource);</span><br><span class="line">      	<span class="comment">//为UserDetailsManager设置AuthenticationManager即可开启重置密码的时的校验</span></span><br><span class="line">        manager.setAuthenticationManager(authenticationManager(manager, encoder));</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着我们编写一个快速重置密码的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/change-password&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">changePassword</span><span class="params">(<span class="meta">@RequestParam</span> String oldPassword,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@RequestParam</span> String newPassword)</span> &#123;</span><br><span class="line">    manager.changePassword(oldPassword, encoder.encode(newPassword));</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    object.put(<span class="string">&quot;success&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们在主界面中添加一个重置密码的操作：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        修改密码：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;oldPassword&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;旧密码&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;newPassword&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;新密码&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;change()&quot;</span>&gt;</span>修改密码<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldPassword = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;oldPassword&quot;</span>).<span class="property">value</span></span><br><span class="line">    <span class="keyword">const</span> newPassword = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;newPassword&quot;</span>).<span class="property">value</span></span><br><span class="line">    <span class="keyword">const</span> csrf = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;_csrf&quot;</span>).<span class="property">value</span></span><br><span class="line">    axios.<span class="title function_">post</span>(<span class="string">&#x27;/mvc/change-password&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">oldPassword</span>: oldPassword,</span><br><span class="line">        <span class="attr">newPassword</span>: newPassword,</span><br><span class="line">        <span class="attr">_csrf</span>: csrf</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">headers</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(data.<span class="property">success</span> ? <span class="string">&quot;密码修改成功&quot;</span> : <span class="string">&quot;密码修改失败，请检查原密码是否正确&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以在首页进行修改密码操作了：</p>
<p><img src="https://s2.loli.net/2023/07/03/akAtDrPeMdc6N3b.png" alt="image-20230703001525592"></p>
<p>当然，这种方式的权限校验虽然能够直接使用数据库，但是存在一定的局限性，只适合快速搭建Demo使用，不适合实际生产环境下编写，下一节我们将介绍如何实现自定义验证，以应对各种情况。</p>
<h3 id="自定义验证"><a href="#自定义验证" class="headerlink" title="自定义验证"></a>自定义验证</h3><p>有些时候，我们的数据库可能并不会像SpringSecurity默认的那样进行设计，而是采用自定义的表结构，这种情况下，上面两种方式就很难进行验证了，此时我们得编写自定义验证，来应对各种任意变化的情况。</p>
<p>既然需要自定义，那么我们就需要自行实现UserDetailsService或是功能更完善的UserDetailsManager接口，这里为了简单，我们直接选择前者进行实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们需要去实现这个<code>loadUserByUsername</code>方法，表示在验证的时候通过自定义的方式，根据给定的用户名查询用户，并封装为<code>UserDetails</code>对象返回，然后由SpringSecurity将我们返回的对象与用户登录的信息进行核验，基本流程实际上跟之前是一样的，只是现在由我们自己来提供用户查询方式。</p>
<p>现在我们在数据库中创建一个自定义的用户表：</p>
<p><img src="https://s2.loli.net/2023/07/03/ln4uZ1TFIe7qaCK.png" alt="image-20230703181046326"></p>
<p>随便插入一点数据：</p>
<p><img src="https://s2.loli.net/2023/07/03/tToR2JPykeuCK73.png" alt="image-20230703152719655"></p>
<p>接着我们自行编写对应的查询操作，首先创建一个对应的实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String username;</span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是根据用户名查询用户的Mapper接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where username = #&#123;username&#125;&quot;)</span></span><br><span class="line">    Account <span class="title function_">findUserByName</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们在配置类上添加相应的包扫描：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScans(&#123;</span></span><br><span class="line"><span class="meta">        @ComponentScan(&quot;com.example.controller&quot;),</span></span><br><span class="line"><span class="meta">        @ComponentScan(&quot;com.example.service&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们来到Service这边进行一下完善，从数据库中进行查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    UserMapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> mapper.findUserByName(username);</span><br><span class="line">        <span class="keyword">if</span>(account == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> User</span><br><span class="line">                .withUsername(username)</span><br><span class="line">                .password(account.getPassword())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就通过自定义的方式实现了数据库信息查询，并完成用户登录操作。</p>
<h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><p>前面我们介绍了如果将SpringSecurity作为我们的登录校验框架，并且实现了三种方式的校验，但是光是这样，自由度还远远不够，在实际开发场景中，我们还会面对各种各样的需求，这一部分我们接着来进行更加深层次的配置。</p>
<h3 id="自定义登录界面"><a href="#自定义登录界面" class="headerlink" title="自定义登录界面"></a>自定义登录界面</h3><p>虽然SpringSecurity为我们提供了一个还行的登录界面，但是很多情况下往往都是我们使用自定义的登录界面，这个时候就需要进行更多的配置了，我们还是以之前图书管理系统使用的模版为例。</p>
<p>下载好模版后，我们将其中的两个页面和资源文件放到类路径下：</p>
<p><img src="https://image.itbaima.net/markdown/2023/07/03/hpZs1DLESojHJue.png" alt="image-20230703180438190"></p>
<p>接着我们配置对应页面的Controller控制器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们在登录之后，就可以展示前端模版页面了：</p>
<p><img src="https://image.itbaima.net/markdown/2023/07/03/Zns4Vwb7zPLc6SQ.png" alt="image-20230703182321093"></p>
<p>不过现在依然是默认进入到SpringSecurity默认的登录界面，现在我们来配置自定义的登录界面，将我们的前端模版中的登录页面作为SpringSecurity的默认登录界面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  	...</span><br><span class="line">  </span><br><span class="line">		<span class="comment">//如果你学习过SpringSecurity 5.X版本，可能会发现新版本的配置方式完全不一样</span></span><br><span class="line">    <span class="comment">//新版本全部采用lambda形式进行配置，无法再使用之前的and()方法进行连接了</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> http</span><br><span class="line">                <span class="comment">//以下是验证请求拦截和放行配置</span></span><br><span class="line">                .authorizeHttpRequests(auth -&gt; &#123;</span><br><span class="line">                    auth.anyRequest().authenticated();    <span class="comment">//将所有请求全部拦截，一律需要验证</span></span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//以下是表单登录相关配置</span></span><br><span class="line">                .formLogin(conf -&gt; &#123;</span><br><span class="line">                    conf.loginPage(<span class="string">&quot;/login&quot;</span>);   <span class="comment">//将登录页设置为我们自己的登录页面</span></span><br><span class="line">                    conf.loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>); <span class="comment">//登录表单提交的地址，可以自定义</span></span><br><span class="line">                    conf.defaultSuccessUrl(<span class="string">&quot;/&quot;</span>);   <span class="comment">//登录成功后跳转的页面</span></span><br><span class="line">                    conf.permitAll();    <span class="comment">//将登录相关的地址放行，否则未登录的用户连登录界面都进不去</span></span><br><span class="line">                  	<span class="comment">//用户名和密码的表单字段名称，不过默认就是这个，可以不配置，除非有特殊需求</span></span><br><span class="line">                    conf.usernameParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">                    conf.passwordParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要配置登陆页面的地址和登陆请求发送的地址，这里登陆页面填写为<code>/login</code>，登陆请求地址为<code>/doLogin</code>，登陆页面我们刚刚已经自己编写Controller来实现了，登陆请求提交处理由SpringSecurity提供，只需要写路径就可以了。现在访问我们的网站，就可以进入到自定义的登录界面了：</p>
<p><img src="https://image.itbaima.net/markdown/2023/07/03/c38kewdxtn1j2V6.png" alt="image-20230703184425313"></p>
<p>但是我们发现，我们的页面只有一个纯文本，这是因为在获取静态资源的时候，所有的静态资源默认情况下也会被拦截，因此全部被302重定向到登录页面，这显然是不对的：</p>
<p><img src="https://image.itbaima.net/markdown/2023/07/03/6vXlPZprzjJLEeq.png" alt="image-20230703184641792"></p>
<p>因此，现在我们需要将所有的静态资源也给放行，否则登录界面都没法正常展示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.authorizeHttpRequests(auth -&gt; &#123;</span><br><span class="line">      auth.requestMatchers(<span class="string">&quot;/static/**&quot;</span>).permitAll();   <span class="comment">//将所有的静态资源放行，一定要添加在全部请求拦截之前</span></span><br><span class="line">      auth.anyRequest().authenticated();    <span class="comment">//将所有请求全部拦截，一律需要验证</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>再次访问我们的网站，就可以看到正常显示的登录界面了：</p>
<p><img src="https://image.itbaima.net/markdown/2023/07/03/LmZbihzD4vYB5GF.png" alt="image-20230703185027927"></p>
<p>因此，如果各位小伙伴后续在编写项目过程中发现有302的情况，一定要先检查是否因为没有放行导致被SpringSecurity给拦截了，别再遇到302一脸懵逼了。</p>
<p>接着我们来配置登录操作，这里我们只需要配置一下登录的地址和登录按钮即可，当然，跟之前一样，要把CSRF的输入框也加上：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;doLogin&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">		...</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Email Address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ad-input&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ad-input&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:name</span>=<span class="string">&quot;$&#123;_csrf.getParameterName()&#125;&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span> <span class="attr">hidden</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ad-auth-btn&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ad-btn ad-login-member&quot;</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着我们就可以尝试进行登录操作了：</p>
<p><img src="https://image.itbaima.net/markdown/2023/07/03/P2LS8uNRQ64WEvT.png" alt="image-20230703185916404"></p>
<p>可以看到，现在我们可以成功地登录到主页了。</p>
<p>退出登录也是同样的操作，我们只需要稍微进行一下配置就可以实现，我们首先继续完善配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> http</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">//以下是退出登录相关配置</span></span><br><span class="line">                .logout(conf -&gt; &#123;</span><br><span class="line">                    conf.logoutUrl(<span class="string">&quot;/doLogout&quot;</span>);   <span class="comment">//退出登录地址，跟上面一样可自定义</span></span><br><span class="line">                    conf.logoutSuccessUrl(<span class="string">&quot;/login&quot;</span>);  <span class="comment">//退出登录成功后跳转的地址，这里设置为登录界面</span></span><br><span class="line">                    conf.permitAll();</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来稍微魔改一下页面中的退出登录按钮：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;doLogout&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:name</span>=<span class="string">&quot;$&#123;_csrf.getParameterName()&#125;&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span> <span class="attr">hidden</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-sign-out-alt&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> logout</span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在我们点击右上角的退出按钮就可以退出了：</p>
<p><img src="https://image.itbaima.net/markdown/2023/07/03/yM8TOAxYPf3iqFs.png" alt="image-20230703190714519"></p>
<p>不过，可能会有小伙伴觉得，我们现在无论提交什么请求都需要Csrf校验，有些太麻烦了，实际上现在浏览器已经很安全了，没必要防御到这种程度，我们也可以直接在配置中关闭csrf校验：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">   	...</span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> http</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">//以下是csrf相关配置</span></span><br><span class="line">                .csrf(conf -&gt; &#123;</span><br><span class="line">                    conf.disable();   <span class="comment">//此方法可以直接关闭全部的csrf校验，一步到位</span></span><br><span class="line">                    conf.ignoringRequestMatchers(<span class="string">&quot;/xxx/**&quot;</span>);   <span class="comment">//此方法可以根据情况忽略某些地址的csrf校验</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就不需要再往页面中嵌入CSRF相关的输入框了，发送请求时也不会进行校验，至此，我们就完成了简单的自定义登录界面配置。</p>
<h3 id="记住我功能"><a href="#记住我功能" class="headerlink" title="记住我功能"></a>记住我功能</h3><p>我们的网站还有一个重要的功能，就是记住我，也就是说我们可以在登陆之后的一段时间内，无需再次输入账号和密码进行登陆，相当于服务端已经记住当前用户，再次访问时就可以免登陆进入，这是一个非常常用的功能。</p>
<p>我们之前在JavaWeb阶段，使用本地Cookie存储的方式实现了记住我功能，但是这种方式并不安全，同时在代码编写上也比较麻烦，那么能否有一种更加高效的记住我功能实现呢？</p>
<p>SpringSecurity为我们提供了一种优秀的实现，它为每个已经登陆的浏览器分配一个携带Token的Cookie，并且此Cookie默认会被保留14天，只要我们不清理浏览器的Cookie，那么下次携带此Cookie访问服务器将无需登陆，直接继续使用之前登陆的身份，这样显然比我们之前的写法更加简便。并且我们需要进行简单配置，即可开启记住我功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> http</span><br><span class="line">                ...</span><br><span class="line">                .rememberMe(conf -&gt; &#123;</span><br><span class="line">                    conf.alwaysRemember(<span class="literal">false</span>);  <span class="comment">//这里不要开启始终记住，我们需要配置为用户自行勾选</span></span><br><span class="line">                    conf.rememberMeParameter(<span class="string">&quot;remember-me&quot;</span>);   <span class="comment">//记住我表单字段，默认就是这个，可以不配置</span></span><br><span class="line">                    conf.rememberMeCookieName(<span class="string">&quot;xxxx&quot;</span>);  <span class="comment">//记住我设置的Cookie名字，也可以自定义，不过没必要</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后，我们需要修改一下前端页面中的表单，将记住我勾选框也作为表单的一部分进行提交：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ad-checkbox&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remember-me&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ad-checkbox&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>Remember Me<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着我们来尝试勾选记住我选项进行登录：</p>
<p><img src="https://image.itbaima.net/markdown/2023/07/04/3wOt7CldbFP8yHz.png" alt="image-20230704211415804"></p>
<p>此时提交的表单中就已经包含记住我字段了，我们会发现，服务端返回给我们了一个记住我专属的Cookie信息：</p>
<p><img src="https://image.itbaima.net/markdown/2023/07/04/NB129h7IKRycXvL.png" alt="image-20230704211611369"></p>
<p>这个Cookie信息的过期时间并不是仅会话，而是默认保存一段时间，因此，我们关闭浏览器后下次再次访问网站时，就不需要我们再次进行登录操作了，而是直接继续上一次的登录状态。</p>
<p>当然，由于记住我信息是存放在内存中的，我们需要保证服务器一直处于运行状态，如果关闭服务器的话，记住我信息会全部丢失，因此，如果我们希望记住我能够一直持久化保存，我们就需要进一步进行配置。我们需要创建一个基于JDBC的TokenRepository实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PersistentTokenRepository <span class="title function_">tokenRepository</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">    <span class="type">JdbcTokenRepositoryImpl</span> <span class="variable">repository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTokenRepositoryImpl</span>();</span><br><span class="line">  	<span class="comment">//在启动时自动在数据库中创建存储记住我信息的表，仅第一次需要，后续不需要</span></span><br><span class="line">    repository.setCreateTableOnStartup(<span class="literal">true</span>);</span><br><span class="line">    repository.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> repository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后添加此仓库：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.rememberMe(conf -&gt; &#123;</span><br><span class="line">     conf.rememberMeParameter(<span class="string">&quot;remember-me&quot;</span>);</span><br><span class="line">     conf.tokenRepository(repository);      <span class="comment">//设置刚刚的记住我持久化存储库</span></span><br><span class="line">     conf.tokenValiditySeconds(<span class="number">3600</span> * <span class="number">7</span>);   <span class="comment">//设置记住我有效时间为7天</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样，我们就成功配置了数据库持久化存储记住我信息，即使我们重启服务器也不会导致数据丢失。当我们登录之后，数据库中会自动记录相关的信息：</p>
<p><img src="https://image.itbaima.net/markdown/2023/07/04/kIJpuWdiEGqUKBx.png" alt="image-20230704220701000"></p>
<p>这样，我们网站的登录系统就更加完善了。</p>
<hr>
<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>用户登录后，可能会根据用户当前是身份进行角色划分，比如我们最常用的QQ，一个QQ群里面，有群主、管理员和普通群成员三种角色，其中群主具有最高权限，群主可以管理整个群的任何板块，并且具有解散和升级群的资格，而管理员只有群主的一部分权限，只能用于日常管理，普通群成员则只能进行最基本的聊天操作。</p>
<p><img src="https://image.itbaima.net/markdown/2023/07/04/e1IXMRgawYoGvSQ.png" alt="image-20230704222032360"></p>
<p>对于我们来说，用户的一个操作实际上就是在访问我们提供的<code>接口</code>(编写的对应访问路径的Servlet），比如登陆，就需要调用<code>/login</code>接口，退出登陆就要调用&#x2F;<code>logout</code>接口，而我们之前的图书管理系统中，新增图书、删除图书，所有的操作都有着对应的Servlet来进行处理。因此，从我们开发者的角度来说，决定用户能否使用某个功能，只需要决定用户是否能够访问对应的Servlet即可。</p>
<p>我们可以大致像下面这样进行划分：</p>
<ul>
<li>群主：<code>/login</code>、<code>/logout</code>、<code>/chat</code>、<code>/edit</code>、<code>/delete</code>、<code>/upgrade</code></li>
<li>管理员：<code>/login</code>、<code>/logout</code>、<code>/chat</code>、<code>/edit</code></li>
<li>普通群成员：<code>/login</code>、<code>/logout</code>、<code>/chat</code></li>
</ul>
<p>也就是说，我们需要做的就是指定哪些请求可以由哪些用户发起。</p>
<p>SpringSecurity为我们提供了两种授权方式：</p>
<ul>
<li>基于权限的授权：只要拥有某权限的用户，就可以访问某个路径。</li>
<li>基于角色的授权：根据用户属于哪个角色来决定是否可以访问某个路径。</li>
</ul>
<p>两者只是概念上的不同，实际上使用起来效果差不多。这里我们就先演示以角色方式来进行授权。</p>
<h3 id="基于角色授权"><a href="#基于角色授权" class="headerlink" title="基于角色授权"></a>基于角色授权</h3><p>现在我们希望创建两个角色，普通用户和管理员，普通用户只能访问index页面，而管理员可以访问任何页面。</p>
<p>首先我们需要对数据库中的角色表进行一些修改，添加一个用户角色字段，并创建一个新的用户，Test用户的角色为user，而Admin用户的角色为admin。</p>
<p>接着我们需要配置SpringSecurity，决定哪些角色可以访问哪些页面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.authorizeHttpRequests(auth -&gt; &#123;</span><br><span class="line">    <span class="comment">//静态资源依然全部可以访问</span></span><br><span class="line">    auth.requestMatchers(<span class="string">&quot;/static/**&quot;</span>).permitAll();</span><br><span class="line">    <span class="comment">//只有具有以下角色的用户才能访问路径&quot;/&quot;</span></span><br><span class="line">    auth.requestMatchers(<span class="string">&quot;/&quot;</span>).hasAnyRole(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    <span class="comment">//其他所有路径必须角色为admin才能访问</span></span><br><span class="line">    auth.anyRequest().hasRole(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>接着我们需要稍微修改一下验证逻辑，我们在数据库中的用户表上添加一个新的字段，用于表示角色：</p>
<p><img src="https://s2.loli.net/2023/07/04/1pkfGS9LrsPtjFx.png" alt="image-20230704222733082"></p>
<p>修改一下对应的实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String username;</span><br><span class="line">    String password;</span><br><span class="line">    String role;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们在查询用户时，需要添加其对应的角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> mapper.findUserByName(username);</span><br><span class="line">    <span class="keyword">if</span>(account == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> User</span><br><span class="line">            .withUsername(username)</span><br><span class="line">            .password(account.getPassword())</span><br><span class="line">            .roles(account.getRole())   <span class="comment">//添加角色，一个用户可以有一个或多个角色</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以了，我们重启服务器登录看看：</p>
<p><img src="https://s2.loli.net/2023/07/03/Zns4Vwb7zPLc6SQ.png" alt="image-20230703182321093"></p>
<p>目前依然是可以正常登录的，但是我们随便访问一个其他的页面，就会被拦截并自动退回到登录界面：</p>
<p><img src="https://s2.loli.net/2023/07/04/8aoGrM9mpYt6Xie.png" alt="image-20230704223248124"></p>
<p>这是因为我们前面配置的是user角色，那么这个角色只能访问首页，其他的都不行，所以就会被自动拦截掉了。现在我们可以到数据库中对这个用户的角色进行修改，看看修改后是否能够访问到其他页面：</p>
<p><img src="https://s2.loli.net/2023/07/04/l9YkDaRJdtrmSZj.png" alt="image-20230704223503682"></p>
<p>这样就可以访问其他页面不会被拦截了，不过因为我们没配置这个路径，所以出来的是404页面。</p>
<p>通过使用角色控制页面的访问，我们就可以让某些用户只能访问部分页面。</p>
<h3 id="基于权限授权"><a href="#基于权限授权" class="headerlink" title="基于权限授权"></a>基于权限授权</h3><p>基于权限的授权与角色类似，需要以<code>hasAnyAuthority</code>或<code>hasAuthority</code>进行判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.authorizeHttpRequests(auth -&gt; &#123;</span><br><span class="line">    <span class="comment">//静态资源依然全部可以访问</span></span><br><span class="line">    auth.requestMatchers(<span class="string">&quot;/static/**&quot;</span>).permitAll();</span><br><span class="line">    <span class="comment">//基于权限和基于角色其实差别并不大，使用方式是相同的</span></span><br><span class="line">    auth.anyRequest().hasAnyAuthority(<span class="string">&quot;page:index&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>实际上权限跟角色相比只是粒度更细，由于使用方式差不多，这里不多做阐述。</p>
<h3 id="使用注解权限判断"><a href="#使用注解权限判断" class="headerlink" title="使用注解权限判断"></a>使用注解权限判断</h3><p>除了直接配置以外，我们还可以以注解形式直接配置，首先需要在配置类（注意这里是在Mvc的配置类上添加，因为这里只针对Controller进行过滤，所有的Controller是由Mvc配置类进行注册的，如果需要为Service或其他Bean也启用权限判断，则需要在Security的配置类上添加）上开启：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableMethodSecurity</span>   <span class="comment">//开启方法安全校验</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们就可以在我们想要进行权限校验的方法上添加注解了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasRole(&#x27;user&#x27;)&quot;)</span>  <span class="comment">//直接使用hasRole方法判断是否包含某个角色</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过添加<code>@PreAuthorize</code>注解，在执行之前判断判断权限，如果没有对应的权限或是对应的角色，将无法访问页面。</p>
<p>这里其实是使用的就是我们之前讲解的SpEL表达式，我们可以直接在这里使用权限判断相关的方法，如果有忘记SpEL如何使用的可以回顾我们的Spring6核心篇。所有可以进行权限判断的方法在<code>SecurityExpressionRoot</code>类中有定义，各位小伙伴可以自行前往查看。</p>
<p>同样的还有<code>@PostAuthorize</code>注解，但是它是在方法执行之后再进行拦截：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostAuthorize(&quot;hasRole(&#x27;user&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了Controller以外，只要是由Spring管理的Bean都可以使用注解形式来控制权限，我们可以在任意方法上添加这个注解，只要不具备表达式中指定的访问权限，那么就无法执行方法并且会返回403页面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAnyRole(&#x27;user&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与具有相同功能的还有<code>@Secured</code>但是它不支持SpEL表达式的权限表示形式，并且需要添加”ROLE_”前缀，这里就不做演示了。</p>
<p>我们还可以使用<code>@PreFilter</code>和<code>@PostFilter</code>对集合类型的参数或返回值进行过滤。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreFilter(&quot;filterObject.equals(&#x27;lbwnb&#x27;)&quot;)</span>   <span class="comment">//filterObject代表集合中每个元素，只要满足条件的元素才会留下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(List&lt;String&gt; list)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;成功执行&quot;</span>+list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;lbwnb&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;yyds&quot;</span>);</span><br><span class="line">    service.test(list);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与<code>@PreFilter</code>类似的<code>@PostFilter</code>这里就不做演示了，它用于处理返回值，使用方法是一样的。</p>
<p>当有多个集合时，需要使用<code>filterTarget</code>进行指定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreFilter(value = &quot;filterObject.equals(&#x27;lbwnb&#x27;)&quot;, filterTarget = &quot;list2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(List&lt;String&gt; list, List&lt;String&gt; list2)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;成功执行&quot;</span>+list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，有关Security的基本功能，我们就全部介绍完毕了，在后面的SpringBoot阶段，我们还会继续深入使用此框架，实现更多高级的功能。</p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在开始时，选择了servlet依赖后自动生成 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!-- 如果日志有报错无法显示Mvc相关的日志，添加以下依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-jdk14<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!-- Spring核心框架的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- SpringMvc相关依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- SpringSecurity相关依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!-- 数据库有关依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- Mybatis专门为Spring编写的支持框架 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- Spring的JDBC支持框架 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!-- lombok依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!-- Thymeleaf依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring6<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用@Resource注解需要导入的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!-- 自动集成JUnit需要导入的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库设计范式</title>
    <url>/2023/09/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="数据库设计范式"><a href="#数据库设计范式" class="headerlink" title="数据库设计范式"></a>数据库设计范式</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>参考文章：</p>
<p><a href="https://juejin.cn/post/6844904183611523086">https://juejin.cn/post/6844904183611523086</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数据库范式，又称为<strong>数据库规范化</strong>，用于保证数据库之间的关系合理，减少数据库中的数据冗余，消除操作带来的异常，增进数据的一致性。</p>
<p>用一句话来概括就是：数据库设计范式可以帮助我们减少数据的冗余，同时提高数据的完整性。</p>
<p><strong>我们设计数据库的时候需要满足一些数据库范式，通常为：1NF、2NF、3NF、BCNF</strong></p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>首先，我们定义一张表，并添加一些数据，这个表 1 （选课表）有助于我们理解这些概念：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172944729191ddd4~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p>
<h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><p>关系中的某个或者某几个属性的集合，用于唯一地标识每一条数据（这里的每一条数据就是数据库中的每一条记录）。</p>
<h4 id="候选码"><a href="#候选码" class="headerlink" title="候选码"></a>候选码</h4><p>在一个表的关系中，可以存在多个关系集合用于唯一确定一条记录，这些多个集合就称为<strong>候选码</strong>，也称为候选键。候选码可以存在多个，每一个候选码都可以唯一地确定一条记录。</p>
<p>我们换一种更加严谨的说法：假设 K 为某个表中的一个属性或者属性组，如果除去 K 之外的所有属性都<strong>完全函数依赖</strong>（稍后会介绍）于 K，那么我们就称 K 为候选码。</p>
<p>根据上表的示例我们可以得出一个候选码：</p>
<ul>
<li>（学号，课名）</li>
</ul>
<h4 id="主码"><a href="#主码" class="headerlink" title="主码"></a>主码</h4><p>通常我们会从候选码中选择一个码作为<strong>主码</strong>，也就是我们通常所说的主键。</p>
<h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>在数学上的解释是：<img src="https://juejin.cn/equation?tex=y%20=%20f(x)" alt="y = f(x)">，输入一个 X，可以得到一个确定的 Y。有点类似于纯函数。</p>
<p>对应到一个表上就是，在一个属性（属性组）X 确定的情况下，必定能够确定属性 Y 的值，这就能够称作 Y 函数依赖于 X，写作 X -&gt; Y 。</p>
<p>记作：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/17294478f4b78bd9~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p>
<p>比如下面这些关系都<strong>存在</strong>函数依赖：</p>
<ul>
<li>（学号）-&gt;（姓名）</li>
<li>（学号，课名）-&gt;（分数）</li>
<li>（系名）-&gt;（系主任）</li>
</ul>
<p>但是，下面这些关系就<strong>不存在</strong>函数依赖：</p>
<ul>
<li>（姓名）-&gt;（学号），因为有可能会出现重名的情况，所以只依靠姓名是无法确定学号的。</li>
<li>（学号）-&gt;（分数），因为一个学号有多个科目，每一个科目都存在一个分数，不能只靠学号来确定分数。</li>
<li>……</li>
</ul>
<h4 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h4><p>在一个表中，如果存在 X -&gt; Y，那么对于 X 下的任何一个真子集（X’），X’ -&gt; Y都不成立，那么我们就说 Y 对于 X 完成函数依赖。</p>
<p>记作：X -&gt;F  Y</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729447d6caba0f9~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p>
<p>通俗的说，必须通过码中的所有属性才可以唯一确定一个值。比如：</p>
<ul>
<li>（学号）-&gt;F（姓名）</li>
<li>（学号，课名）-&gt;F（分数）</li>
</ul>
<h4 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h4><p>在一个表中，如果存在 X -&gt; Y，但是 Y 并不完成依赖于 X。存在一些 X 的子集 X’，X‘ -&gt; Y成立，那么我们就说 Y 对于X 部分函数依赖。</p>
<p>记作：X -&gt;P Y</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/17294481094df130~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p>
<p>通俗的说，只需要码中的部分属性即可唯一确定一个值。比如：</p>
<ul>
<li>（学号，课名）-&gt; （姓名），只需要根据码中的学号即可唯一确定姓名。</li>
</ul>
<p><strong>它跟完全函数依赖的区别在于，完全函数依赖必须要通过码中的所有属性才可以唯一确定一个值，而部分函数依赖只需要码中的部分属性即可。</strong></p>
<h4 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h4><p>如果 Z 函数依赖于 Y，Y 函数依赖于 X，并且 X 不函数依赖于 Y，那么我们就说 Z 传递函数依赖于 X。</p>
<p>记作：X -&gt;T Z</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/17294484b7bd7b14~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p>
<p>通俗的说，通过码可以唯一确定一个属性，然后通过该属性可以唯一确定另一个属性，所以就演变为了可以通过码唯一确定一个无函数依赖的属性。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性就是我们在表中定义的每一个列</p>
<h4 id="主属性"><a href="#主属性" class="headerlink" title="主属性"></a>主属性</h4><p>在码中的所有属性（每一列）都称为主属性</p>
<h4 id="非主属性"><a href="#非主属性" class="headerlink" title="非主属性"></a>非主属性</h4><p>除了主属性之外的其他属性，都称为非主属性。</p>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>有了上面的那些概念，我们现在就可以正式来谈谈范式了。数据库设计范式有很多种：1NF、2NF、3NF、BCNF、4NF、5NF、6NF 等等。</p>
<p>但是并不是说遵循的范式等级越高越好，范式过高虽然具有对数据关系有更好的约束性，但是也会导致表之间的关系更加繁琐，从而导致每次操作的表会变多，数据库性能下降。</p>
<p>通常在设计中，最高也就遵循到 BCNF，普遍还是 3NF。</p>
<h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>1NF，又称第一范式。只要每一列中的数据都不可再分即可满足该范式，关系型数据库建立的表默认都支持该范式。但是一些开发人员会反其道而行，比如下面这种表 2 设计：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/17294487b37ab282~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p>
<p>这种设计是违反了第一范式的设计，因为这里的地址和亲属是可以继续划分的，而第一范式强调的就是属性不可再分。</p>
<p><strong>结论：属性不可再分。</strong></p>
<h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>1NF 只是设计数据库最基本的要求，但是数据会存在大量的冗余，并存在删除异常、插入异常、更新异常。我们把目光看到我们一开始的表 1 中。</p>
<p>在该表中，存在下面几个问题：</p>
<ul>
<li>每一名学生的学号、姓名、系名、系主任都是重复的数据，这都是冗余数据。</li>
<li>假如学校新建了一个系，但是这个系还未招收学生。那么就无法将系名与系主任关联起来，这就是插入异常。</li>
<li>假如系里的学生都毕业了，并且还未招收其他学生，那么该表中的学生删除之后，也同时将系的信息也删除了，这就会表现为不存在这个系，这就是删除异常。</li>
<li>假如电子系要更换系主任了，那么就要将这个表里每一条有关电子系的系主任都进行更新，这就是更新异常。</li>
</ul>
<p>为了解决上述的问题，我们就要引入更高一级的第二范式（2NF）。</p>
<p>2NF 对 1NF 做了哪些改进呢？</p>
<p><strong>2NF 在 1NF 的基础上，消除了非主属性对码的部分函数依赖</strong>  。我们已经知道<strong>码</strong>是可以唯一确定一条记录的属性集合，<strong>非主属性</strong>是除了码中属性之外的其他属性。</p>
<p>我们来分析表 1：</p>
<p>码：（学号、课名）</p>
<p>主属性：（学号、课名）</p>
<p>非主属性：（姓名、系名、系主任、班级、课名、分数）</p>
<p>我们回过头来分析一下表 1 是否符合 2NF，<strong>要符合 2NF 那么就不能存在非主属性对码的部分函数依赖</strong>。判断是否符合 2NF 可以通过以下步骤：</p>
<ol>
<li>找出表中所有的<strong>码（候选码）</strong>。</li>
<li>根据第一步得出的码找出所有的<strong>主属性</strong>。</li>
<li>除了主属性之外的其他属性，就都是<strong>非主属性</strong>。</li>
<li>判断是否存在非主属性<strong>部分函数依赖</strong>于码。</li>
</ol>
<p>我们根据上面的步骤来验证表 1 是否符合 2NF。</p>
<h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>找出表中所有的候选码。</p>
<p>如何找候选码呢？只有使用排列组合来寻找了。</p>
<ul>
<li>首先查看每一个属性，如果该属性确定，是否可以唯一地确定一条记录。</li>
<li>查看每两个属性组合的属性组，如果该属性组确定，是否可以唯一地确定一条记录。</li>
<li>……</li>
</ul>
<p>以此类推，一直到所有属性组成的属性组为止。这看起来相当的繁琐，但是我们一般都可以通过直接观察得到，或者我们设计的时候就可以确定我们拥有的候选码有哪些。并不需要一个个的的自己组合判断。</p>
<p>如果一定要自己组合判断，我们可以根据候选码具有完全函数依赖的特性，可以推测出：如果 A 是码，那么任何与 A 组合的属性组都不符合码的要求，比如：（A，B）（A，B，C）等等。</p>
<p>我们根据上面的解释，我们在这一步中可以得出表 1 中的候选码：<strong>（学号、课名）</strong></p>
<h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>根据码找出所有的主属性。</p>
<p>这一步相对简单，第一步中找到的码只有（学号、课名）。所以主属性只有（学号、课名）。</p>
<h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>除去主属性之外的其他属性，都是非主属性。</p>
<p>所以非主属性有（姓名、系名、系主任、班级、分数）。</p>
<h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>判断第三步找出的非主属性是否部分函数依赖于第一步找出的码。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729449451055760~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p>
<p>我们根据上面的这张图，可以看出，有多个非主属性部分函数依赖于码。</p>
<ul>
<li>对于（学号，课名）-&gt;（姓名），存在（学号）-&gt;（姓名），存在非主属性<strong>姓名</strong>部分函数依赖于码。</li>
<li>对于（学号，课名）-&gt;（系名），存在（学号）-&gt;（系名），存在非主属性<strong>系名</strong>部分函数依赖于码。</li>
<li>……</li>
</ul>
<p>所以对于表 1 来说，它不符合 2NF 的要求，它只能达到 1NF 的要求。</p>
<p>在这种情况下，我们应该如何改进才能让表 1 符合 2NF 的要求呢？当然是将表进行拆分，消除这些部分函数依赖，有个比较正式的名称：<strong>模式分解</strong>。</p>
<p>我们可以将选课表进行拆分，将它拆分为两张表：选课表、学生表。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172944971f50d919~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/17294498d5c7549b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p>
<p>我们现在再来看选课表。此时它只有一个码：<strong>（学号，课名）</strong>，非主属性只有一个：<strong>分数</strong>。它们之间已经不是部分函数依赖的关系了，而是完全函数依赖的关系。选课表中已经不存在部分函数依赖，所以此时选课表符合第二范式（2NF）。</p>
<p>我们现在来看看学生表是否符合 2NF。</p>
<p>按照上面的四个步骤：</p>
<ol>
<li>码：（学号）</li>
<li>主属性：学号</li>
<li>非主属性：（姓名，系名，系主任，班级）</li>
<li>因为码中只有一个属性，所以不可能存在部分函数依赖。</li>
</ol>
<p>所以学生表也是符合 2NF 的。</p>
<p><strong>结论：在 1NF 的基础上，通过对表的拆分，消除表中非主属性对码的部分函数依赖。</strong></p>
<h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>我们通过 2NF 已经将表 1 拆分成了两个表：选课表、学生表。但是依然存在着一些问题，比如：</p>
<ul>
<li>当删除学生表中的学生之后，会将系的信息也一起删除。如果将学生表的内容全部都删除，那么系信息也全部都不存在了。</li>
<li>当创建一个新的系，但是还没有该系的学生，也无法添加该系的信息。</li>
</ul>
<p>我们通过上一节已经知道选课表和学生表都是符合 2NF 的，但是学生表中依然存在着一些问题。所以，符合 2NF 的表不一定就能满足我们的要求。此时，我们就要用到 3NF。</p>
<p>只要表中存在非主属性对码的传递函数依赖，则不满足 3NF 的要求。所以对于 3NF 来说，就是在 2NF 的基础上，消除非主属性对码的<strong>传递函数依赖</strong>。</p>
<p>我们来分析以下学生表中的函数依赖关系：</p>
<ol>
<li>找出学生表中的码：（学号）</li>
<li>主属性：学号</li>
<li>非主属性：（学号，系名，系主任，分数）</li>
<li>学号与系主任之间存在传递函数依赖</li>
</ol>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729449b85a01b3d~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p>
<p>通过图可以看到，只要我们确定了学号，我们就可以确定系名，确定了系名，我们就可以确定系主任。因此在学号确定的情况下，我们也可以确定系主任。这就是传递函数依赖。</p>
<p>消除传递函数依赖的方法也是通过拆分表来完成，我们将学生表拆分为两张表：学生表、系表</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729449d283b32e0~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/1729449e5f705664~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p>
<p>在拆分之后，学生表就消除了函数传递依赖，所以此时学生表符合 3NF，系表也符合 3NF。</p>
<p><strong>结论：在 2NF 的基础上，消除表中非主属性对码的传递函数依赖。</strong></p>
<p>我们为了使表 1 符合设计范式，将表 1 拆分成了三个表。从而解决了数据的冗余、删除异常、添加异常、更新异常的问题。</p>
<p>但是这也带来了一个新的问题，我们查询数据的时候不能只通过查询一张表来得出结果，而要通过连接三张表一起查询才行，这也会影响数据库的查询性能。</p>
<h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p>我们已经了解 1NF、2NF、3NF，也通过这三个范式解决了问题，那么为什么还会有 BCNF 呢？这个范式又解决了什么问题？我们带着这两个问题一起来看看 BCNF。</p>
<p>首先，要说明的是，上面经过拆分之后的三张表都是符合 BCNF的。看到这里，小朋友，你是否有很多问号？</p>
<p>别急，让我们先看一下 BCNF 的定义：不存在<strong>主属性</strong>对于码的部分函数依赖和传递函数依赖，那么即符合 BCNF。</p>
<p>注意：这里说的是<strong>主属性</strong>，而前面的 2NF、3NF都是<strong>非主属性</strong>对码的部分函数依赖和传递函数依赖。要注意这个区别，很重要。</p>
<p>我们可以看到上面三个表因为都只有一个码，所以不存在主属性对码的部分函数依赖和传递函数依赖。不符合BCNF 需要存在两个码以上。</p>
<p>比如下面这种情况：</p>
<ul>
<li>某公司有若干个仓库</li>
<li>每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作</li>
<li>一个仓库中可以存放多种物品，一个物品也可以存放在不同的仓库。每种物品在每个仓库中都有对应的数量。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172944a040d954ce~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p>
<p>我们来分析一下这个表：</p>
<ul>
<li>码：（仓库名，物品名），（管理员，物品名）</li>
<li>主属性：仓库名、物品名、管理员</li>
<li>非主属性：数量</li>
</ul>
<p>非主属性只有“数量”，而非主属性对于两个码都不存在部分函数依赖和传递函数依赖，所以这个表是符合 3NF的。但是这个表却是不符合 BCNF 的。</p>
<p>因为存在主属性对码的部分函数依赖：</p>
<ul>
<li>（仓库名，物品名）-&gt; 管理员，只要确定仓库名，即可确定管理员，所以管理员部分函数依赖于仓库名。</li>
<li>（管理员，物品名）-&gt; 仓库名，同上。</li>
</ul>
<p>那么我们要将该表进行拆分才能让物品表符合 BCNF。将该表拆分为两个表：仓库表、物品表。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172944a1c10693d6~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172944a4388123f5~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="img"></p>
<p>我们可以来看看拆分之后解决了什么问题：</p>
<ul>
<li>如果仓库换管理员，不需要将物品表中的每一个该仓库的数据都进行修改。</li>
<li>如果物品都被删除，仓库依然存在，仓库管理员也依然于仓库存在关系</li>
<li>如果新增一个仓库，但是还没有物品，可以直接在仓库表添加一条记录即可，数据库不会出错。</li>
</ul>
<p>所以消除了主属性对码的部分函数依赖和传递函数依赖之后，数据库中的操作的异常就不再出现了。</p>
<p><strong>结论：在 3NF 的基础上，消除主属性对码的部分函数依赖和传递函数依赖。</strong></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2023/10/07/SpringBoot/</url>
    <content><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p>Spring Boot让您可以轻松地创建独立的、生产级别的Spring应用程序，并“直接运行”这些应用程序。SpringBoot为大量的第三方库添加了支持，能够做到开箱即用，简化大量繁琐配置，用最少的配置快速构建你想要的项目。在2023年，SpringBoot迎来了它的第三个大版本，随着SpringBoot 3的正式发布，整个生态也迎来了一次重大革新。</p>
<p>目前的最新版本以及对应的维护情况：</p>
<p><img src="https://s2.loli.net/2023/07/10/qnjY5MdRrOemFaQ.png" alt="image-20230710174659973"></p>
<p>可以看到，曾经的SpringBoot 2.5版本将会在2023年8月底终止商业支持，届时将不会再对这类旧版本进行任何维护，因此，将我们的老版本SpringBoot项目进行升级已经迫在眉睫，目前最强的3.1正式版会维护到2025年中旬。</p>
<p>在3.X之后的变化相比2.X可以说是相当大，尤其是其生态下的SpringSecurity框架，旧版本项目在升级之后API已经完全发生改变；以及内置Tomcat服务器的升级，Servlet也升级到5以上，从<code>javax</code>全新升级到<code>jakarta</code>新包名；包括在3.X得到的大量新特性，如支持GraalVM打包本地镜像运行等；并且Java版本也强制要求为17版本。迁移到新版本不仅可以享受到免费维护支持，也可以感受Java17带来的全新体验。</p>
<p>介绍了这么多，我们首先还是来看看SpringBoot功能有哪些：</p>
<ul>
<li>能够创建独立的Spring应用程序</li>
<li>内嵌Tomcat、Jetty或Undertow服务器（无需单独部署WAR包，打包成Jar本身就是一个可以运行的应用程序）</li>
<li>提供一站式的“starter”依赖项，以简化Maven配置（需要整合什么框架，直接导对应框架的starter依赖）</li>
<li>尽可能自动配置Spring和第三方库（除非特殊情况，否则几乎不需要进行任何配置）</li>
<li>提供生产环境下相关功能，如指标、运行状况检查和外部化配置</li>
<li>没有任何代码生成，也不需要任何XML配置（XML是什么，好吃吗）</li>
</ul>
<p>SpringBoot是现在最主流的开发框架，国内的公司基本都在使用，也是我们出去找工作一定要会的框架，它提供了一站式的开发体验，能够大幅度提高我们的开发效率。</p>
<p><img src="https://s2.loli.net/2022/11/22/hDGo7m9uBlgVn5A.png" alt="image-20221122175719997"></p>
<p>在SSM阶段，当我们需要搭建一个基于Spring全家桶的Web应用程序时，我们不得不做大量的依赖导入和框架整合相关的Bean定义，光是整合框架就花费了我们大量的时间，但是实际上我们发现，整合框架其实基本都是一些固定流程，我们每创建一个新的Web应用程序，基本都会使用同样的方式去整合框架，我们完全可以将一些重复的配置作为约定，只要框架遵守这个约定，为我们提供默认的配置就好，这样就不用我们再去配置了，约定优于配置！</p>
<p>而SpringBoot正是将这些过程大幅度进行了简化，它可以自动进行配置，我们只需要导入对应的启动器（starter）依赖即可。</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>要感受SpringBoot带来的快速开发体验，我们就从创建一个项目开始。</p>
<h3 id="极速创建项目"><a href="#极速创建项目" class="headerlink" title="极速创建项目"></a>极速创建项目</h3><p>在过去，我们创建一个SSM项目，需要先导入各种依赖，进行大量的配置，而现在，有了SpringBoot，我们可以享受超快的项目创建体验，只需要前往官网进行少量配置就能快速为你生成一个SpringBoot项目模版：<a href="https://start.spring.io/">https://start.spring.io/</a></p>
<p><img src="https://s2.loli.net/2023/07/11/V6lBrtp5QvbPyKk.png" alt="image-20230711124041648"></p>
<p>不过，为了方便，IDEA已经将这个工具集成到内部了，我们可以直接在IDEA中进行创建，效果是一样的，首先在新建项目阶段，选择 Spring Initializr 类型：</p>
<p><img src="https://s2.loli.net/2023/07/11/Ol3Tqh21V8pjyLW.png" alt="image-20230711124216094"></p>
<p>接着我们就可以配置项目的语言，并且选择项目需要使用的模块，这里我们简单选择两个依赖：</p>
<p><img src="https://s2.loli.net/2023/07/11/rzJblifUQomV4Ed.png" alt="image-20230711124332819"></p>
<p>如果一开始不清楚自己需要哪些模块，我们也可以后续自己手动添加对应模块的starter依赖，使用非常简单。</p>
<p>项目自动生成之后，可以看到Spring相关的依赖已经全部自动导入：</p>
<p><img src="https://s2.loli.net/2023/07/11/2P9wIJGdYluk8Hz.png" alt="image-20230711124949017"></p>
<p>并且也自动为我们创建了一个主类用于运行我们的SpringBoot项目：</p>
<p><img src="https://s2.loli.net/2023/07/11/ZSAbwpurQKYDN6O.png" alt="image-20230711125025254"></p>
<p>我们可以一键启动我们的SpringBoot项目：</p>
<p><img src="https://s2.loli.net/2023/07/11/1YvbfCkoIWEBg4X.png" alt="image-20230711125447493"></p>
<p>只不过由于我们没有添加任何有用的模块，也没有编写什么操作，因此启动之后项目就直接停止了。</p>
<h3 id="常用模块快速整合"><a href="#常用模块快速整合" class="headerlink" title="常用模块快速整合"></a>常用模块快速整合</h3><p>前面我们说了，SpringBoot的核心思想就是约定大于配置，能在一开始默认的就直接默认，不用我们自己来进行配置，我们只需要配置某些特殊的部分即可，这一部分我们就来详细体验一下。</p>
<p>我们来尝试将我们之前使用过的模块进行一下快速整合，可以看到在一开始的时候，我们没有勾选其他的依赖，因此这里只导入了最基本的<code>spring-boot-starter</code>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>所有的SpringBoot依赖都是以starter的形式命名的，之后我们需要导入其他模块也是导入<code>spring-boot-starter-xxxx</code>这种名称格式的依赖。</p>
<p>首先我们还是从SpringMvc相关依赖开始。SpringBoot为我们提供了包含内置Tomcat服务器的Web模块，我们只需要导入依赖就能直接运行服务器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们不需要进行任何配置，直接点击启动：</p>
<p><img src="https://s2.loli.net/2023/07/11/Hz1dVPqpe3vJsuR.png" alt="image-20230711133113516"></p>
<p>它真的做到了开箱即用，我们现在可以直接访问这个网站：</p>
<p><img src="https://s2.loli.net/2023/07/11/7GELtUH3Kj5ld1w.png" alt="image-20230711133224425"></p>
<p>可以看到成功响应了404页面，相比之前的大量配置，可以说方便了很多，我们到目前为止仅仅是导入了一个依赖，就可以做到直接启动我们的Web服务器并正常访问。</p>
<p>SpringBoot支持自动包扫描，我们不需要编写任何配置，直接在任意路径（但是不能跑到主类所在包外面去了）下创建的组件（如Controller、Service、Component、Configuration等）都可以生效，比如我们这里创建一个测试的Controller试试看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启之后，可以看到直接就能访问到，而这期间我们只是创建了对应的Controller却没有进行任何配置，这真的太方便了：</p>
<p><img src="https://s2.loli.net/2023/07/13/2jrxoswhNpASPil.png" alt="image-20230713225914578"></p>
<p>包括一个对象现在也可以直接以JSON形式返回给客户端，无需任何配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> sid;</span><br><span class="line">    String name;</span><br><span class="line">    String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Student <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student.setName(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    student.setSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    student.setSid(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![image-20230715171140388](&#x2F;Users&#x2F;nagocoler&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230715171140388.png)</p>
<p>最后浏览器能够直接得到<code>application/json</code>的响应数据，就是这么方便，这都得归功于SpringBoot对应的start帮助我们自动将处理JSON数据的Converter进行了配置，我们不需要再单独去配置Converter了。不过SpringBoot官方默认使用的是<code>Jackson</code>和<code>Gson</code> 的HttpMessageConverter来进行配置，不是我们之前教程中使用的FastJSON框架。</p>
<p>我们最后来看看这个Start包含了哪些依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>里面包含了以下内容：</p>
<ul>
<li>spring-boot-starter  基础依赖starter</li>
<li>spring-boot-starter-json  配置JSON转换的starter</li>
<li>spring-boot-starter-tomcat   内置Tomcat服务器</li>
<li>spring-web、spring-webmvc    不用多说了吧，之前已经讲过了</li>
</ul>
<p>如果需要像之前一样添加WebMvc的配置类，方法是一样的，直接创建即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只需要添加Configuration用于注册配置类，不需要其他任何注解，已经自动配置好了</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">HandlerInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> HandlerInterceptor.<span class="built_in">super</span>.preHandle(request, response, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在SSM阶段编写的大量配置，到现在已经彻底不需要了。</p>
<p>同样的，我们来看看SpringSecurity框架如何进行整合，也是非常简单，我们只需要直接导入即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>导入完成后，再次访问网站，就可以看到熟悉的登录界面了：</p>
<p><img src="https://s2.loli.net/2023/07/15/1dJaDbqlyUgnFBt.png" alt="image-20230715182059681"></p>
<p>我们没有进行任何配置，而是对应的Starter帮助我们完成了默认的配置，并且在启动时，就已经帮助我们配置了一个随机密码的用户可以直接登录使用：</p>
<p><img src="https://s2.loli.net/2023/07/15/a4QbGBtMdZP6qec.png" alt="image-20230715182323772"></p>
<p>密码直接展示在启动日志中，而默认用户名称为<code>user</code>我们可以直接登录：</p>
<p><img src="https://s2.loli.net/2023/07/15/StwKT5JLdG3Vacv.png" alt="image-20230715182448770"></p>
<p>同样没有进行任何配置，我们只需要添加对应的starter就能做到开箱即用，并且内置一套默认配置，自动帮助我们创建一个测试用户，方便我们快速搭建项目，同样的，如果要进行额外配置，我们只需要直接添加配置类即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//依然只需要Configuration注解即可，不需要其他配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//配置方式跟之前SSM阶段是一样的</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> http</span><br><span class="line">                .authorizeHttpRequests(auth -&gt; &#123;</span><br><span class="line">                    auth.anyRequest().authenticated();</span><br><span class="line">                &#125;)</span><br><span class="line">                .formLogin(conf -&gt; &#123;</span><br><span class="line">                    conf.loginPage(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">                    conf.loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>);</span><br><span class="line">                    conf.defaultSuccessUrl(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                    conf.permitAll();</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，我们也可以快速整合之前使用的模版引擎，比如Thymeleaf框架，直接上对应的Starter即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在默认情况下，我们需要在<code>resources</code>目录下创建两个目录：</p>
<p><img src="https://s2.loli.net/2023/07/15/HfGt61A7OqVDesz.png" alt="image-20230715225833930"></p>
<p>这两个目录是默认配置下需要的，名字必须是这个：</p>
<ul>
<li><code>templates</code> - 所有模版文件都存放在这里</li>
<li><code>static</code> - 所有静态资源都存放在这里</li>
</ul>
<p>我们只需要按照上面的样子放入我们之前的前端模版，就可以正常使用模版引擎了，同样不需要进入任何的配置，当然，如果各位小伙伴觉得不方便，我们后续也可以进行修改。</p>
<p>我们不需要在controller中写任何内容，它默认会将index.html作为首页文件，我们直接访问服务器地址就能展示首页了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">		<span class="comment">//什么都不用写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/07/15/thnN29vz4fuYRFW.png" alt="image-20230715230152860"></p>
<p>这都是得益于约定大于配置的思想，开箱即用的感觉就是这么舒服，不过肯定有小伙伴好奇那现在要怎么才能像之前一样自己写呢，这个肯定还是跟之前一样的呗，该怎么写就怎么写。</p>
<p>我们最后再来看看Mybatis如何进行整合，同样只需要一个starter即可，这里顺便把MySQL的驱动加上：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意这里的<code>mybatis-spring-boot-starter</code>版本需要我们自己指定，因为它没有被父工程默认管理。</p>
<p><img src="https://s2.loli.net/2023/07/15/yWAUnZufkxH8CFp.png" alt="image-20230715231142842"></p>
<p>启动服务器时，我们发现这里出现了问题，导致无法启动。这是因为我们没有配置数据源导致的，虽然SpringBoot采用约定大于配置的思想，但是数据库信息只有我们自己清楚，而且变化多样，根本没有办法提前完成约定，所以说这里我们还是需要再配置文件中编写，至于如何编写配置文件我们会在下一节中进行讲解。</p>
<h3 id="自定义运行器"><a href="#自定义运行器" class="headerlink" title="自定义运行器"></a>自定义运行器</h3><p>在项目中，可能会遇到这样一个问题：我们需要在项目启动完成之后，紧接着执行一段代码。</p>
<p>我们可以编写自定义的ApplicationRunner来解决，它会在项目启动完成后执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRunner</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然也可以使用CommandLineRunner，它也支持使用@Order或是实现Ordered接口来支持优先级执行。</p>
<p>这个功能比较简单，不多做介绍了。</p>
<h3 id="配置文件介绍"><a href="#配置文件介绍" class="headerlink" title="配置文件介绍"></a>配置文件介绍</h3><p>前面我们已经体验了SpringBoot带来的快捷开发体验，不过我们发现有些东西还是需要我们自己来编写配置才可以，不然SpringBoot项目无法正常启动，我们来看看如何编写配置。我们可以直接在<code>application.properties</code>中进行配置编写，它是整个SpringBoot的配置文件，比如要修改服务器的默认端口：</p>
<p><img src="https://s2.loli.net/2023/07/15/E3nsZG7DcaSzOBY.png" alt="image-20230715232124133"></p>
<p>这些配置其实都是各种Starter提供的，部分配置在Starter中具有默认值，我们即使不配置也会使用默认值，比如这里的8080就是我们服务器的默认端口，我们也可以手动修改它，来变成我们需要的。</p>
<p>除了配置已经存在的选项，我们也可以添加自定义的配置，来方便我们程序中使用，比如我们这里创建一个测试数据：</p>
<p><img src="https://s2.loli.net/2023/07/15/HJWz7PIl6Sgk1nx.png" alt="image-20230715234130924"></p>
<p>我们可以直接在程序中通过<code>@Value</code>来访问到（跟我们之前Spring基础篇讲的是一样的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;test.data&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> data;   <span class="comment">//直接从配置中去取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件除了使用<code>properties</code>格式以外，还有一种叫做<code>yaml</code>格式，它的语法如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">一级目录:</span></span><br><span class="line">    <span class="string">二级目录:</span></span><br><span class="line">      <span class="string">三级目录1:</span> <span class="string">值</span></span><br><span class="line">      <span class="string">三级目录2:</span> <span class="string">值</span></span><br><span class="line">      <span class="string">三级目录List:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">元素1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">元素2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">元素3</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，每一级目录都是通过缩进（不能使用Tab，只能使用空格）区分，并且键和值之间需要添加冒号+空格来表示。</p>
<p>SpringBoot也支持这种格式的配置文件，我们可以将<code>application.properties</code>修改为<code>application.yml</code>或是<code>application.yaml</code>来使用YAML语法编写配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>现在我们来尝试为之前的数据源进行一下配置，这样才能正常启动我们的服务器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:3306/test</span></span><br><span class="line">    username: root</span><br><span class="line">    password: <span class="number">123456</span></span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>

<p>配置完成后，我们就可以正常启动服务器了。</p>
<p>这里我们接续来测试一下MyBatis的配置，想要在SpringBoot中使用Mybatis也很简单，不需要进行任何配置，我们直接编写Mapper即可，这里我们随便创建一个表试试看：</p>
<p><img src="https://s2.loli.net/2023/07/16/ygRp98mDKafXkw1.png" alt="image-20230716000431492"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    String email;</span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，在SpringBoot整合之后，我们只需要直接在配置类上添加<code>@MapperScan</code>注解即可，跟我们之前的使用方法是一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>不过，为了方便，我们也可以直接为需要注册为Mapper的接口添加<code>@Mapper</code>注解，来表示这个接口作为Mapper使用：</p>
<p><img src="https://s2.loli.net/2023/07/16/lTrXepw1c38IdSv.png" alt="image-20230716000755756"></p>
<p>这样，即使不配置MapperScan也能直接注册为Mapper正常使用，是不是感觉特别方便？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mapper.findUserById(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问接口测试一下：</p>
<p><img src="https://s2.loli.net/2023/07/16/PSfpylWGCs3bzZj.png" alt="image-20230716001311316"></p>
<p>最后，我们再来介绍一下常见的配置项，比如SpringSecurity和SpringBootMvc配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="comment">#  Spring Mvc相关配置</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/static/**</span>   <span class="comment">#静态资源解析地址</span></span><br><span class="line">  <span class="comment"># Spring Security 相关配置</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">filter:</span></span><br><span class="line">      <span class="attr">order:</span> <span class="number">-100</span> <span class="comment">#Spring Security 过滤器优先级</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&#x27;admin&#x27;</span>   <span class="comment">#默认登录用户名</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&#x27;123456&#x27;</span>   <span class="comment">#默认登录密码</span></span><br><span class="line">      <span class="attr">roles:</span>    <span class="comment">#默认用户的角色</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">admin</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">user</span></span><br></pre></td></tr></table></figure>

<p>更多的配置我们可以在后续的学习中继续认识，这些配置其实都是由Starter提供的，确实极大程度简化了我们对于框架的使用。</p>
<h3 id="轻松打包运行"><a href="#轻松打包运行" class="headerlink" title="轻松打包运行"></a>轻松打包运行</h3><p>前面我们介绍了一个SpringBoot如何快捷整合其他框架以及进行配置编写，我们接着来看如何打包我们的SpringBoot项目使其可以正常运行，SpringBoot提供了一个非常便捷的打包插件，能够直接将我们的项目打包成一个jar包，然后使用java命令直接运行，我们直接点击Maven中的：</p>
<p><img src="https://s2.loli.net/2023/07/16/oI6YjqUurZznw3C.png" alt="image-20230716155322915"></p>
<p>点击之后项目会自动打包构建：</p>
<p><img src="https://s2.loli.net/2023/07/16/2dToslkFHXxujOa.png" alt="image-20230716155412252"></p>
<p>打包完成之后，会在target目录下出现一个打包好的jar文件：</p>
<p><img src="https://s2.loli.net/2023/07/16/itQxlHTL5hsjIme.png" alt="image-20230716155622849"></p>
<p>我们可以直接在命令行中运行这个程序，在CMD中进入到target目录，然后输入：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -jar demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>这样就可以直接运行了：</p>
<p><img src="https://s2.loli.net/2023/07/16/7bjyil3RgfuNLsZ.png" alt="image-20230716155834628"></p>
<p>现在，我们的SpringBoot项目就可以快速部署到任何计算机了，只要能够安装JRE环境，都可以通过命令一键运行。</p>
<p>当然，可能也会有小伙伴好奇，怎么才能像之前一样在我们的Tomcat服务器中运行呢？我们也可以将其打包为War包的形式部署到我们自己环境中的Tomcat服务器或是其他任何支持Servlet的服务器中，但是这种做法相对比较复杂，不太推荐采用这种方式进行项目部署，不过我们这里还是介绍一下。</p>
<p>首先我们需要排除掉<code>spring-boot-starter-web</code>中自带的Tomcat服务器依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后自行添加Servlet依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后将打包方式修改为war包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着我们需要修改主类，将其继承SpringBoot需要的Initializer（又回到SSM阶段那烦人的配置了，所以说一点不推荐这种部署方式）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> <span class="keyword">extends</span> <span class="title class_">SpringBootServletInitializer</span> &#123;  <span class="comment">//继承专用的初始化器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//重写configure方法，完成启动类配置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> SpringApplicationBuilder <span class="title function_">configure</span><span class="params">(SpringApplicationBuilder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.sources(DemoApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们再次运行Maven 的package指令就可以打包为war包了：</p>
<p><img src="https://s2.loli.net/2023/07/16/eycOMVRfZHmLnWX.png" alt="image-20230716161834726"></p>
<p>我们可以直接将其部署到Tomcat服务器中（如何部署已经在JavaWeb篇介绍过了）</p>
<p><img src="https://s2.loli.net/2023/07/16/CiNpxywXOso32kH.png" alt="image-20230716161921180"></p>
<p>接着启动服务器就能正常访问了：</p>
<p><img src="https://s2.loli.net/2023/07/16/3hp6guwVt2aGKlQ.png" alt="image-20230716162008831"></p>
<p><img src="https://s2.loli.net/2023/07/16/VDiRhqgNam8cleI.png" alt="image-20230716162030102"></p>
<p>如果各位小伙伴需要在IDEA中进行调试运行，我们需要像之前一样配置一个Tomcat运行环境：</p>
<p><img src="https://s2.loli.net/2023/07/16/Fn5kxeECwhuoWBl.png" alt="image-20230716162119751"></p>
<p>这样就可以跟之前一样使用外部Tomcat服务器了：</p>
<p><img src="https://s2.loli.net/2023/07/16/xK8sgwWoAIB61qk.png" alt="image-20230716162156347"></p>
<p>最后，我们需要特别介绍一下新的特性，在SpringBoot3之后，特别对GraalVM进行了支持：</p>
<blockquote>
<p>GraalVM 是一种通用的虚拟机，最初由 Oracle 开发。它支持多种编程语言（例如 Java、JavaScript、Python 等），可以在不同的环境中运行，并提供高性能和低内存消耗。</p>
<p>GraalVM的核心是一个即时编译器，它能够将各种语言的代码直接编译成本地机器码，以获得更高的性能。此外，GraalVM 还提供了一个强大的运行时环境，包括垃圾回收器、即时编译器、线程管理器等，可以提供更好的性能和可扩展性。</p>
<p>GraalVM 的一个重要特性是它的跨语言互操作性。GraalVM 可以使不同语言之间的互操作更加容易。例如，你可以在 Java 代码中直接调用 JavaScript 函数，或者在 JavaScript 代码中直接调用 Java 类。这使得在不同语言之间共享和复用代码变得更加容易。</p>
<p>总的来说，GraalVM 是一个开创性的技术，可以提供出色的性能和灵活性，同时也为多语言开发提供了更好的支持。它是一个非常有潜力的工具，可以用于构建高效的应用程序和解决方案。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/07/16/qJiMVGeDnhf7HYu.png" alt="image-20230716160131837"></p>
<p>简而言之，我们的SpringBoot项目除了打包为传统的Jar包基于JVM运行之外，我们也可以将其直接编译为操作系统原生的程序来进行使用（这样会大幅提升程序的运行效率，但是由于编译为操作系统原生程序，这将无法支持跨平台）</p>
<p>首先我们需要安装GraalVM的环境才可以，这跟安装普通JDK的操作是完全一样的，下载地址：<a href="https://github.com/graalvm/graalvm-ce-builds/releases/tag/jdk-17.0.7">https://github.com/graalvm/graalvm-ce-builds/releases/tag/jdk-17.0.7</a></p>
<p><img src="https://s2.loli.net/2023/07/16/Y8VBnQPL4mHit7N.png" alt="image-20230716162524422"></p>
<p>下载好对应系统架构的GraalVM环境之后，就可以安装部署了，首先我们需要为GraalVM配置环境变量，将GRAALVM_HOME作为环境变量指向你的安装目录的bin目录下，接着我们就可以开始进行打包了（注意，SpringBoot项目必须在创建的时候添加了Native支持才可以，否则无法正常打包）</p>
<p>注意，一定要将<code>GRAALVM_HOME</code>配置到环境变量中，否则会报错：</p>
<p><img src="https://s2.loli.net/2023/07/16/lCjUpPYWhkm6eTq.png" alt="image-20230716163645399"></p>
<p>一切无误后，我们直接在IDEA中或是命令行中输入：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn -Pnative -DskipTests native:compile</span><br></pre></td></tr></table></figure>

<p>接着会自动安装<code>native-image</code>组件，然后进行本地镜像的编译（建议挂梯，不然卡一天都下不动）</p>
<p><img src="https://s2.loli.net/2023/07/16/fxzCEJbmluGn8jy.png" alt="image-20230716164025545"></p>
<p>编译过程中比较消耗资源，建议CPU选择6核及以上，不然速度会很慢，编译完成之后如下图：</p>
<p><img src="https://s2.loli.net/2023/07/16/9JekL4VAB7EOdrf.png" alt="image-20230716164317582"></p>
<p>这样一个系统原生的SpringBoot项目就打包好了，我们可以直接运行这个程序：</p>
<p><img src="https://s2.loli.net/2023/07/16/MTu4GCmsogfaeRO.png" alt="image-20230716165228609"></p>
<p>不过由于Mybatis目前不支持Native-Image，所以只能期待有朝一日这些框架都能够完整支持原生镜像，让我们的程序运行效率更上一层楼。</p>
<p>至此，关于SpringBoot的快速上手教程就全部结束了，其实只要SSM阶段学的扎实，到了Boot阶段之后也是轻轻松松，下一部分我们将隆重介绍一下SpringBoot的日志模块。</p>
<hr>
<h2 id="日志系统介绍"><a href="#日志系统介绍" class="headerlink" title="日志系统介绍"></a>日志系统介绍</h2><p>SpringBoot为我们提供了丰富的日志系统，它几乎是开箱即用的。我们在之前学习SSM时，如果不配置日志，就会报错，但是到了SpringBoot阶段之后似乎这个问题就不见了，日志打印得也非常统一，这是为什么呢？</p>
<h3 id="日志门面和日志实现"><a href="#日志门面和日志实现" class="headerlink" title="日志门面和日志实现"></a>日志门面和日志实现</h3><p>我们首先要区分一下，什么是日志门面（Facade）什么是日志实现，我们之前学习的JUL实际上就是一种日志实现，我们可以直接使用JUL为我们提供的日志框架来规范化打印日志。</p>
<p>而日志门面，如Slf4j，是把不同的日志系统的实现进行了具体的抽象化，只提供了统一的日志使用接口，使用时只需要按照其提供的接口方法进行调用即可，由于它只是一个接口，并不是一个具体的可以直接单独使用的日志框架，所以最终日志的格式、记录级别、输出方式等都要通过接口绑定的具体的日志系统来实现，这些具体的日志系统就有log4j、logback、java.util.logging等，它们才实现了具体的日志系统的功能。</p>
<p>日志门面和日志实现就像JDBC和数据库驱动一样，一个是画大饼的，一个是真的去做饼的。</p>
<p><img src="https://s2.loli.net/2023/03/06/MGg1EHxtuvswV8d.png" alt="img"></p>
<p>但是现在有一个问题就是，不同的框架可能使用了不同的日志框架，如果这个时候出现众多日志框架并存的情况，我们现在希望的是所有的框架一律使用日志门面（Slf4j）进行日志打印，这时该怎么去解决？我们不可能将其他框架依赖的日志框架替换掉，直接更换为Slf4j吧，这样显然不现实。</p>
<p>这时，可以采取类似于偷梁换柱的做法，只保留不同日志框架的接口和类定义等关键信息，而将实现全部定向为Slf4j调用。相当于有着和原有日志框架一样的外壳，对于其他框架来说依然可以使用对应的类进行操作，而具体如何执行，真正的内心已经是Slf4j的了。</p>
<p><img src="https://s2.loli.net/2023/03/06/o1bMPITBcgetVYa.png" alt="img"></p>
<p>所以，SpringBoot为了统一日志框架的使用，做了这些事情：</p>
<ul>
<li>直接将其他依赖以前的日志框架剔除</li>
<li>导入对应日志框架的Slf4j中间包</li>
<li>导入自己官方指定的日志实现，并作为Slf4j的日志实现层</li>
</ul>
<h3 id="打印项目日志信息"><a href="#打印项目日志信息" class="headerlink" title="打印项目日志信息"></a>打印项目日志信息</h3><p>SpringBoot使用的是Slf4j作为日志门面，Logback（<a href="http://logback.qos.ch/">Logback</a> 是log4j 框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J）作为日志实现，对应的依赖为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此依赖已经被包含了，所以我们如果需要打印日志，可以像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(TestController.class);</span><br><span class="line">    logger.info(<span class="string">&quot;用户访问了一次测试数据&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mapper.findUserById(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们使用了Lombok，所以直接一个注解也可以搞定哦：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainController</span> &#123;</span><br><span class="line"></span><br><span class="line">  	<span class="meta">@ResponseBody</span></span><br><span class="line">		<span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    		log.info(<span class="string">&quot;用户访问了一次测试数据&quot;</span>);</span><br><span class="line">    		<span class="keyword">return</span> mapper.findUserById(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">  </span><br><span class="line">  	...</span><br></pre></td></tr></table></figure>

<p>日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，SpringBoot默认只会打印INFO以上级别的信息，效果如下，也是使用同样的格式打印在控制台的：</p>
<p><img src="https://s2.loli.net/2023/07/16/HCZQndu2YPwINoS.png" alt="image-20230716171120646"></p>
<h3 id="配置Logback日志"><a href="#配置Logback日志" class="headerlink" title="配置Logback日志"></a>配置Logback日志</h3><p>Logback官网：<a href="https://logback.qos.ch/">https://logback.qos.ch</a></p>
<p>和JUL一样，Logback也能实现定制化，我们可以编写对应的配置文件，SpringBoot推荐将配置文件名称命名为<code>logback-spring.xml</code>表示这是SpringBoot下Logback专用的配置，可以使用SpringBoot 的高级Proﬁle功能，它的内容类似于这样：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最外层由<code>configuration</code>包裹，一旦编写，那么就会替换默认的配置，所以如果内部什么都不写的话，那么会导致我们的SpringBoot项目没有配置任何日志输出方式，控制台也不会打印日志。</p>
<p>我们接着来看如何配置一个控制台日志打印，我们可以直接导入并使用SpringBoot为我们预设好的日志格式，在<code>org/springframework/boot/logging/logback/defaults.xml</code>中已经帮我们把日志的输出格式定义好了，我们只需要设置对应的<code>appender</code>即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">included</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">&quot;clr&quot;</span> <span class="attr">converterClass</span>=<span class="string">&quot;org.springframework.boot.logging.logback.ColorConverter&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">&quot;wex&quot;</span> <span class="attr">converterClass</span>=<span class="string">&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">&quot;wEx&quot;</span> <span class="attr">converterClass</span>=<span class="string">&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE_LOG_PATTERN&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE_LOG_CHARSET&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;CONSOLE_LOG_CHARSET:-$&#123;file.encoding:-UTF-8&#125;&#125;&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_LOG_PATTERN&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;FILE_LOG_PATTERN:-%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125; $&#123;LOG_LEVEL_PATTERN:-%5p&#125; $&#123;PID:- &#125; --- [%t] %-40.40logger&#123;39&#125; : %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_LOG_CHARSET&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;FILE_LOG_CHARSET:-$&#123;file.encoding:-UTF-8&#125;&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.catalina.startup.DigesterFactory&quot;</span> <span class="attr">level</span>=<span class="string">&quot;ERROR&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.catalina.util.LifecycleBase&quot;</span> <span class="attr">level</span>=<span class="string">&quot;ERROR&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.sshd.common.util.SecurityUtils&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.tomcat.util.net.NioSelectorPool&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.eclipse.jetty.util.component.AbstractLifeCycle&quot;</span> <span class="attr">level</span>=<span class="string">&quot;ERROR&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.hibernate.validator.internal.util.Version&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework.boot.actuate.endpoint.jmx&quot;</span> <span class="attr">level</span>=<span class="string">&quot;WARN&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">included</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>导入后，我们利用预设的日志格式创建一个控制台日志打印：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  导入其他配置文件，作为预设  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  Appender作为日志打印器配置，这里命名随意  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  ch.qos.logback.core.ConsoleAppender是专用于控制台的Appender  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>$&#123;CONSOLE_LOG_CHARSET&#125;<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  指定日志输出级别，以及启用的Appender，这里就使用了我们上面的ConsoleAppender  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置完成后，我们发现控制台已经可以正常打印日志信息了。</p>
<p>接着我们来看看如何开启文件打印，我们只需要配置一个对应的Appender即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  ch.qos.logback.core.rolling.RollingFileAppender用于文件日志记录，它支持滚动  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>$&#123;FILE_LOG_CHARSET&#125;<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  自定义滚动策略，防止日志文件无限变大，也就是日志文件写到什么时候为止，重新创建一个新的日志文件开始写  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  文件保存位置以及文件命名规则，这里用到了%d&#123;yyyy-MM-dd&#125;表示当前日期，%i表示这一天的第N个日志  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>log/%d&#123;yyyy-MM-dd&#125;-spring-%i.log<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  到期自动清理日志文件  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cleanHistoryOnStart</span>&gt;</span>true<span class="tag">&lt;/<span class="name">cleanHistoryOnStart</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  最大日志保留时间  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>7<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  最大单个日志文件大小  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  指定日志输出级别，以及启用的Appender，这里就使用了我们上面的ConsoleAppender  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置完成后，我们可以看到日志文件也能自动生成了。</p>
<p>我们也可以魔改官方提供的日志格式，官方文档：<a href="https://logback.qos.ch/manual/layouts.html">https://logback.qos.ch/manual/layouts.html</a></p>
<p>这里需要提及的是MDC机制，Logback内置的日志字段还是比较少，如果我们需要打印有关业务的更多的内容，包括自定义的一些数据，需要借助logback MDC机制，MDC为“Mapped Diagnostic Context”（映射诊断上下文），即将一些运行时的上下文数据通过logback打印出来；此时我们需要借助org.sl4j.MDC类。</p>
<p>比如我们现在需要记录是哪个用户访问我们网站的日志，只要是此用户访问我们网站，都会在日志中携带该用户的ID，我们希望每条日志中都携带这样一段信息文本，而官方提供的字段无法实现此功能，这时就需要使用MDC机制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">test</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">   MDC.put(<span class="string">&quot;reqId&quot;</span>, request.getSession().getId());</span><br><span class="line">   log.info(<span class="string">&quot;用户访问了一次测试数据&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> mapper.findUserById(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，我们就可以向日志中传入自定义参数了，我们日志中添加这样一个占位符<code>%X&#123;键值&#125;</code>，名字保持一致：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">%clr([%X&#123;reqId&#125;])&#123;faint&#125; </span><br></pre></td></tr></table></figure>

<p>这样当我们向MDC中添加信息后，只要是当前线程（本质是ThreadLocal实现）下输出的日志，都会自动替换占位符。</p>
<h3 id="自定义Banner展示"><a href="#自定义Banner展示" class="headerlink" title="自定义Banner展示"></a>自定义Banner展示</h3><p>我们在之前发现，实际上Banner部分和日志部分是独立的，SpringBoot启动后，会先打印Banner部分，那么这个Banner部分是否可以自定义呢？答案是可以的。</p>
<p>我们可以直接来配置文件所在目录下创建一个名为<code>banner.txt</code>的文本文档，内容随便你：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">//                          _ooOoo_                               //</span><br><span class="line">//                         o8888888o                              //</span><br><span class="line">//                         88&quot; . &quot;88                              //</span><br><span class="line">//                         (| ^_^ |)                              //</span><br><span class="line">//                         O\  =  /O                              //</span><br><span class="line">//                      ____/`---&#x27;\____                           //</span><br><span class="line">//                    .&#x27;  \\|     |//  `.                         //</span><br><span class="line">//                   /  \\|||  :  |||//  \                        //</span><br><span class="line">//                  /  _||||| -:- |||||-  \                       //</span><br><span class="line">//                  |   | \\\  -  /// |   |                       //</span><br><span class="line">//                  | \_|  &#x27;&#x27;\---/&#x27;&#x27;  |   |                       //</span><br><span class="line">//                  \  .-\__  `-`  ___/-. /                       //</span><br><span class="line">//                ___`. .&#x27;  /--.--\  `. . ___                     //</span><br><span class="line">//              .&quot;&quot; &#x27;&lt;  `.___\_&lt;|&gt;_/___.&#x27;  &gt;&#x27;&quot;&quot;.                  //</span><br><span class="line">//            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //</span><br><span class="line">//            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //</span><br><span class="line">//      ========`-.____`-.___\_____/___.-`____.-&#x27;========         //</span><br><span class="line">//                           `=---=&#x27;                              //</span><br><span class="line">//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //</span><br><span class="line">//             佛祖保佑          永无BUG         永不修改             //</span><br></pre></td></tr></table></figure>

<p>可以使用在线生成网站进行生成自己的个性Banner：<a href="https://www.bootschool.net/ascii">https://www.bootschool.net/ascii</a></p>
<p>我们甚至还可以使用颜色代码来为文本切换颜色：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;AnsiColor.BRIGHT_GREEN&#125;  //绿色</span><br></pre></td></tr></table></figure>

<p>也可以获取一些常用的变量信息：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;AnsiColor.YELLOW&#125; 当前 Spring Boot 版本：$&#123;spring-boot.version&#125;</span><br></pre></td></tr></table></figure>

<p>前面忘了，后面忘了，狠狠赚一笔！</p>
<hr>
<h2 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h2><p>在日常开发中，我们项目会有多个环境。例如开发环境（develop）也就是我们研发过程中疯狂敲代码修BUG阶段，生产环境（production ）项目开发得差不多了，可以放在服务器上跑了。不同的环境下，可能我们的配置文件也存在不同，但是我们不可能切换环境的时候又去重新写一次配置文件，所以我们可以将多个环境的配置文件提前写好，进行自由切换。</p>
<p>由于SpringBoot只会读取<code>application.properties</code>或是<code>application.yml</code>文件，那么怎么才能实现自由切换呢？SpringBoot给我们提供了一种方式，我们可以通过配置文件指定：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>

<p>接着我们分别创建两个环境的配置文件，<code>application-dev.yml</code>和<code>application-prod.yml</code>分别表示开发环境和生产环境的配置文件，比如开发环境我们使用的服务器端口为8080，而生产环境下可能就需要设置为80或是443端口，那么这个时候就需要不同环境下的配置文件进行区分：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>这样我们就可以灵活切换生产环境和开发环境下的配置文件了。</p>
<p>SpringBoot自带的Logback日志系统也是支持多环境配置的，比如我们想在开发环境下输出日志到控制台，而生产环境下只需要输出到文件即可，这时就需要进行环境配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;prod&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意<code>springProfile</code>是区分大小写的！</p>
<p>那如果我们希望生产环境中不要打包开发环境下的配置文件呢，我们目前虽然可以切换开发环境，但是打包的时候依然是所有配置文件全部打包，这样总感觉还欠缺一点完美，因此，打包的问题就只能找Maven解决了，Maven也可以设置多环境：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--分别设置开发，生产环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">environment</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 生产环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>false<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">environment</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着，我们需要根据环境的不同，排除其他环境的配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--排除配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--先排除所有的配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--使用通配符，当然可以定义多个exclude标签进行排除--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>application*.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--根据激活条件引入打包所需的配置和文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引入所需环境的配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>application.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--根据maven选择环境导入配置文件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>application-$&#123;environment&#125;.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着，我们可以直接将Maven中的<code>environment</code>属性，传递给SpringBoot的配置文件，在构建时替换为对应的值：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">&#x27;@environment@&#x27;</span>  <span class="comment">#注意YAML配置文件需要加单引号，否则会报错</span></span><br></pre></td></tr></table></figure>

<p>这样，根据我们Maven环境的切换，SpringBoot的配置文件也会进行对应的切换。</p>
<p>最后我们打开Maven栏目，就可以自由切换了，直接勾选即可，注意切换环境之后要重新加载一下Maven项目，不然不会生效！</p>
<hr>
<h2 id="常用框架介绍"><a href="#常用框架介绍" class="headerlink" title="常用框架介绍"></a>常用框架介绍</h2><p>前面我们介绍了SpringBoot项目的基本搭建，相信各位小伙伴已经体验到SpringBoot 3带来的超强便捷性了，不过光靠这些还不够，我们还需要了解更多框架来丰富我们的网站，通过了解其他的SpringBoot整合框架，我们就可以在我们自己的Web服务器上实现更多更高级的功能，同时也是为了给我们后续学习前后端分离项目做准备。</p>
<h3 id="邮件发送模块"><a href="#邮件发送模块" class="headerlink" title="邮件发送模块"></a>邮件发送模块</h3><p>都什么年代了，还在发传统邮件，我们来看看电子邮件。</p>
<p>我们在注册很多的网站时，都会遇到邮件或是手机号验证，也就是通过你的邮箱或是手机短信去接受网站发给你的注册验证信息，填写验证码之后，就可以完成注册了，同时，网站也会绑定你的手机号或是邮箱。</p>
<p>那么，像这样的功能，我们如何实现呢？SpringBoot已经给我们提供了封装好的邮件模块使用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在学习邮件发送之前，我们需要先了解一下什么是电子邮件。</p>
<blockquote>
<p>电子邮件也是一种通信方式，是互联网应用最广的服务。通过网络的电子邮件系统，用户可以以非常低廉的价格（不管发送到哪里，都只需负担网费，实际上就是把信息发送到对方服务器而已）、非常快速的方式，与世界上任何一个地方的电子邮箱用户联系。</p>
</blockquote>
<p>虽说方便倒是方便，虽然是曾经的霸主，不过现在这个时代，QQ微信横行，手机短信和电子邮箱貌似就只剩收验证码这一个功能了。</p>
<p>要在Internet上提供电子邮件功能，必须有专门的电子邮件服务器。例如现在Internet很多提供邮件服务的厂商：新浪、搜狐、163、QQ邮箱等，他们都有自己的邮件服务器。这些服务器类似于现实生活中的邮局，它主要负责接收用户投递过来的邮件，并把邮件投递到邮件接收者的电子邮箱中。</p>
<p>所有的用户都可以在电子邮件服务器上申请一个账号用于邮件发送和接收，那么邮件是以什么样的格式发送的呢？实际上和Http一样，邮件发送也有自己的协议，也就是约定邮件数据长啥样以及如何通信。</p>
<p><img src="https://s2.loli.net/2023/07/16/sL56YdmgGblfFjo.png" alt="image-20230716172901937"></p>
<p>比较常用的协议有两种：</p>
<ol>
<li>SMTP协议（主要用于发送邮件 Simple Mail Transfer Protocol）</li>
<li>POP3协议（主要用于接收邮件 Post Office Protocol 3）</li>
</ol>
<p>整个发送&#x2F;接收流程大致如下：</p>
<p><img src="https://s2.loli.net/2023/07/16/sOyWQguFonJKXNw.jpg" alt="img"></p>
<p>实际上每个邮箱服务器都有一个smtp发送服务器和pop3接收服务器，比如要从QQ邮箱发送邮件到163邮箱，那么我们只需要通过QQ邮箱客户端告知QQ邮箱的smtp服务器我们需要发送邮件，以及邮件的相关信息，然后QQ邮箱的smtp服务器就会帮助我们发送到163邮箱的pop3服务器上，163邮箱会通过163邮箱客户端告知对应用户收到一封新邮件。</p>
<p>而我们如果想要实现给别人发送邮件，那么就需要连接到对应电子邮箱的smtp服务器上，并告知其我们要发送邮件。而SpringBoot已经帮助我们将最基本的底层通信全部实现了，我们只需要关心smtp服务器的地址以及我们要发送的邮件长啥样即可。</p>
<p>这里以163邮箱 <a href="https://mail.163.com/">https://mail.163.com</a> 为例，我们需要在配置文件中告诉SpringBootMail我们的smtp服务器的地址以及你的邮箱账号和密码，首先我们要去设置中开启smtp&#x2F;pop3服务才可以，开启后会得到一个随机生成的密钥，这个就是我们的密码。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">      <span class="comment"># 163邮箱的地址为smtp.163.com，直接填写即可</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.163.com</span></span><br><span class="line">    <span class="comment"># 你申请的163邮箱</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">javastudy111@163.com</span></span><br><span class="line">    <span class="comment"># 注意密码是在开启smtp/pop3时自动生成的，记得保存一下，不然就找不到了</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">AZJTOAWZESLMHTNI</span></span><br></pre></td></tr></table></figure>

<p>配置完成后，接着我们来进行一下测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringBootTestApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//JavaMailSender是专门用于发送邮件的对象，自动配置类已经提供了Bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JavaMailSender sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="comment">//SimpleMailMessage是一个比较简易的邮件封装，支持设置一些比较简单内容</span></span><br><span class="line">        <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">          <span class="comment">//设置邮件标题</span></span><br><span class="line">        message.setSubject(<span class="string">&quot;【电子科技大学教务处】关于近期学校对您的处分决定&quot;</span>);</span><br><span class="line">          <span class="comment">//设置邮件内容</span></span><br><span class="line">        message.setText(<span class="string">&quot;XXX同学您好，经监控和教务巡查发现，您近期存在旷课、迟到、早退、上课刷抖音行为，&quot;</span> +</span><br><span class="line">                <span class="string">&quot;现已通知相关辅导员，请手写5000字书面检讨，并在2022年4月1日17点前交到辅导员办公室。&quot;</span>);</span><br><span class="line">          <span class="comment">//设置邮件发送给谁，可以多个，这里就发给你的QQ邮箱</span></span><br><span class="line">        message.setTo(<span class="string">&quot;你的QQ号@qq.com&quot;</span>);</span><br><span class="line">          <span class="comment">//邮件发送者，这里要与配置文件中的保持一致</span></span><br><span class="line">        message.setFrom(<span class="string">&quot;javastudy111@163.com&quot;</span>);</span><br><span class="line">          <span class="comment">//OK，万事俱备只欠发送</span></span><br><span class="line">        sender.send(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要添加附件等更多功能，可以使用MimeMessageHelper来帮助我们完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> MessagingException &#123;</span><br><span class="line">      <span class="comment">//创建一个MimeMessage</span></span><br><span class="line">    <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> sender.createMimeMessage();</span><br><span class="line">      <span class="comment">//使用MimeMessageHelper来帮我们修改MimeMessage中的信息</span></span><br><span class="line">    <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message, <span class="literal">true</span>);</span><br><span class="line">    helper.setSubject(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    helper.setText(<span class="string">&quot;lbwnb&quot;</span>);</span><br><span class="line">    helper.setTo(<span class="string">&quot;你的QQ号@qq.com&quot;</span>);</span><br><span class="line">    helper.setFrom(<span class="string">&quot;javastudy111@163.com&quot;</span>);</span><br><span class="line">      <span class="comment">//发送修改好的MimeMessage</span></span><br><span class="line">    sender.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们来尝试为我们的网站实现一个邮件注册功能，首先明确验证流程：请求验证码 -&gt; 生成验证码（临时有效，注意设定过期时间） -&gt; 用户输入验证码并填写注册信息 -&gt; 验证通过注册成功！</p>
<p>接着我们就来着手写一下。</p>
<h3 id="接口规则校验"><a href="#接口规则校验" class="headerlink" title="接口规则校验"></a>接口规则校验</h3><p>通常我们在使用SpringMvc框架编写接口时，很有可能用户发送的数据存在一些问题，比如下面这个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/submit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">submit</span><span class="params">(String username,</span></span><br><span class="line"><span class="params">                     String password)</span>&#123;</span><br><span class="line">    System.out.println(username.substring(<span class="number">3</span>));</span><br><span class="line">    System.out.println(password.substring(<span class="number">2</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;请求成功!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口中，我们需要将用户名和密码分割然后打印，在正常情况下，因为用户名长度规定不小于5，如果用户发送的数据是没有问题的，那么就可以正常运行，这也是我们所希望的情况，但是如果用户发送的数据并不是按照规定的，那么就会直接报错：</p>
<p><img src="https://s2.loli.net/2023/07/16/n1FMADOiQCRcGw6.png" alt="image-20230716215850225"></p>
<p>这个时候，我们就需要在请求进来之前进行校验了，最简单的办法就是判断一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/submit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">submit</span><span class="params">(String username,</span></span><br><span class="line"><span class="params">                     String password)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(username.length() &gt; <span class="number">3</span> &amp;&amp; password.length() &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        System.out.println(username.substring(<span class="number">3</span>));</span><br><span class="line">        System.out.println(password.substring(<span class="number">2</span>, <span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;请求成功!&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;请求失败&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这样就能直接解决问题，但是如果我们的每一个接口都需要这样去进行配置，那么是不是太麻烦了一点？SpringBoot为我们提供了很方便的接口校验框架：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在，我们可以直接使用注解完成全部接口的校验：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Validated</span>   <span class="comment">//首先在Controller上开启接口校验</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/submit&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">submit</span><span class="params">(<span class="meta">@Length(min = 3)</span> String username,  //使用<span class="meta">@Length</span>注解一步到位</span></span><br><span class="line"><span class="params">                         <span class="meta">@Length(min = 10)</span> String password)</span>&#123;</span><br><span class="line">        System.out.println(username.substring(<span class="number">3</span>));</span><br><span class="line">        System.out.println(password.substring(<span class="number">2</span>, <span class="number">10</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;请求成功!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们的接口校验就可以快速进行配置了，一个接口就能搞定：</p>
<p><img src="https://s2.loli.net/2023/07/16/EibCc4sHWflywek.png" alt="image-20230716220839816"></p>
<p>不过这样依然会抛出一个异常，对用户不太友好，我们可以稍微处理一下，这里我们可以直接使用之前在SSM阶段中学习的异常处理Controller来自行处理这类异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidationController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ConstraintViolationException.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">error</span><span class="params">(ValidationException e)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.getMessage();   <span class="comment">//出现异常直接返回消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/07/16/7JH6BzOhlUe9gkG.png" alt="image-20230716221420324"></p>
<p>除了@Length之外，我们也可以使用其他的接口来实现各种数据校验：</p>
<table>
<thead>
<tr>
<th align="center">验证注解</th>
<th align="center">验证的数据类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@AssertFalse</td>
<td align="center">Boolean,boolean</td>
<td align="center">值必须是false</td>
</tr>
<tr>
<td align="center">@AssertTrue</td>
<td align="center">Boolean,boolean</td>
<td align="center">值必须是true</td>
</tr>
<tr>
<td align="center">@NotNull</td>
<td align="center">任意类型</td>
<td align="center">值不能是null</td>
</tr>
<tr>
<td align="center">@Null</td>
<td align="center">任意类型</td>
<td align="center">值必须是null</td>
</tr>
<tr>
<td align="center">@Min</td>
<td align="center">BigDecimal、BigInteger、byte、short、int、long、double 以及任何Number或CharSequence子类型</td>
<td align="center">大于等于@Min指定的值</td>
</tr>
<tr>
<td align="center">@Max</td>
<td align="center">同上</td>
<td align="center">小于等于@Max指定的值</td>
</tr>
<tr>
<td align="center">@DecimalMin</td>
<td align="center">同上</td>
<td align="center">大于等于@DecimalMin指定的值（超高精度）</td>
</tr>
<tr>
<td align="center">@DecimalMax</td>
<td align="center">同上</td>
<td align="center">小于等于@DecimalMax指定的值（超高精度）</td>
</tr>
<tr>
<td align="center">@Digits</td>
<td align="center">同上</td>
<td align="center">限制整数位数和小数位数上限</td>
</tr>
<tr>
<td align="center">@Size</td>
<td align="center">字符串、Collection、Map、数组等</td>
<td align="center">长度在指定区间之内，如字符串长度、集合大小等</td>
</tr>
<tr>
<td align="center">@Past</td>
<td align="center">如 java.util.Date, java.util.Calendar 等日期类型</td>
<td align="center">值必须比当前时间早</td>
</tr>
<tr>
<td align="center">@Future</td>
<td align="center">同上</td>
<td align="center">值必须比当前时间晚</td>
</tr>
<tr>
<td align="center">@NotBlank</td>
<td align="center">CharSequence及其子类</td>
<td align="center">值不为空，在比较时会去除字符串的首位空格</td>
</tr>
<tr>
<td align="center">@Length</td>
<td align="center">CharSequence及其子类</td>
<td align="center">字符串长度在指定区间内</td>
</tr>
<tr>
<td align="center">@NotEmpty</td>
<td align="center">CharSequence及其子类、Collection、Map、数组</td>
<td align="center">值不为null且长度不为空（字符串长度不为0，集合大小不为0）</td>
</tr>
<tr>
<td align="center">@Range</td>
<td align="center">BigDecimal、BigInteger、CharSequence、byte、short、int、long 以及原子类型和包装类型</td>
<td align="center">值在指定区间内</td>
</tr>
<tr>
<td align="center">@Email</td>
<td align="center">CharSequence及其子类</td>
<td align="center">值必须是邮件格式</td>
</tr>
<tr>
<td align="center">@Pattern</td>
<td align="center">CharSequence及其子类</td>
<td align="center">值需要与指定的正则表达式匹配</td>
</tr>
<tr>
<td align="center">@Valid</td>
<td align="center">任何非原子类型</td>
<td align="center">用于验证对象属性</td>
</tr>
</tbody></table>
<p>虽然这样已经很方便了，但是在遇到对象的时候，依然不太方便，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    String username;</span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/submit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">submit</span><span class="params">(Account account)</span>&#123;   <span class="comment">//直接使用对象接收</span></span><br><span class="line">    System.out.println(account.getUsername().substring(<span class="number">3</span>));</span><br><span class="line">    System.out.println(account.getPassword().substring(<span class="number">2</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;请求成功!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时接口是以对象形式接收前端发送的表单数据的，这个时候就没办法向上面一样编写对应的校验规则了，那么现在又该怎么做呢？</p>
<p>对应对象类型，我们也可以进行验证，方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/submit&quot;)</span>  <span class="comment">//在参数上添加@Valid注解表示需要验证</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">submit</span><span class="params">(<span class="meta">@Valid</span> Account account)</span>&#123;</span><br><span class="line">    System.out.println(account.getUsername().substring(<span class="number">3</span>));</span><br><span class="line">    System.out.println(account.getPassword().substring(<span class="number">2</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;请求成功!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="meta">@Length(min = 3)</span>   <span class="comment">//只需要在对应的字段上添加校验的注解即可</span></span><br><span class="line">    String username;</span><br><span class="line">    <span class="meta">@Length(min = 10)</span></span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样当受到请求时，就会对对象中的字段进行校验了，这里我们稍微修改一下ValidationController的错误处理，对于实体类接收参数的验证，会抛出MethodArgumentNotValidException异常，这里也进行一下处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@ExceptionHandler(&#123;ConstraintViolationException.class, MethodArgumentNotValidException.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">error</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e <span class="keyword">instanceof</span> ConstraintViolationException exception) &#123;</span><br><span class="line">        <span class="keyword">return</span> exception.getMessage();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> MethodArgumentNotValidException exception)&#123;</span><br><span class="line">        <span class="keyword">if</span> (exception.getFieldError() == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;未知错误&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> exception.getFieldError().getDefaultMessage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;未知错误&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以正确返回对应的错误信息了。</p>
<h2 id="数据交互"><a href="#数据交互" class="headerlink" title="数据交互"></a>数据交互</h2><h3 id="JDBC交互框架"><a href="#JDBC交互框架" class="headerlink" title="JDBC交互框架"></a>JDBC交互框架</h3><p>除了我们前面一直认识的Mybatis之外，实际上Spring官方也提供了一个非常方便的JDBC操作工具，它同样可以快速进行增删改查。首先我们还是通过starter将依赖导入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>导入完成之后就可以轻松使用了。</p>
<h4 id="JDBC模版类"><a href="#JDBC模版类" class="headerlink" title="JDBC模版类"></a>JDBC模版类</h4><p>Spring JDBC为我们提供了一个非常方便的<code>JdbcTemplate</code>类，它封装了常用的JDBC操作，我们可以快速使用这些方法来实现增删改查，这里我们还是配置一下MySQL数据源信息：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>我们要操作数据库，最简单直接的方法就是使用JdbcTemplate来完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">JdbcTemplate template;</span><br></pre></td></tr></table></figure>

<p>它给我们封装了很多方法使用，比如我们要查询数据库中的一条记录：</p>
<p><img src="https://s2.loli.net/2023/07/16/ygRp98mDKafXkw1.png" alt="image-20230716000431492"></p>
<p>我们可以使用<code>queryForMap</code>快速以Map为结果的形式查询一行数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = template.queryForMap(<span class="string">&quot;select * from user where id = ?&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非常方便：</p>
<p><img src="https://s2.loli.net/2023/07/20/ijczpNxh4fXoQKv.png" alt="image-20230720215124918"></p>
<p>我们也可以编写自定义的Mapper用于直接得到查询结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    String email;</span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> template.queryForObject(<span class="string">&quot;select * from user where id = ?&quot;</span>,</span><br><span class="line">        (r, i) -&gt; <span class="keyword">new</span> <span class="title class_">User</span>(r.getInt(<span class="number">1</span>), r.getString(<span class="number">2</span>), r.getString(<span class="number">3</span>), r.getString(<span class="number">4</span>)), <span class="number">1</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然除了这些之外，它还提供了<code>update</code>方法适用于各种情况的查询、更新、删除操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> template.update(<span class="string">&quot;insert into user values(2, &#x27;admin&#x27;, &#x27;654321@qq.com&#x27;, &#x27;123456&#x27;)&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;更新了 &quot;</span>+update+<span class="string">&quot; 行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，如果是那种非常小型的项目，甚至是测试用例的话，都可以快速使用JdbcTemplate快速进行各种操作。</p>
<h4 id="JDBC简单封装"><a href="#JDBC简单封装" class="headerlink" title="JDBC简单封装"></a>JDBC简单封装</h4><p>对于一些插入操作，Spring JDBC为我们提供了更方便的SimpleJdbcInsert工具，它可以实现更多高级的插入功能，比如我们的表主键采用的是自增ID，那么它支持插入后返回自动生成的ID，这就非常方便了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    DataSource source;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="comment">//这个类需要自己创建对象</span></span><br><span class="line">        <span class="type">SimpleJdbcInsert</span> <span class="variable">simple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleJdbcInsert</span>(source)</span><br><span class="line">                .withTableName(<span class="string">&quot;user&quot;</span>)   <span class="comment">//设置要操作的表名称</span></span><br><span class="line">                .usingGeneratedKeyColumns(<span class="string">&quot;id&quot;</span>);    <span class="comment">//设置自增主键列</span></span><br><span class="line">        Map&lt;String, Object&gt; user = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);  <span class="comment">//插入操作需要传入一个Map作为数据</span></span><br><span class="line">        user.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;bob&quot;</span>);</span><br><span class="line">        user.put(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;112233@qq.com&quot;</span>);</span><br><span class="line">        user.put(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="type">Number</span> <span class="variable">number</span> <span class="operator">=</span> simple.executeAndReturnKey(user);   <span class="comment">//最后得到的Numver就是得到的自增主键</span></span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以快速进行插入操作并且返回自增主键了，还是挺方便的。</p>
<p><img src="https://s2.loli.net/2023/07/20/xMeBEY3sdKVGmly.png" alt="image-20230720224314223"></p>
<p>当然，虽然SpringJDBC给我们提供了这些小工具，但是其实只适用于简单小项目，稍微复杂一点就不太适合了，下一部分我们将介绍JPA框架。</p>
<h3 id="JPA框架"><a href="#JPA框架" class="headerlink" title="JPA框架"></a>JPA框架</h3><p><img src="https://s2.loli.net/2023/07/20/mq4Ut7BMI5XTDoN.png" alt="image-20230720230734488"></p>
<ul>
<li>用了Mybatis之后，你看那个JDBC，真是太逊了。</li>
<li>这么说，你的项目很勇哦？</li>
<li>开玩笑，我的写代码超勇的好不好。</li>
<li>阿伟，你可曾幻想过有一天你的项目里不再有SQL语句？</li>
<li>不再有SQL语句？那我怎么和数据库交互啊？</li>
<li>我看你是完全不懂哦</li>
<li>懂，懂什么啊？</li>
<li>你想懂？来，到我项目里来，我给你看点好康的。</li>
<li>好康？是什么新框架哦？</li>
<li>什么新框架，比新框架还刺激，还可以让你的项目登duang郎哦。</li>
<li>哇，杰哥，你项目里面都没SQL语句诶，这是用的什么框架啊？</li>
</ul>
<p>​		在我们之前编写的项目中，我们不难发现，实际上大部分的数据库交互操作，到最后都只会做一个事情，那就是把数据库中的数据映射为Java中的对象。比如我们要通过用户名去查找对应的用户，或是通过ID查找对应的学生信息，在使用Mybatis时，我们只需要编写正确的SQL语句就可以直接将获取的数据映射为对应的Java对象，通过调用Mapper中的方法就能直接获得实体类，这样就方便我们在Java中数据库表中的相关信息了。</p>
<p>​		但是以上这些操作都有一个共性，那就是它们都是通过某种条件去进行查询，而最后的查询结果，都是一个实体类，所以你会发现你写的很多SQL语句都是一个套路<code>select * from xxx where xxx=xxx</code>，实际上对于这种简单SQL语句，我们完全可以弄成一个模版来使用，那么能否有一种框架，帮我们把这些相同的套路给封装起来，直接把这类相似的SQL语句给屏蔽掉，不再由我们编写，而是让框架自己去组合拼接。</p>
<h4 id="认识SpringData-JPA"><a href="#认识SpringData-JPA" class="headerlink" title="认识SpringData JPA"></a>认识SpringData JPA</h4><p>首先我们来看一个国外的统计：</p>
<p><img src="https://s2.loli.net/2023/03/06/XaoLIPrjDKzO9Tx.png" alt="image-20230306224859664"></p>
<p>不对吧，为什么Mybatis这么好用，这么强大，却只有10%的人喜欢呢？然而事实就是，在国外JPA几乎占据了主导地位，而Mybatis并不像国内那样受待见，所以你会发现，JPA都有SpringBoot的官方直接提供的starter，而Mybatis没有，直到SpringBoot 3才开始加入到官方模版中。</p>
<p>那么，什么是JPA？</p>
<blockquote>
<p>JPA（Java Persistence API）和JDBC类似，也是官方定义的一组接口，但是它相比传统的JDBC，它是为了实现ORM而生的，即Object-Relationl Mapping，它的作用是在关系型数据库和对象之间形成一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作它就可以了。</p>
<p>其中比较常见的JPA实现有：</p>
<ol>
<li>Hibernate：Hibernate是JPA规范的一个具体实现，也是目前使用最广泛的JPA实现框架之一。它提供了强大的对象关系映射功能，可以将Java对象映射到数据库表中，并提供了丰富的查询语言和缓存机制。</li>
<li>EclipseLink：EclipseLink是另一个流行的JPA实现框架，由Eclipse基金会开发和维护。它提供了丰富的特性，如对象关系映射、缓存、查询语言和连接池管理等，并具有较高的性能和可扩展性。</li>
<li>OpenJPA：OpenJPA是Apache基金会的一个开源项目，也是JPA规范的一个实现。它提供了高性能的JPA实现和丰富的特性，如延迟加载、缓存和分布式事务等。</li>
<li>TopLink：TopLink是Oracle公司开发的一个对象关系映射框架，也是JPA规范的一个实现。虽然EclipseLink已经取代了TopLink成为Oracle推荐的JPA实现，但TopLink仍然得到广泛使用。</li>
</ol>
</blockquote>
<p>在之前，我们使用JDBC或是Mybatis来操作数据，通过直接编写对应的SQL语句来实现数据访问，但是我们发现实际上我们在Java中大部分操作数据库的情况都是读取数据并封装为一个实体类，因此，为什么不直接将实体类直接对应到一个数据库表呢？也就是说，一张表里面有什么属性，那么我们的对象就有什么属性，所有属性跟数据库里面的字段一一对应，而读取数据时，只需要读取一行的数据并封装为我们定义好的实体类既可以，而具体的SQL语句执行，完全可以交给框架根据我们定义的映射关系去生成，不再由我们去编写，因为这些SQL实际上都是千篇一律的。</p>
<p>而实现JPA规范的框架一般最常用的就是<code>Hibernate</code>，它是一个重量级框架，学习难度相比Mybatis也更高一些，而SpringDataJPA也是采用Hibernate框架作为底层实现，并对其加以封装。</p>
<p>官网：<a href="https://spring.io/projects/spring-data-jpa">https://spring.io/projects/spring-data-jpa</a></p>
<h4 id="使用JPA快速上手"><a href="#使用JPA快速上手" class="headerlink" title="使用JPA快速上手"></a>使用JPA快速上手</h4><p>同样的，我们只需要导入stater依赖即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着我们可以直接创建一个类，比如用户类，我们只需要把一个账号对应的属性全部定义好即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String username;</span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，我们可以通过注解形式，在属性上添加数据库映射关系，这样就能够让JPA知道我们的实体类对应的数据库表长啥样，这里用到了很多注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span>   <span class="comment">//表示这个类是一个实体类</span></span><br><span class="line"><span class="meta">@Table(name = &quot;account&quot;)</span>    <span class="comment">//对应的数据库中表名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>   <span class="comment">//生成策略，这里配置为自增</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;id&quot;)</span>    <span class="comment">//对应表中id这一列</span></span><br><span class="line">    <span class="meta">@Id</span>     <span class="comment">//此属性为主键</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;username&quot;)</span>   <span class="comment">//对应表中username这一列</span></span><br><span class="line">    String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;password&quot;)</span>   <span class="comment">//对应表中password这一列</span></span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来修改一下配置文件，把日志打印给打开：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="comment">#开启SQL语句执行日志信息</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="comment">#配置为检查数据库表结构，没有时会自动创建</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br></pre></td></tr></table></figure>

<p><code>ddl-auto</code>属性用于设置自动表定义，可以实现自动在数据库中为我们创建一个表，表的结构会根据我们定义的实体类决定，它有以下几种：</p>
<ul>
<li><code>none</code>: 不执行任何操作，数据库表结构需要手动创建。</li>
<li><code>create</code>: 框架在每次运行时都会删除所有表，并重新创建。</li>
<li><code>create-drop</code>: 框架在每次运行时都会删除所有表，然后再创建，但在程序结束时会再次删除所有表。</li>
<li><code>update</code>: 框架会检查数据库表结构，如果与实体类定义不匹配，则会做相应的修改，以保持它们的一致性。</li>
<li><code>validate</code>: 框架会检查数据库表结构与实体类定义是否匹配，如果不匹配，则会抛出异常。</li>
</ul>
<p>这个配置项的作用是为了避免手动管理数据库表结构，使开发者可以更方便地进行开发和测试，但在生产环境中，更推荐使用数据库迁移工具来管理表结构的变更。</p>
<p>我们可以在日志中发现，在启动时执行了如下SQL语句：</p>
<p><img src="https://s2.loli.net/2023/07/20/kABZVhJ8vjKSqzT.png" alt="image-20230720235136506"></p>
<p>我们的数据库中对应的表已经自动创建好了。</p>
<p>我们接着来看如何访问我们的表，我们需要创建一个Repository实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意JpaRepository有两个泛型，前者是具体操作的对象实体，也就是对应的表，后者是ID的类型，接口中已经定义了比较常用的数据库操作。编写接口继承即可，我们可以直接注入此接口获得实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">AccountRepository repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    account.setUsername(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">    account.setPassword(<span class="string">&quot;1234567&quot;</span>);</span><br><span class="line">    System.out.println(repository.save(account).getId());   <span class="comment">//使用save来快速插入数据，并且会返回插入的对象，如果存在自增ID，对象的自增id属性会自动被赋值，这就很方便了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<p><img src="https://s2.loli.net/2023/07/20/ksI3J5eidzTrvyL.png" alt="image-20230720235640148"></p>
<p>同时，查询操作也很方便：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="comment">//默认通过通过ID查找的方法，并且返回的结果是Optional包装的对象，非常人性化</span></span><br><span class="line">    repository.findById(<span class="number">1</span>).ifPresent(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果为：</p>
<p><img src="https://s2.loli.net/2023/07/20/TRHOWbop267Al4Q.png" alt="image-20230720235949290"></p>
<p>包括常见的一些计数、删除操作等都包含在里面，仅仅配置应该接口就能完美实现增删改查：</p>
<p><img src="https://s2.loli.net/2023/07/21/uIBciLqFsH5tdDR.png" alt="image-20230721000050875"></p>
<p>我们发现，使用了JPA之后，整个项目的代码中没有出现任何的SQL语句，可以说是非常方便了，JPA依靠我们提供的注解信息自动完成了所有信息的映射和关联。</p>
<p>相比Mybatis，JPA几乎就是一个全自动的ORM框架，而Mybatis则顶多算是半自动ORM框架。</p>
<h4 id="方法名称拼接自定义SQL"><a href="#方法名称拼接自定义SQL" class="headerlink" title="方法名称拼接自定义SQL"></a>方法名称拼接自定义SQL</h4><p>虽然接口预置的方法使用起来非常方便，但是如果我们需要进行条件查询等操作或是一些判断，就需要自定义一些方法来实现，同样的，我们不需要编写SQL语句，而是通过方法名称的拼接来实现条件判断，这里列出了所有支持的条件判断名称：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>拼接方法名称示例</th>
<th>执行的语句</th>
</tr>
</thead>
<tbody><tr>
<td>Distinct</td>
<td>findDistinctByLastnameAndFirstname</td>
<td>select distinct … where x.lastname &#x3D; ?1 and x.firstname &#x3D; ?2</td>
</tr>
<tr>
<td>And</td>
<td>findByLastnameAndFirstname</td>
<td>… where x.lastname &#x3D; ?1 and x.firstname &#x3D; ?2</td>
</tr>
<tr>
<td>Or</td>
<td>findByLastnameOrFirstname</td>
<td>… where x.lastname &#x3D; ?1 or x.firstname &#x3D; ?2</td>
</tr>
<tr>
<td>Is，Equals</td>
<td>findByFirstname<code>,</code>findByFirstnameIs<code>,</code>findByFirstnameEquals</td>
<td>… where x.firstname &#x3D; ?1</td>
</tr>
<tr>
<td>Between</td>
<td>findByStartDateBetween</td>
<td>… where x.startDate between ?1 and ?2</td>
</tr>
<tr>
<td>LessThan</td>
<td>findByAgeLessThan</td>
<td>… where x.age &lt; ?1</td>
</tr>
<tr>
<td>LessThanEqual</td>
<td>findByAgeLessThanEqual</td>
<td>… where x.age &lt;&#x3D; ?1</td>
</tr>
<tr>
<td>GreaterThan</td>
<td>findByAgeGreaterThan</td>
<td>… where x.age &gt; ?1</td>
</tr>
<tr>
<td>GreaterThanEqual</td>
<td>findByAgeGreaterThanEqual</td>
<td>… where x.age &gt;&#x3D; ?1</td>
</tr>
<tr>
<td>After</td>
<td>findByStartDateAfter</td>
<td>… where x.startDate &gt; ?1</td>
</tr>
<tr>
<td>Before</td>
<td>findByStartDateBefore</td>
<td>… where x.startDate &lt; ?1</td>
</tr>
<tr>
<td>IsNull，Null</td>
<td>findByAge(Is)Null</td>
<td>… where x.age is null</td>
</tr>
<tr>
<td>IsNotNull，NotNull</td>
<td>findByAge(Is)NotNull</td>
<td>… where x.age not null</td>
</tr>
<tr>
<td>Like</td>
<td>findByFirstnameLike</td>
<td>… where x.firstname like ?1</td>
</tr>
<tr>
<td>NotLike</td>
<td>findByFirstnameNotLike</td>
<td>… where x.firstname not like ?1</td>
</tr>
<tr>
<td>StartingWith</td>
<td>findByFirstnameStartingWith</td>
<td>… where x.firstname like ?1（参数与附加<code>%</code>绑定）</td>
</tr>
<tr>
<td>EndingWith</td>
<td>findByFirstnameEndingWith</td>
<td>… where x.firstname like ?1（参数与前缀<code>%</code>绑定）</td>
</tr>
<tr>
<td>Containing</td>
<td>findByFirstnameContaining</td>
<td>… where x.firstname like ?1（参数绑定以<code>%</code>包装）</td>
</tr>
<tr>
<td>OrderBy</td>
<td>findByAgeOrderByLastnameDesc</td>
<td>… where x.age &#x3D; ?1 order by x.lastname desc</td>
</tr>
<tr>
<td>Not</td>
<td>findByLastnameNot</td>
<td>… where x.lastname &lt;&gt; ?1</td>
</tr>
<tr>
<td>In</td>
<td>findByAgeIn(Collection<Age> ages)</td>
<td>… where x.age in ?1</td>
</tr>
<tr>
<td>NotIn</td>
<td>findByAgeNotIn(Collection<Age> ages)</td>
<td>… where x.age not in ?1</td>
</tr>
<tr>
<td>True</td>
<td>findByActiveTrue</td>
<td>… where x.active &#x3D; true</td>
</tr>
<tr>
<td>False</td>
<td>findByActiveFalse</td>
<td>… where x.active &#x3D; false</td>
</tr>
<tr>
<td>IgnoreCase</td>
<td>findByFirstnameIgnoreCase</td>
<td>… where UPPER(x.firstname) &#x3D; UPPER(?1)</td>
</tr>
</tbody></table>
<p>比如我们想要实现根据用户名模糊匹配查找用户：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;</span><br><span class="line">    <span class="comment">//按照表中的规则进行名称拼接，不用刻意去记，IDEA会有提示</span></span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAllByUsernameLike</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    repository.findAllByUsernameLike(<span class="string">&quot;%明%&quot;</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/07/21/mioZaUk7Yj3QDxb.png" alt="image-20230721001035279"></p>
<p>又比如我们想同时根据用户名和ID一起查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;</span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAllByUsernameLike</span><span class="params">(String str)</span>;</span><br><span class="line"></span><br><span class="line">    Account <span class="title function_">findByIdAndUsername</span><span class="params">(<span class="type">int</span> id, String username)</span>;</span><br><span class="line">    <span class="comment">//也可以使用Optional类进行包装，Optional&lt;Account&gt; findByIdAndUsername(int id, String username);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(repository.findByIdAndUsername(<span class="number">1</span>, <span class="string">&quot;小明&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们想判断数据库中是否存在某个ID的用户：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;</span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAllByUsernameLike</span><span class="params">(String str)</span>;</span><br><span class="line">    Account <span class="title function_">findByIdAndUsername</span><span class="params">(<span class="type">int</span> id, String username)</span>;</span><br><span class="line">    <span class="comment">//使用exists判断是否存在</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">existsAccountById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意自定义条件操作的方法名称一定要遵循规则，不然会出现异常：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Caused by: org.springframework.data.repository.query.QueryCreationException: Could not create query <span class="keyword">for</span> public abstract  ...</span><br></pre></td></tr></table></figure>

<p>有了这些操作，我们在编写一些简单SQL的时候就很方便了，用久了甚至直接忘记SQL怎么写。</p>
<h4 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h4><p>在实际开发中，比较常见的场景还有关联查询，也就是我们会在表中添加一个外键字段，而此外键字段又指向了另一个表中的数据，当我们查询数据时，可能会需要将关联数据也一并获取，比如我们想要查询某个用户的详细信息，一般用户简略信息会单独存放一个表，而用户详细信息会单独存放在另一个表中。当然，除了用户详细信息之外，可能在某些电商平台还会有用户的购买记录、用户的购物车，交流社区中的用户帖子、用户评论等，这些都是需要根据用户信息进行关联查询的内容。</p>
<p><img src="https://s2.loli.net/2023/03/06/WnPEmdR2sDLuwGN.jpg" alt="img"></p>
<p>我们知道，在JPA中，每张表实际上就是一个实体类的映射，而表之间的关联关系，也可以看作对象之间的依赖关系，比如用户表中包含了用户详细信息的ID字段作为外键，那么实际上就是用户表实体中包括了用户详细信息实体对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users_detail&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDetail</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;id&quot;)</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;address&quot;)</span></span><br><span class="line">    String address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;email&quot;)</span></span><br><span class="line">    String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;phone&quot;)</span></span><br><span class="line">    String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;real_name&quot;)</span></span><br><span class="line">    String realName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而用户信息和用户详细信息之间形成了一对一的关系，那么这时我们就可以直接在类中指定这种关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;id&quot;)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;username&quot;)</span></span><br><span class="line">    String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;password&quot;)</span></span><br><span class="line">    String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;detail_id&quot;)</span>   <span class="comment">//指定存储外键的字段名称</span></span><br><span class="line">    <span class="meta">@OneToOne</span>    <span class="comment">//声明为一对一关系</span></span><br><span class="line">    AccountDetail detail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在修改实体类信息后，我们发现在启动时也进行了更新，日志如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hibernate: alter table users add column detail_id integer</span><br><span class="line">Hibernate: create table users_detail (id integer not null auto_increment, address varchar(255), email varchar(255), phone varchar(255), real_name varchar(255), primary key (id)) engine=InnoDB</span><br><span class="line">Hibernate: alter table users add constraint FK7gb021edkxf3mdv5bs75ni6jd foreign key (detail_id) references users_detail (id)</span><br></pre></td></tr></table></figure>

<p>是不是感觉非常方便！都懒得去手动改表结构了。</p>
<p>接着我们往用户详细信息中添加一些数据，一会我们可以直接进行查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pageAccount</span><span class="params">()</span> &#123;</span><br><span class="line">    repository.findById(<span class="number">1</span>).ifPresent(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询后，可以发现，得到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hibernate: select account0_.id as id1_0_0_, account0_.detail_id as detail_i4_0_0_, account0_.password as password2_0_0_, account0_.username as username3_0_0_, accountdet1_.id as id1_1_1_, accountdet1_.address as address2_1_1_, accountdet1_.email as email3_1_1_, accountdet1_.phone as phone4_1_1_, accountdet1_.real_name as real_nam5_1_1_ from users account0_ left outer join users_detail accountdet1_ on account0_.detail_id=accountdet1_.id where account0_.id=?</span><br><span class="line">Account(id=1, username=Test, password=123456, detail=AccountDetail(id=1, address=四川省成都市青羊区, email=8371289@qq.com, phone=1234567890, realName=本伟))</span><br></pre></td></tr></table></figure>

<p>也就是，在建立关系之后，我们查询Account对象时，会自动将关联数据的结果也一并进行查询。</p>
<p>那要是我们只想要Account的数据，不想要用户详细信息数据怎么办呢？我希望在我要用的时候再获取详细信息，这样可以节省一些网络开销，我们可以设置懒加载，这样只有在需要时才会向数据库获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JoinColumn(name = &quot;detail_id&quot;)</span></span><br><span class="line"><span class="meta">@OneToOne(fetch = FetchType.LAZY)</span>    <span class="comment">//将获取类型改为LAZY</span></span><br><span class="line">AccountDetail detail;</span><br></pre></td></tr></table></figure>

<p>接着我们测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>   <span class="comment">//懒加载属性需要在事务环境下获取，因为repository方法调用完后Session会立即关闭</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pageAccount</span><span class="params">()</span> &#123;</span><br><span class="line">    repository.findById(<span class="number">1</span>).ifPresent(account -&gt; &#123;</span><br><span class="line">        System.out.println(account.getUsername());   <span class="comment">//获取用户名</span></span><br><span class="line">        System.out.println(account.getDetail());  <span class="comment">//获取详细信息（懒加载）</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来看看控制台输出了什么：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hibernate: select account0_.id as id1_0_0_, account0_.detail_id as detail_i4_0_0_, account0_.password as password2_0_0_, account0_.username as username3_0_0_ from users account0_ where account0_.id=?</span><br><span class="line">Test</span><br><span class="line">Hibernate: select accountdet0_.id as id1_1_0_, accountdet0_.address as address2_1_0_, accountdet0_.email as email3_1_0_, accountdet0_.phone as phone4_1_0_, accountdet0_.real_name as real_nam5_1_0_ from users_detail accountdet0_ where accountdet0_.id=?</span><br><span class="line">AccountDetail(id=1, address=四川省成都市青羊区, email=8371289@qq.com, phone=1234567890, realName=卢本)</span><br></pre></td></tr></table></figure>

<p>可以看到，获取用户名之前，并没有去查询用户的详细信息，而是当我们获取详细信息时才进行查询并返回AccountDetail对象。</p>
<p>那么我们是否也可以在添加数据时，利用实体类之间的关联信息，一次性添加两张表的数据呢？可以，但是我们需要稍微修改一下级联关联操作设定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JoinColumn(name = &quot;detail_id&quot;)</span></span><br><span class="line"><span class="meta">@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)</span> <span class="comment">//设置关联操作为ALL</span></span><br><span class="line">AccountDetail detail;</span><br></pre></td></tr></table></figure>

<ul>
<li>ALL：所有操作都进行关联操作</li>
<li>PERSIST：插入操作时才进行关联操作</li>
<li>REMOVE：删除操作时才进行关联操作</li>
<li>MERGE：修改操作时才进行关联操作</li>
</ul>
<p>可以多个并存，接着我们来进行一下测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addAccount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    account.setUsername(<span class="string">&quot;Nike&quot;</span>);</span><br><span class="line">    account.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="type">AccountDetail</span> <span class="variable">detail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountDetail</span>();</span><br><span class="line">    detail.setAddress(<span class="string">&quot;重庆市渝中区解放碑&quot;</span>);</span><br><span class="line">    detail.setPhone(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">    detail.setEmail(<span class="string">&quot;73281937@qq.com&quot;</span>);</span><br><span class="line">    detail.setRealName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  	account.setDetail(detail);</span><br><span class="line">    account = repository.save(account);</span><br><span class="line">    System.out.println(<span class="string">&quot;插入时，自动生成的主键ID为：&quot;</span>+account.getId()+<span class="string">&quot;，外键ID为：&quot;</span>+account.getDetail().getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到日志结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hibernate: insert into users_detail (address, email, phone, real_name) values (?, ?, ?, ?)</span><br><span class="line">Hibernate: insert into users (detail_id, password, username) values (?, ?, ?)</span><br><span class="line">插入时，自动生成的主键ID为：6，外键ID为：3</span><br></pre></td></tr></table></figure>

<p>结束后会发现数据库中两张表都同时存在数据。</p>
<p>接着我们来看一对多关联，比如每个用户的成绩信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JoinColumn(name = &quot;uid&quot;)</span>  <span class="comment">//注意这里的name指的是Score表中的uid字段对应的就是当前的主键，会将uid外键设置为当前的主键</span></span><br><span class="line"><span class="meta">@OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)</span>   <span class="comment">//在移除Account时，一并移除所有的成绩信息，依然使用懒加载</span></span><br><span class="line">List&lt;Score&gt; scoreList;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users_score&quot;)</span>   <span class="comment">//成绩表，注意只存成绩，不存学科信息，学科信息id做外键</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;id&quot;)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToOne</span>   <span class="comment">//一对一对应到学科上</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;cid&quot;)</span></span><br><span class="line">    Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;socre&quot;)</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;uid&quot;)</span></span><br><span class="line">    <span class="type">int</span> uid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;subjects&quot;)</span>   <span class="comment">//学科信息表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;cid&quot;)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="type">int</span> cid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;name&quot;)</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;teacher&quot;)</span></span><br><span class="line">    String teacher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;time&quot;)</span></span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在数据库中填写相应数据，接着我们就可以查询用户的成绩信息了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    repository.findById(<span class="number">1</span>).ifPresent(account -&gt; &#123;</span><br><span class="line">        account.getScoreList().forEach(System.out::println);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功得到用户所有的成绩信息，包括得分和学科信息。</p>
<p>同样的，我们还可以将对应成绩中的教师信息单独分出一张表存储，并建立多对一的关系，因为多门课程可能由同一个老师教授（千万别搞晕了，一定要理清楚关联关系，同时也是考验你的基础扎不扎实）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line"><span class="meta">@JoinColumn(name = &quot;tid&quot;)</span>   <span class="comment">//存储教师ID的字段，和一对一是一样的，也会当前表中创个外键</span></span><br><span class="line">Teacher teacher;</span><br></pre></td></tr></table></figure>

<p>接着就是教师实体类了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;teachers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;id&quot;)</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;name&quot;)</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;sex&quot;)</span></span><br><span class="line">    String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们再进行一下测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    repository.findById(<span class="number">3</span>).ifPresent(account -&gt; &#123;</span><br><span class="line">        account.getScoreList().forEach(score -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;课程名称：&quot;</span>+score.getSubject().getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;得分：&quot;</span>+score.getScore());</span><br><span class="line">            System.out.println(<span class="string">&quot;任课教师：&quot;</span>+score.getSubject().getTeacher().getName());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功得到多对一的教师信息。</p>
<p>最后我们再来看最复杂的情况，现在我们一门课程可以由多个老师教授，而一个老师也可以教授多个课程，那么这种情况就是很明显的多对多场景，现在又该如何定义呢？我们可以像之前一样，插入一张中间表表示教授关系，这个表中专门存储哪个老师教哪个科目：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ManyToMany(fetch = FetchType.LAZY)</span>   <span class="comment">//多对多场景</span></span><br><span class="line"><span class="meta">@JoinTable(name = &quot;teach_relation&quot;,     //多对多中间关联表</span></span><br><span class="line"><span class="meta">        joinColumns = @JoinColumn(name = &quot;cid&quot;),    //当前实体主键在关联表中的字段名称</span></span><br><span class="line"><span class="meta">        inverseJoinColumns = @JoinColumn(name = &quot;tid&quot;)   //教师实体主键在关联表中的字段名称</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line">List&lt;Teacher&gt; teacher;</span><br></pre></td></tr></table></figure>

<p>接着，JPA会自动创建一张中间表，并自动设置外键，我们就可以将多对多关联信息编写在其中了。</p>
<h4 id="JPQL自定义SQL语句"><a href="#JPQL自定义SQL语句" class="headerlink" title="JPQL自定义SQL语句"></a>JPQL自定义SQL语句</h4><p>虽然SpringDataJPA能够简化大部分数据获取场景，但是难免会有一些特殊的场景，需要使用复杂查询才能够去完成，这时你又会发现，如果要实现，只能用回Mybatis了，因为我们需要自己手动编写SQL语句，过度依赖SpringDataJPA会使得SQL语句不可控。</p>
<p>使用JPA，我们也可以像Mybatis那样，直接编写SQL语句，不过它是JPQL语言，与原生SQL语句很类似，但是它是面向对象的，当然我们也可以编写原生SQL语句。</p>
<p>比如我们要更新用户表中指定ID用户的密码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span>    <span class="comment">//DML操作需要事务环境，可以不在这里声明，但是调用时一定要处于事务环境下</span></span><br><span class="line">    <span class="meta">@Modifying</span>     <span class="comment">//表示这是一个DML操作</span></span><br><span class="line">    <span class="meta">@Query(&quot;update Account set password = ?2 where id = ?1&quot;)</span> <span class="comment">//这里操作的是一个实体类对应的表，参数使用?代表，后面接第n个参数</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updatePasswordById</span><span class="params">(<span class="type">int</span> id, String newPassword)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateAccount</span><span class="params">()</span>&#123;</span><br><span class="line">    repository.updatePasswordById(<span class="number">1</span>, <span class="string">&quot;654321&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我想使用原生SQL来实现根据用户名称修改密码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Query(value = &quot;update users set password = :pwd where username = :name&quot;, nativeQuery = true)</span> <span class="comment">//使用原生SQL，和Mybatis一样，这里使用 :名称 表示参数，当然也可以继续用上面那种方式。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updatePasswordByUsername</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String username,   //我们可以使用<span class="meta">@Param</span>指定名称</span></span><br><span class="line"><span class="params">                             <span class="meta">@Param(&quot;pwd&quot;)</span> String newPassword)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateAccount</span><span class="params">()</span>&#123;</span><br><span class="line">    repository.updatePasswordByUsername(<span class="string">&quot;Admin&quot;</span>, <span class="string">&quot;654321&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过编写原生SQL，在一定程度上弥补了SQL不可控的问题。</p>
<p>虽然JPA能够为我们带来非常便捷的开发体验，但是正是因为太便捷了，保姆级的体验有时也会适得其反，尤其是一些国内用到复杂查询业务的项目，可能开发到后期特别庞大时，就只能从底层SQL语句开始进行优化，而由于JPA尽可能地在屏蔽我们对SQL语句的编写，所以后期优化是个大问题，并且Hibernate相对于Mybatis来说，更加重量级。不过，在微服务的时代，单体项目一般不会太大，JPA的劣势并没有太明显地体现出来。</p>
<h3 id="MybatisPlus框架"><a href="#MybatisPlus框架" class="headerlink" title="MybatisPlus框架"></a>MybatisPlus框架</h3><p>前面我们体验了JPA带来的快速开发体验，但是我们发现，面对一些复杂查询时，JPA似乎有点力不从心，反观稍微麻烦一点的Mybatis却能够手动编写SQL，使用起来更加灵活，那么有没有一种既能灵活掌控逻辑又能快速完成开发的持久层框架呢？</p>
<blockquote>
<p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a>（简称 MP）是一个 <a href="https://www.mybatis.org/mybatis-3/">MyBatis</a>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<p>MybatisPlus的愿景是成为 MyBatis 最好的搭档，就像 <a href="https://baomidou.com/img/contra.jpg">魂斗罗</a> 中的 1P、2P，基友搭配，效率翻倍。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/07/21/dUAkeOP9FfVarRL.png" alt="img"></p>
<p>官方网站地址：<a href="https://baomidou.com/">https://baomidou.com</a></p>
<p>MybatisPlus具有以下特性：</p>
<ul>
<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li>
<li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li>
<li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li>
<li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li>
<li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li>
<li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li>
<li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li>
<li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li>
<li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li>
<li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li>
<li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li>
<li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li>
</ul>
<p>框架整体结构如下：</p>
<p><img src="https://s2.loli.net/2023/07/21/fwAQGv43HdRnyI7.jpg" alt="framework"></p>
<p>不过，光说还是不能体会到它带来的便捷性，我们接着就来上手体验一下。</p>
<h4 id="快速上手-1"><a href="#快速上手-1" class="headerlink" title="快速上手"></a>快速上手</h4><p>跟之前一样，还是添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件依然只需要配置数据源即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>然后依然是实体类，可以直接映射到数据库中的表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span>  <span class="comment">//对应的表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span>   <span class="comment">//对应的主键</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="meta">@TableField(&quot;name&quot;)</span>   <span class="comment">//对应的字段</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="meta">@TableField(&quot;email&quot;)</span></span><br><span class="line">    String email;</span><br><span class="line">    <span class="meta">@TableField(&quot;password&quot;)</span></span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，我们就可以编写一个Mapper来操作了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">  	<span class="comment">//使用方式与JPA极其相似，同样是继承一个基础的模版Mapper</span></span><br><span class="line">  	<span class="comment">//这个模版里面提供了预设的大量方法直接使用，跟JPA如出一辙</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们就来写一个简单测试用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    UserMapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(mapper.selectById(<span class="number">1</span>));  <span class="comment">//同样可以直接selectById，非常快速方便</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个Mapper提供的方法还是很丰富的：</p>
<p><img src="https://s2.loli.net/2023/07/21/R7fhN5UtAOPFe4M.png" alt="image-20230721133315171"></p>
<p>后续的板块我们将详细介绍它的使用方式。</p>
<h4 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h4><p>对于一些复杂查询的情况，MybatisPlus支持我们自己构造QueryWrapper用于复杂条件查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();    <span class="comment">//复杂查询可以使用QueryWrapper来完成</span></span><br><span class="line">  	wrapper</span><br><span class="line">            .select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;email&quot;</span>, <span class="string">&quot;password&quot;</span>)    <span class="comment">//可以自定义选择哪些字段</span></span><br><span class="line">            .ge(<span class="string">&quot;id&quot;</span>, <span class="number">2</span>)     			<span class="comment">//选择判断id大于等于1的所有数据</span></span><br><span class="line">            .orderByDesc(<span class="string">&quot;id&quot;</span>);   <span class="comment">//根据id字段进行降序排序</span></span><br><span class="line">    System.out.println(mapper.selectList(wrapper));   <span class="comment">//Mapper同样支持使用QueryWrapper进行查询</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用上面的QueryWrapper对象进行查询，也就等价于下面的SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,email,password <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">2</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>

<p>我们可以在配置中开启SQL日志打印：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>

<p>最后得到的结果如下：</p>
<p><img src="https://s2.loli.net/2023/07/21/FxOfrnERhVPi8tu.png" alt="image-20230721160951500"></p>
<p>有些时候我们遇到需要批处理的情况，也可以直接使用批处理操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//支持批处理操作，我们可以一次性删除多个指定ID的用户</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mapper.deleteBatchIds(List.of(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/07/21/lwaJUF3g2opbWZG.png" alt="image-20230721190139253"></p>
<p>我们也可以快速进行分页查询操作，不过在执行前我们需要先配置一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">      	<span class="comment">//添加分页拦截器到MybatisPlusInterceptor中</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以愉快地使用分页功能了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这里我们将用户表分2页，并获取第一页的数据</span></span><br><span class="line">    Page&lt;User&gt; page = mapper.selectPage(Page.of(<span class="number">1</span>, <span class="number">2</span>), Wrappers.emptyWrapper());</span><br><span class="line">    System.out.println(page.getRecords());   <span class="comment">//获取分页之后的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/07/21/XMPLWB3N6VpHUkG.png" alt="image-20230721185519292"></p>
<p>对于数据更新操作，我们也可以使用UpdateWrapper非常方便的来完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    UpdateWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper</span><br><span class="line">            .set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lbw&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(mapper.update(<span class="literal">null</span>, wrapper));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以快速完成更新操作了：</p>
<p><img src="https://s2.loli.net/2023/07/21/W1e8fFuUwSpi7Cg.png" alt="image-20230721162409308"></p>
<p>QueryWrapper和UpdateWrapper还有专门支持Java 8新增的Lambda表达式的特殊实现，可以直接以函数式的形式进行编写，使用方法是一样的，这里简单演示几个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers</span><br><span class="line">                .&lt;User&gt;lambdaQuery()</span><br><span class="line">                .eq(User::getId, <span class="number">2</span>)   <span class="comment">//比如我们需要选择id为2的用户，前面传入方法引用，后面比的值</span></span><br><span class="line">                .select(User::getName, User::getId);   <span class="comment">//比如我们只需要选择name和id，那就传入对应的get方法引用</span></span><br><span class="line">        System.out.println(mapper.selectOne(wrapper));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过感觉可读性似乎没有不用Lambda高啊。</p>
<h4 id="接口基本操作"><a href="#接口基本操作" class="headerlink" title="接口基本操作"></a>接口基本操作</h4><p>虽然使用MybatisPlus提供的BaseMapper已经很方便了，但是我们的业务中，实际上很多时候也是一样的工作，都是去简单调用底层的Mapper做一个很简单的事情，那么能不能干脆把Service也给弄个模版？MybatisPlus为我们提供了很方便的CRUD接口，直接实现了各种业务中会用到的增删改查操作。</p>
<p>我们只需要继承即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">  	<span class="comment">//除了继承模版，我们也可以把它当成普通Service添加自己需要的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们还需要编写一个实现类，这个实现类就是UserService的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>   <span class="comment">//需要继承ServiceImpl才能实现那些默认的CRUD方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用起来也很方便，整合了超多方法：</p>
<p><img src="https://s2.loli.net/2023/07/21/l5Vkb9dgtJcyL4R.png" alt="image-20230721181359616"></p>
<p>比如我们想批量插入一组用户数据到数据库中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = List.of(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xxx&quot;</span>), <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;yyy&quot;</span>));</span><br><span class="line">  	<span class="comment">//预设方法中已经支持批量保存了，这相比我们直接用for效率高不少</span></span><br><span class="line">    service.saveBatch(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有更加方便快捷的保存或更新操作，当数据不存在时（通过主键ID判断）则插入新数据，否则就更新数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    service.saveOrUpdate(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;aaa&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以直接使用Service来进行链式查询，写法非常舒服：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">one</span> <span class="operator">=</span> service.query().eq(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>).one();</span><br><span class="line">    System.out.println(one);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新版代码生成器"><a href="#新版代码生成器" class="headerlink" title="新版代码生成器"></a>新版代码生成器</h4><p>最后我们再来隆重介绍一下MybatisPlus的代码生成器，这个东西可谓是拯救了千千万万学子的毕设啊。</p>
<p>它能够根据数据库做到代码的一键生成，能做到什么程度呢？</p>
<p><img src="https://s2.loli.net/2023/07/21/lGT4g5Y6Heqavsw.png" alt="image-20230721200757985"></p>
<p>你没看错，整个项目从Mapper到Controller，所有的东西全部都给你生成好了，你只管把需要补充的业务给写了就行，这是真正的把饭给喂到你嘴边的行为，是广大学子的毕设大杀器。</p>
<p>那么我们就来看看，这玩意怎么去用的，首先我们需要先把整个项目的数据库给创建好，创建好之后，我们继续下一步，这里我们从头开始创建一个项目，感受一下它的强大，首先创建一个普通的SpringBoot项目：</p>
<p><img src="https://s2.loli.net/2023/07/21/bIZ9D2cA7XsgSoU.png" alt="image-20230721202019230"></p>
<p>接着我们导入一会需要用到的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后再配置一下数据源：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>接着我们就可以开始编写自动生成脚本了，这里依然选择测试类，用到<code>FastAutoGenerator</code>作为生成器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">      FastAutoGenerator</span><br><span class="line">        			<span class="comment">//首先使用create来配置数据库链接信息</span></span><br><span class="line">              .create(<span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>.Builder(dataSource))</span><br><span class="line">              .execute();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>接着我们配置一下全局设置，这些会影响一会生成的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    FastAutoGenerator</span><br><span class="line">            .create(<span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>.Builder(dataSource))</span><br><span class="line">            .globalConfig(builder -&gt; &#123;</span><br><span class="line">                builder.author(<span class="string">&quot;lbw&quot;</span>);              <span class="comment">//作者信息，一会会变成注释</span></span><br><span class="line">                builder.commentDate(<span class="string">&quot;2024-01-01&quot;</span>);  <span class="comment">//日期信息，一会会变成注释</span></span><br><span class="line">                builder.outputDir(<span class="string">&quot;src/main/java&quot;</span>); <span class="comment">//输出目录设置为当前项目的目录</span></span><br><span class="line">            &#125;)</span><br><span class="line">            .execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是打包设置，也就是项目的生成的包等等，这里简单配置一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    FastAutoGenerator</span><br><span class="line">            ...</span><br><span class="line">      			<span class="comment">//打包设置，这里设置一下包名就行，注意跟我们项目包名设置为一致的</span></span><br><span class="line">      			.packageConfig(builder -&gt; builder.parent(<span class="string">&quot;com.example&quot;</span>))</span><br><span class="line">      			.strategyConfig(builder -&gt; &#123;</span><br><span class="line">                    <span class="comment">//设置为所有Mapper添加@Mapper注解</span></span><br><span class="line">                    builder</span><br><span class="line">                            .mapperBuilder()</span><br><span class="line">                            .mapperAnnotation(Mapper.class)</span><br><span class="line">                            .build();</span><br><span class="line">            &#125;)</span><br><span class="line">            .execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们就可以直接执行了这个脚本了：</p>
<p><img src="https://s2.loli.net/2023/07/21/SdDRqZPnNrkeKjG.png" alt="image-20230721203819514"></p>
<p>现在，可以看到我们的项目中已经出现自动生成代码了：</p>
<p><img src="https://s2.loli.net/2023/07/21/pKMnwFZEOBmLXDy.png" alt="image-20230721204011913"></p>
<p>我们也可以直接运行这个项目：</p>
<p><img src="https://s2.loli.net/2023/07/21/CEdRz5wgaoxUjFJ.png" alt="image-20230721210417345"></p>
<p>速度可以说是非常之快，一个项目模版就搭建完成了，我们只需要接着写业务就可以了，当然如果各位小伙伴需要更多定制化的话，可以在官网查看其他的配置：<a href="https://baomidou.com/pages/981406/">https://baomidou.com/pages/981406/</a></p>
<p>对于一些有特殊要求的用户来说，我们希望能够以自己的模版来进行生产，怎么才能修改它自动生成的代码模版呢，我们可以直接找到<code>mybatis-plus-generator</code>的源码：</p>
<p><img src="https://s2.loli.net/2023/07/21/lxaBgGPubOkptCT.png" alt="image-20230721204530505"></p>
<p>生成模版都在在这个里面有写，我们要做的就是去修改这些模版，变成我们自己希望的样子，由于默认的模版解析引擎为Velocity，我们需要复制以<code>.vm</code>结尾的文件到<code>resource</code>随便一个目录中，然后随便改：</p>
<p><img src="https://s2.loli.net/2023/07/21/gZlbG9JDIa3kSMO.png" alt="image-20230721210716832"></p>
<p>接着我们配置一下模版：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    FastAutoGenerator</span><br><span class="line">            ...</span><br><span class="line">      			.strategyConfig(builder -&gt; &#123;</span><br><span class="line">                builder</span><br><span class="line">                        .mapperBuilder()</span><br><span class="line">                        .enableFileOverride()   <span class="comment">//开启文件重写，自动覆盖新的</span></span><br><span class="line">                        .mapperAnnotation(Mapper.class)</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;)</span><br><span class="line">            .templateConfig(builder -&gt; &#123;</span><br><span class="line">                builder.mapper(<span class="string">&quot;/template/mapper.java.vm&quot;</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">            .execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，新生成的代码中就是按照我们自己的模版来定义了:</p>
<p><img src="https://s2.loli.net/2023/07/21/K6DufSwG3hdqPsr.png" alt="image-20230721211002961"></p>
<p>有了代码生成器，我们工 (划) 作 (水) 效率更上一层楼啦~</p>
<h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><p>前后端分离是一种软件架构模式，它将前端和后端的开发职责分开，使得前端和后端可以独立进行开发、测试和部署。在之前，我们都是编写Web应用程序，但是随着时代发展，各种桌面App、手机端App还有小程序层出不穷，这都完全脱离我们之前的开发模式，客户端和服务端的划分越来越明显，前后端分离开发势在必行。</p>
<p>在前后端分离架构中，前端主要负责展示层的开发，包括用户界面的设计、用户交互的实现等。前端使用一些技术栈，如Vue、React等技术来实现用户界面，同时通过Ajax、Axios等技术与后端进行数据的交互，这样前端无论使用什么技术进行开发，都与后端无关，受到的限制会小很多。</p>
<p>后端主要负责业务逻辑的处理和数据的存储，包括用户认证、数据验证、数据处理、数据库访问等，我们在SSM阶段就已经给各位小伙伴介绍过了前后端开发的相关思路了，实际上后端只需要返回前端需要的数据即可，我们一般使用JSON格式进行返回。</p>
<p>前后端分离架构的优势包括：</p>
<ul>
<li>前后端可以同时独立进行开发，提高开发效率。</li>
<li>前端可以灵活选择技术栈和框架，提供更好的用户体验。</li>
<li>后端可以专注于业务逻辑的实现，提高代码的可维护性。</li>
<li>前后端通过接口进行通信，使得前端和后端可以分别进行部署，提高系统的可扩展性和灵活性。</li>
</ul>
<p><img src="https://s2.loli.net/2023/07/22/8Zxp5PVjN7zfn6b.png" alt="image-20230722122002573"></p>
<p>然而，前后端分离架构也存在一些挑战，包括接口设计的复杂性、前后端协作的沟通成本等。因此，在选择前后端分离架构时，需要综合考虑项目的特点和团队成员的技能，以及开发周期等因素。</p>
<p>我们介绍两种实现前后端分离的方案。</p>
<h3 id="基于Session的分离（有状态）"><a href="#基于Session的分离（有状态）" class="headerlink" title="基于Session的分离（有状态）"></a>基于Session的分离（有状态）</h3><p>基于Cookie的前后端分离是最简单的一种，也是更接近我们之前学习的一种。在之前，我们都是使用SpringSecurity提供的默认登录流程完成验证。</p>
<p>我们发现，实际上SpringSecurity在登录之后，会利用Session机制记录用户的登录状态，这就要求我们每次请求的时候都需要携带Cookie才可以，因为Cookie中存储了用于识别的JSESSIONID数据。因此，要实现前后端分离，我们只需要稍微修改一下就可以实现了，这对于小型的单端应用程序非常友好。</p>
<h4 id="学习环境搭建"><a href="#学习环境搭建" class="headerlink" title="学习环境搭建"></a>学习环境搭建</h4><p>考虑到各位小伙伴没有学习过Vue等前端框架，这里我们依然使用前端模版进行魔改。只不过现在我们的前端页面需要单独进行部署，而不是和后端揉在一起，这里我们需要先创建一个前端项目，依赖只需勾选SpringWeb即可，主要用作反向代理前端页面：</p>
<p><img src="https://s2.loli.net/2023/07/22/A7gTxwv6r89tKh3.png" alt="image-20230722151228110"></p>
<p>如果各位小伙伴学习了Nginx代理，使用Nginx代理前端项目会更好一些。</p>
<p>接着我们将所有的前端模版文件全部丢进对应的目录中，创建一个<code>web</code>目录到resource目录下，然后放入我们前端模版的全部文件：</p>
<p><img src="https://s2.loli.net/2023/07/22/DtLF21ue7RVMQPY.png" alt="image-20230722154349756"></p>
<p>然后配置一下静态资源代理，现在我们希望的是页面直接被代理，不用我们手动去写Controller来解析视图：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">static-locations:</span> <span class="string">classpath:/web</span></span><br></pre></td></tr></table></figure>

<p>然后启动服务器就行了：</p>
<p><img src="https://s2.loli.net/2023/07/22/65snkmhyjFENTxt.png" alt="image-20230722154452928"></p>
<p>接着我们就可以随便访问我们的网站了：</p>
<p><img src="https://s2.loli.net/2023/07/22/GEWekp2IwMZhx5c.png" alt="image-20230722154659328"></p>
<p>这样前端页面就部署完成了，接着我们还需要创建一个后端项目，用于去编写我们的后端，选上我们需要的一些依赖：</p>
<p><img src="https://s2.loli.net/2023/07/22/vt52ogbLp8YN1Im.png" alt="image-20230722155049948"></p>
<p>接着我们需要修改一下后端服务器的端口，因为现在我们要同时开两个服务器，一个是负责部署前端的，一个是负责部署后端的，这样就是标准的前后端分离了，所以说为了防止端口打架，我们就把端口开放在8081上：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>

<p>现在启动这两个服务器，我们的学习环境就搭建好了。</p>
<h4 id="实现登录授权和跨域处理"><a href="#实现登录授权和跨域处理" class="headerlink" title="实现登录授权和跨域处理"></a>实现登录授权和跨域处理</h4><p>在之前，我们的登录操作以及登录之后的页面跳转都是由SpringSecurity来完成，但是现在前后端分离之后，整个流程发生了变化，现在前端仅仅是调用登录接口进行一次校验即可，而后端只需要返回本次校验的结果，由前端来判断是否校验成功并跳转页面：</p>
<p><img src="https://s2.loli.net/2023/07/22/yZpHd4wcikVxhta.png" alt="image-20230722164431249"></p>
<p>因此，现在我们只需要让登录模块响应一个JSON数据告诉前端登录成功与否即可，当然，前端在发起请求的时候依然需要携带Cookie信息，否则后端不认识是谁。</p>
<p>现在我们就来尝试实现一下这种模式，首先我们配置一下SpringSecurity的相关接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> http</span><br><span class="line">                .authorizeHttpRequests(conf -&gt; &#123;</span><br><span class="line">                    conf.anyRequest().authenticated();</span><br><span class="line">                &#125;)</span><br><span class="line">                .formLogin(conf -&gt; &#123;</span><br><span class="line">                  	<span class="comment">//一般分离之后，为了统一规范接口，使用 /api/模块/功能 的形式命名接口</span></span><br><span class="line">                    conf.loginProcessingUrl(<span class="string">&quot;/api/auth/login&quot;</span>);</span><br><span class="line">                    conf.permitAll();</span><br><span class="line">                &#125;)</span><br><span class="line">                .csrf(AbstractHttpConfigurer::disable)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这样成功定义了登录接口相关内容，但是怎么才能让SpringSecurity在登录成功之后返回一个JSON数据给前端而不是默认的重定向呢？这时我们可以手动设置SuccessHandler和FailureHandler来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="keyword">return</span> http</span><br><span class="line">              ...</span><br><span class="line">              .formLogin(conf -&gt; &#123;</span><br><span class="line">                  conf.loginProcessingUrl(<span class="string">&quot;/api/auth/login&quot;</span>);</span><br><span class="line">                	<span class="comment">//使用自定义的成功失败处理器</span></span><br><span class="line">                  conf.failureHandler(<span class="built_in">this</span>::onAuthenticationFailure);</span><br><span class="line">                  conf.successHandler(<span class="built_in">this</span>::onAuthenticationSuccess);</span><br><span class="line">                  conf.permitAll();</span><br><span class="line">              &#125;)</span><br><span class="line">              ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义成功失败处理器</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                               HttpServletResponse response,</span></span><br><span class="line"><span class="params">                               AuthenticationException exception)</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                               HttpServletResponse response, </span></span><br><span class="line"><span class="params">                               Authentication authentication)</span> &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>现在我们需要返回一个标准的JSON格式数据作为响应，这里我们根据Rest API标准来进行编写：</p>
<blockquote>
<p>REST API是遵循REST（Representational State Transfer, 表述性状态转移）原则的Web服务接口，下面简单介绍一下REST接口规范以及对应的响应数据该如何编写:</p>
<h3 id="1-REST接口规范"><a href="#1-REST接口规范" class="headerlink" title="1. REST接口规范"></a>1. REST接口规范</h3><ul>
<li><strong>使用HTTP方法</strong>：GET（检索资源）、POST（创建资源）、PUT（更新资源）、DELETE（删除资源）。</li>
<li><strong>无状态</strong>: REST接口要求实现无状态从而使其独立于之前的请求。</li>
<li><strong>使用正确的HTTP状态码</strong>：在HTTP响应中反馈操作的结果（例如，200表示成功，404表示资源不存在等）。</li>
<li><strong>URI 应该清晰易懂</strong>：URI应能清晰地指示出所引用资源的类型和编号，并能易于理解和使用。</li>
</ul>
<h3 id="2-响应数据格式"><a href="#2-响应数据格式" class="headerlink" title="2. 响应数据格式"></a>2. 响应数据格式</h3><p>REST应答一般使用的格式为JSON，以下是一个标准的JSON响应数据样例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Tom&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">18</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;查询成功&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>字段的含义分别为：</p>
<ul>
<li><strong>code</strong>：HTTP状态码，表示请求的结果。常见的有200（成功）、400（客户端错误）、500（服务器错误）等。</li>
<li><strong>data</strong>：响应的真实数据。在上例中，是一个包含用户信息的对象。</li>
<li><strong>message</strong>：请求响应信息，常用于描述请求处理结果。</li>
</ul>
<p>上述都是建议的最佳实践，实际应用中可以根据具体的业务需求进行适当的调整。</p>
</blockquote>
<p>这里我们创建一个实体类来装载响应数据，可以使用记录类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">RestBean</span>&lt;T&gt; (<span class="type">int</span> code, T data, String message) &#123;</span><br><span class="line">		<span class="comment">//写几个工具方法，用于快速创建RestBean对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestBean&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestBean</span>&lt;&gt;(<span class="number">200</span>, data, <span class="string">&quot;请求成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestBean&lt;T&gt; <span class="title function_">failure</span><span class="params">(<span class="type">int</span> code, String message)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestBean</span>&lt;&gt;(code, <span class="literal">null</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; RestBean&lt;T&gt; <span class="title function_">failure</span><span class="params">(<span class="type">int</span> code)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> failure(code, <span class="string">&quot;请求失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//将当前对象转换为JSON格式的字符串用于返回</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">asJsonString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JSONObject.toJSONString(<span class="built_in">this</span>, JSONWriter.Feature.WriteNulls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们稍微设置一下对应的Handler即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                               HttpServletResponse response,</span></span><br><span class="line"><span class="params">                               AuthenticationException exception)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    	response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">      <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">      writer.write(RestBean.failure(<span class="number">401</span>, exception.getMessage()).asJsonString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                               HttpServletResponse response,</span></span><br><span class="line"><span class="params">                               Authentication authentication)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    	response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">      <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">      writer.write(RestBean.success(authentication.getName()).asJsonString());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>现在我们就可以使用API测试工具来调试一下了：</p>
<p><img src="https://s2.loli.net/2023/07/23/EiMUuCjcKpnOmRb.png" alt="image-20230723193442527"></p>
<p>可以看到响应的结果是标准的JSON格式数据，而不是像之前那样重定向到一个页面，这样前端发起的异步请求就可以进行快速判断了。</p>
<p>我们来尝试写一个简单的前端逻辑试试看，这里依然引入Axios框架来发起异步请求：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios@1.1.2/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        axios.<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:8081/api/auth/login&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">username</span>: <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username&#x27;</span>).<span class="property">value</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">password</span>: <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;password&#x27;</span>).<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">        &#125;, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">headers</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">          	<span class="attr">withCredentials</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">        &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(data.<span class="property">code</span> === <span class="number">200</span>) &#123;  <span class="comment">//通过状态码进行判断</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;/index.html&#x27;</span>  <span class="comment">//登录成功进入主页</span></span></span><br><span class="line"><span class="language-javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&#x27;登录失败：&#x27;</span>+data.<span class="property">message</span>)   <span class="comment">//登录失败返回弹窗</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可能会有小伙伴好奇，这个前端不是每个页面都能随便访问吗，这登录跟不登录有啥区别？实际上我们的前端开发者会在前端做相应的路由以及拦截来控制页面的跳转，我们后端开发者无需担心，我们只需要保证自己返回的数据是准确无误的即可，其他的交给前端小姐姐就好，这里我们只是做个样子。</p>
<p>当点击按钮时就能发起请求了，但是我们现在遇到了一个新的问题：</p>
<p><img src="https://s2.loli.net/2023/07/23/KYULQNoFsHbm3zg.png" alt="image-20230723190406008"></p>
<p>我们在发起登录请求时，前端得到了一个跨域请求错误，这是因为我们前端的站点和后端站点不一致导致的，浏览器为了用户的安全，防止网页中一些恶意脚本跨站请求数据，会对未经许可的跨域请求发起拦截。那么，我们怎么才能让这个请求变成我们许可的呢？对于跨域问题，是属于我们后端需要处理的问题，跟前端无关，我们需要在响应的时候，在响应头中添加一些跨域属性，来告诉浏览器从哪个站点发来的跨域请求是安全的，这样浏览器就不会拦截了。</p>
<p>那么如何进行配置呢，我们现在使用了SpringSecurity框架，可以直接进行跨域配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> http</span><br><span class="line">            ...</span><br><span class="line">            .cors(conf -&gt; &#123;</span><br><span class="line">                <span class="type">CorsConfiguration</span> <span class="variable">cors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">              	<span class="comment">//添加前端站点地址，这样就可以告诉浏览器信任了</span></span><br><span class="line">              	cors.addAllowedOrigin(<span class="string">&quot;http://localhost:8080&quot;</span>);</span><br><span class="line">                <span class="comment">//虽然也可以像这样允许所有 cors.addAllowedOriginPattern(&quot;*&quot;);</span></span><br><span class="line">              	<span class="comment">//但是这样并不安全，我们应该只许可给我们信任的站点</span></span><br><span class="line">                cors.setAllowCredentials(<span class="literal">true</span>);  <span class="comment">//允许跨域请求中携带Cookie</span></span><br><span class="line">                cors.addAllowedHeader(<span class="string">&quot;*&quot;</span>);   <span class="comment">//其他的也可以配置，为了方便这里就 * 了</span></span><br><span class="line">                cors.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                cors.addExposedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">                source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, cors);  <span class="comment">//直接针对于所有地址生效</span></span><br><span class="line">                conf.configurationSource(source);</span><br><span class="line">            &#125;)</span><br><span class="line">            ...</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当我们再次重启服务器，返回的响应头中都会携带跨域相关的信息，这样浏览器就不会进行拦截了：</p>
<p><img src="https://s2.loli.net/2023/07/23/QVFEWknMdujomqi.png" alt="image-20230723192217101"></p>
<p>这样就可以实现前后端分离的登录模式了：</p>
<p><img src="https://s2.loli.net/2023/07/23/1GpZuQUawM48eVq.png" alt="image-20230723194030641"></p>
<p>由于记住我功能和退出登录操作跟之前是一样的配置，这里我们就不进行演示了。</p>
<h4 id="响应JSON化"><a href="#响应JSON化" class="headerlink" title="响应JSON化"></a>响应JSON化</h4><p>前面我们完成了前后端分离的登录模式，我们来看看一般的业务接口该如何去实现，比如这里我们写一个非常简单的的用户名称获取接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span>   <span class="comment">//为了方便，我们一律使用RestController，这样每个请求默认都返回JSON对象</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/user&quot;)</span>   <span class="comment">//用户相关的接口，路径可以设置为/api/user/xxxx</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/name&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestBean&lt;String&gt; <span class="title function_">username</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">        <span class="keyword">return</span> RestBean.success(user.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样前端就可以在登录之后获取到这个接口的结果了，注意一定要在请求时携带Cookie，否则服务端无法识别身份，会直接被拦截并重定向：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:8081/api/user/name&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">withCredentials</span>: <span class="literal">true</span>  <span class="comment">//携带Cookie访问，不然服务器不认识我们</span></span></span><br><span class="line"><span class="language-javascript">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username&#x27;</span>).<span class="property">innerText</span> = data.<span class="property">data</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意一定要登录之后再请求，成功的请求结果如下：</p>
<p><img src="https://s2.loli.net/2023/07/24/L4PcVKpO2nmHG7e.png" alt="image-20230724000237828"></p>
<p>不过我们发现，我们的一些响应还是不完善，比如用户没有登录，默认还是会302重定向，但是实际上我们只需要告诉前端没有登录就行了，所以说我们修改一下未登录状态下返回的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> http</span><br><span class="line">            ...</span><br><span class="line">            .exceptionHandling(conf -&gt; &#123;</span><br><span class="line">              	<span class="comment">//配置授权相关异常处理器</span></span><br><span class="line">                conf.accessDeniedHandler(<span class="built_in">this</span>::onAccessDeny);</span><br><span class="line">              	<span class="comment">//配置验证相关异常的处理器</span></span><br><span class="line">                conf.authenticationEntryPoint(<span class="built_in">this</span>::onAuthenticationFailure);</span><br><span class="line">            &#125;)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在有三个方法，但是实际上功能都是一样的，我们可以把它们整合为同一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleProcess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                     HttpServletResponse response,</span></span><br><span class="line"><span class="params">                     Object exceptionOrAuthentication)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">      <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">      <span class="keyword">if</span>(exceptionOrAuthentication <span class="keyword">instanceof</span> AccessDeniedException exception) &#123;</span><br><span class="line">          writer.write(RestBean.failure(<span class="number">403</span>, exception.getMessage()).asJsonString());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(exceptionOrAuthentication <span class="keyword">instanceof</span> Exception exception) &#123;</span><br><span class="line">          writer.write(RestBean.failure(<span class="number">401</span>, exception.getMessage()).asJsonString());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(exceptionOrAuthentication <span class="keyword">instanceof</span> Authentication authentication)&#123;</span><br><span class="line">          writer.write(RestBean.success(authentication.getName()).asJsonString());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这样，用户在没有登录的情况下，请求接口就会返回我们的自定义JSON信息了：</p>
<p><img src="https://s2.loli.net/2023/07/24/Rf9BSVLvih1lOE2.png" alt="image-20230724002459523"></p>
<p>对于我们页面中的一些常见的异常，我们也可以编写异常处理器来将其规范化返回，比如404页面，我们可以直接配置让其抛出异常：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">throw-exception-if-no-handler-found:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">add-mappings:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>然后编写异常处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> RestBean&lt;String&gt; <span class="title function_">error</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> NoHandlerFoundException exception)  <span class="comment">//这里就大概处理一下404就行</span></span><br><span class="line">            <span class="keyword">return</span> RestBean.failure(<span class="number">404</span>, e.getMessage());  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ServletException exception)  <span class="comment">//其他的Servlet异常就返回400状态码</span></span><br><span class="line">            <span class="keyword">return</span> RestBean.failure(<span class="number">400</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> RestBean.failure(<span class="number">500</span>, e.getMessage());  <span class="comment">//其他异常直接返回500</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们的后端就返回的是非常统一的JSON格式数据了，前端开发人员只需要根据我们返回的数据编写统一的处理即可，基于Session的前后端分离实现起来也是最简单的，几乎没有多少的学习成本，跟我们之前的使用是一样的，只是现在前端单独编写了而已。</p>
<h3 id="基于Token的分离（无状态）"><a href="#基于Token的分离（无状态）" class="headerlink" title="基于Token的分离（无状态）"></a>基于Token的分离（无状态）</h3><p>基于Token的前后端分离主打无状态，无状态服务是指在处理每个请求时，服务本身不会维持任何与请求相关的状态信息。每个请求被视为独立的、自包含的操作，服务只关注处理请求本身，而不关心前后请求之间的状态变化。也就是说，用户在发起请求时，服务器不会记录其信息，而是通过用户携带的Token信息来判断是哪一个用户：</p>
<ul>
<li>有状态：用户请求接口 -&gt;  从Session中读取用户信息  -&gt;   根据当前的用户来处理业务   -&gt;  返回</li>
<li>无状态：用户携带Token请求接口    -&gt;   从请求中获取用户信息   -&gt;   根据当前的用户来处理业务   -&gt;  返回</li>
</ul>
<p>无状态服务的优点包括：</p>
<ol>
<li>服务端无需存储会话信息：传统的会话管理方式需要服务端存储用户的会话信息，包括用户的身份认证信息和会话状态。而使用Token，服务端无需存储任何会话信息，所有的认证信息都包含在Token中，使得服务端变得无状态，减轻了服务器的负担，同时也方便了服务的水平扩展。</li>
<li>减少网络延迟：传统的会话管理方式需要在每次请求中都携带会话标识，即使是无状态的RESTful API也需要携带身份认证信息。而使用Token，身份认证信息已经包含在Token中，只需要在请求的Authorization头部携带Token即可，减少了每次请求的数据量，减少了网络延迟。</li>
<li>客户端无需存储会话信息：传统的会话管理方式中，客户端需要存储会话标识，以便在每次请求中携带。而使用Token，客户端只需要保存Token即可，方便了客户端的存储和管理。</li>
<li>跨域支持：Token可以在各个不同的域名之间进行传递和使用，因为Token是通过签名来验证和保护数据完整性的，可以防止未经授权的修改。</li>
</ol>
<p>这一部分，我们将深入学习目前比较主流的基于Token的前后端分离方案。</p>
<h4 id="认识JWT令牌"><a href="#认识JWT令牌" class="headerlink" title="认识JWT令牌"></a>认识JWT令牌</h4><p>在认识Token前后端分离之前，我们需要先学习最常见的JWT令牌，官网：<a href="https://jwt.io/">https://jwt.io</a></p>
<p>JSON Web Token令牌（JWT）是一个开放标准（<a href="https://tools.ietf.org/html/rfc7519">RFC 7519</a>），它定义了一种紧凑和自成一体的方式，用于在各方之间作为JSON对象安全地传输信息。这些信息可以被验证和信任，因为它是数字签名的。JWT可以使用密钥（使用<strong>HMAC</strong>算法）或使用<strong>RSA</strong>或<strong>ECDSA</strong>进行公钥&#x2F;私钥对进行签名。</p>
<p>JWT令牌的格式如下：</p>
<p><img src="https://s2.loli.net/2023/03/07/Xu8lxYhKoJNr6it.png" alt="image-20230307000004710"></p>
<p>一个JWT令牌由3部分组成：标头(Header)、有效载荷(Payload)和签名(Signature)。在传输的时候，会将JWT的钱2部分分别进行Base64编码后用<code>.</code>进行连接形成最终需要传输的字符串。</p>
<ul>
<li>标头：包含一些元数据信息，比如JWT签名所使用的加密算法，还有类型，这里统一都是JWT。</li>
<li>有效载荷：包括用户名称、令牌发布时间、过期时间、JWT ID等，当然我们也可以自定义添加字段，我们的用户信息一般都在这里存放。</li>
<li>签名：首先需要指定一个密钥，该密钥仅仅保存在服务器中，保证不能让其他用户知道。然后使用Header中指定的算法对Header和Payload进行base64加密之后的结果通过密钥计算哈希值，然后就得出一个签名哈希。这个会用于之后验证内容是否被篡改。</li>
</ul>
<p>这里还是补充一下一些概念，因为很多东西都是我们之前没有接触过的：</p>
<ul>
<li><p><strong>Base64：</strong>就是包括小写字母a-z、大写字母A-Z、数字0-9、符号”+”、”&#x2F;“一共64个字符的字符集（末尾还有1个或多个<code>=</code>用来凑够字节数），任何的符号都可以转换成这个字符集中的字符，这个转换过程就叫做Base64编码，编码之后会生成只包含上述64个字符的字符串。相反，如果需要原本的内容，我们也可以进行Base64解码，回到原有的样子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;你们可能不知道只用20万赢到578万是什么概念&quot;</span>;</span><br><span class="line">  	<span class="comment">//Base64不只是可以对字符串进行编码，任何byte[]数据都可以，编码结果可以是byte[]，也可以是字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">encodeStr</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(str.getBytes());</span><br><span class="line">    System.out.println(<span class="string">&quot;Base64编码后的字符串：&quot;</span>+encodeStr);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;解码后的字符串：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(Base64.getDecoder().decode(encodeStr)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意Base64不是加密算法，只是一种信息的编码方式而已。</p>
</li>
<li><p><strong>加密算法：</strong>加密算法分为对称加密和非对称加密，其中<strong>对称加密（Symmetric Cryptography）</strong>比较好理解，就像一把锁配了两把钥匙一样，这两把钥匙你和别人都有一把，然后你们直接传递数据，都会把数据用锁给锁上，就算传递的途中有人把数据窃取了，也没办法解密，因为钥匙只有你和对方有，没有钥匙无法进行解密，但是这样有个问题，既然解密的关键在于钥匙本身，那么如果有人不仅窃取了数据，而且对方那边的治安也不好，于是顺手就偷走了钥匙，那你们之间发的数据不就凉凉了吗。</p>
<p>因此，<strong>非对称加密（Asymmetric Cryptography）</strong>算法出现了，它并不是直接生成一把钥匙，而是生成一个公钥和一个私钥，私钥只能由你保管，而公钥交给对方或是你要发送的任何人都行，现在你需要把数据传给对方，那么就需要使用私钥进行加密，但是，这个数据只能使用对应的公钥进行解密，相反，如果对方需要给你发送数据，那么就需要用公钥进行加密，而数据只能使用私钥进行解密，这样的话就算对方的公钥被窃取，那么别人发给你的数据也没办法解密出来，因为需要私钥才能解密，而只有你才有私钥。</p>
<p>因此，非对称加密的安全性会更高一些，包括HTTPS的隐私信息正是使用非对称加密来保障传输数据的安全（当然HTTPS并不是单纯地使用非对称加密完成的，感兴趣的可以去了解一下）</p>
<p>对称加密和非对称加密都有很多的算法，比如对称加密，就有：DES、IDEA、RC2，非对称加密有：RSA、DAS、ECC</p>
</li>
<li><p><strong>不可逆加密算法：</strong>常见的不可逆加密算法有MD5, HMAC, SHA-1, SHA-224, SHA-256, SHA-384, 和SHA-512, 其中SHA-224、SHA-256、SHA-384，和SHA-512我们可以统称为SHA2加密算法，SHA加密算法的安全性要比MD5更高，而SHA2加密算法比SHA1的要高，其中SHA后面的数字表示的是加密后的字符串长度，SHA1默认会产生一个160位的信息摘要。经过不可逆加密算法得到的加密结果，是无法解密回去的，也就是说加密出来是什么就是什么了。本质上，其就是一种哈希函数，用于对一段信息产生摘要，以<strong>防止被篡改</strong>。</p>
<p>实际上这种算法就常常被用作信息摘要计算，同样的数据通过同样的算法计算得到的结果肯定也一样，而如果数据被修改，那么计算的结果肯定就不一样了。</p>
</li>
</ul>
<p>因此，JWT令牌实际上是一种经过加密的JSON数据，其中包含了用户名字、用户ID等信息，我们可以直接解密JWT令牌得到用户的信息，我们可以写一个小测试来看看，导入JWT支持库依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要生成一个JWT令牌非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwtKey</span> <span class="operator">=</span> <span class="string">&quot;abcdefghijklmn&quot;</span>;                 <span class="comment">//使用一个JWT秘钥进行加密</span></span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(jwtKey);  <span class="comment">//创建HMAC256加密算法对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> JWT.create()</span><br><span class="line">                .withClaim(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>)   <span class="comment">//向令牌中塞入自定义的数据</span></span><br><span class="line">                .withClaim(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lbw&quot;</span>)</span><br><span class="line">                .withClaim(<span class="string">&quot;role&quot;</span>, <span class="string">&quot;nb&quot;</span>)</span><br><span class="line">                .withExpiresAt(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2024</span>, Calendar.FEBRUARY, <span class="number">1</span>))  <span class="comment">//JWT令牌的失效时间</span></span><br><span class="line">                .withIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())   <span class="comment">//JWT令牌的签发时间</span></span><br><span class="line">                .sign(algorithm);    <span class="comment">//使用上面的加密算法进行加密，完成签名</span></span><br><span class="line">        System.out.println(jwtToken);   <span class="comment">//得到最终的JWT令牌</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后得到的JWT令牌就长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjoibmIiLCJuYW1lIjoibGJ3IiwiaWQiOjEsImV4cCI6NjE2NjQ4NjA4MDAsImlhdCI6MTY5MDEzMTQ3OH0.KUuGKM0OynL_DEUnRIETDBlmGjoqbt_5dP2r21ZDE1s</span><br></pre></td></tr></table></figure>

<p>我们可以使用Base64将其还原为原本的样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> <span class="string">&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjoibmIiLCJuYW1lIjoibGJ3IiwiaWQiOjEsImV4cCI6NjE2NjQ4NjA4MDAsImlhdCI6MTY5MDEzMTQ3OH0.KUuGKM0OynL_DEUnRIETDBlmGjoqbt_5dP2r21ZDE1s&quot;</span>;</span><br><span class="line">        String[] split = jwtToken.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; split.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> split[i];</span><br><span class="line">            <span class="type">byte</span>[] decode = Base64.getDecoder().decode(s);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(decode));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析前面两个部分得到：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span><span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span><span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span><span class="string">&quot;HS256&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;role&quot;</span><span class="punctuation">:</span><span class="string">&quot;nb&quot;</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;lbw&quot;</span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span><span class="number">61664860800</span><span class="punctuation">,</span><span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span><span class="number">1690131478</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到确实是经过Base64加密的JSON格式数据，包括我们的自定义数据也在其中，而我们可以直接使用JWT令牌来作为我们权限校验的核心，我们可以像这样设计我们的系统：</p>
<p><img src="https://s2.loli.net/2023/07/24/4bThtMwA9XsP5uc.png" alt="image-20230724010807761"></p>
<p>首先用户还是按照正常流程进行登录，只不过用户在登录成功之后，服务端会返回一个JWT令牌用于后续请求使用，由于JWT令牌具有时效性，所以说当过期之后又需要重新登录。就像我们进入游乐园需要一张门票一样，只有持有游乐园门票才能进入游乐园游玩，如果没有门票就会被拒之门外，而游乐园门票也有时间限制，如果已经过期，我们也是没有办法进入游乐园的。</p>
<p>所以，我们只需要在后续请求中携带这个Token即可（可以放在Cookie中，也可以放在请求头中）这样服务器就可以直接从Token中解密读取到我们用户的相关信息以及判断用户是否登录过期了。</p>
<p>不过这个时候会有小伙伴疑问，既然现在用户信息都在JWT中，那要是用户随便修改里面的内容，岂不是可以以任意身份访问服务器了？这会不会存在安全隐患？对于这个问题，前面我们已经说的很清楚了，JWT实际上最后会有一个加密的签名，这个是根据秘钥+JWT本体内容计算得到的，用户在没有持有秘钥的情况下，是不可能计算得到正确的签名的，所以说服务器会在收到JWT时对签名进行重新计算，比较是否一致，来验证JWT是否被用户恶意修改，如果被修改肯定也是不能通过的。</p>
<p><img src="https://s2.loli.net/2023/07/24/17dmiHXEG4rLO6W.png" alt="image-20230724011814993"></p>
<h4 id="SpringSecurity实现JWT校验"><a href="#SpringSecurity实现JWT校验" class="headerlink" title="SpringSecurity实现JWT校验"></a>SpringSecurity实现JWT校验</h4><p>前面我们介绍了JWT的基本原理以及后端的基本校验流程，那么我们现在就来看看如何实现这样的流程。</p>
<p>SpringSecurity中并没有为我们提供预设的JWT校验模块（只有OAuth2模块才有，但是知识太超前了，我们暂时不讲解）这里我们只能手动进行整合，JWT可以存放在Cookie或是请求头中，不过不管哪种方式，我们都可以通过Request获取到对应的JWT令牌，这里我们使用比较常见的请求头携带JWT的方案，客户端发起的请求中会携带这样的的特殊请求头：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Authorization: Bearer eyJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJzZWxmIiwic3ViIjoidXNlciIsImV4cCI6MTY5MDIxODE2NCwiaWF0IjoxNjkwMTgyMTY0LCJzY29wZSI6ImFwcCJ9.Z5-WMeulZyx60WeNxrQg2z2GiVquEHrsBl9V4dixbRkAD6rFp-6gCrcAXWkebs0i-we4xTQ7TZW0ltuhGYZ1GmEaj4F6BP9VN8fLq2aT7GhCJDgjikaTs-w5BbbOD2PN_vTAK_KeVGvYhWU4_l81cvilJWVXAhzMtwgPsz1Dkd04cWTCpI7ZZi-RQaBGYlullXtUrehYcjprla8N-bSpmeb3CBVM3kpAdehzfRpAGWXotN27PIKyAbtiJ0rqdvRmvlSztNY0_1IoO4TprMTUr-wjilGbJ5QTQaYUKRHcK3OJrProz9m8ztClSq0GRvFIB7HuMlYWNYwf7lkKpGvKDg</span><br></pre></td></tr></table></figure>

<p>这里的Authorization请求头就是携带JWT的专用属性，值的格式为”Bearer Token”，前面的Bearer代表身份验证方式，默认情况下有两种：</p>
<blockquote>
<p>Basic 和 Bearer 是两种不同的身份验证方式。</p>
<p>Basic 是一种基本的身份验证方式，它将用户名和密码进行base64编码后，放在 Authorization 请求头中，用于向服务器验证用户身份。这种方式不够安全，因为它将密码以明文的形式传输，容易受到中间人攻击。</p>
<p>Bearer 是一种更安全的身份验证方式，它基于令牌（Token）来验证用户身份。Bearer 令牌是由身份验证服务器颁发给客户端的，客户端在每个请求中将令牌放在 Authorization 请求头的 Bearer 字段中。服务器会验证令牌的有效性和权限，以确定用户的身份。Bearer 令牌通常使用 JSON Web Token (JWT) 的形式进行传递和验证。</p>
</blockquote>
<p>一会我们会自行编写JWT校验拦截器来处理这些信息。</p>
<p>首先我们先把用于处理JWT令牌的工具类完成一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line">  	<span class="comment">//Jwt秘钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;abcdefghijklmn&quot;</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//根据用户信息创建Jwt令牌</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJwt</span><span class="params">(UserDetails user)</span>&#123;</span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(key);</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        calendar.add(Calendar.SECOND, <span class="number">3600</span> * <span class="number">24</span> * <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">return</span> JWT.create()</span><br><span class="line">                .withClaim(<span class="string">&quot;name&quot;</span>, user.getUsername())  <span class="comment">//配置JWT自定义信息</span></span><br><span class="line">                .withClaim(<span class="string">&quot;authorities&quot;</span>, user.getAuthorities().stream().map(GrantedAuthority::getAuthority).toList())</span><br><span class="line">                .withExpiresAt(calendar.getTime())  <span class="comment">//设置过期时间</span></span><br><span class="line">                .withIssuedAt(now)    <span class="comment">//设置创建创建时间</span></span><br><span class="line">                .sign(algorithm);   <span class="comment">//最终签名</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//根据Jwt验证并解析用户信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDetails <span class="title function_">resolveJwt</span><span class="params">(String token)</span>&#123;</span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(key);</span><br><span class="line">        <span class="type">JWTVerifier</span> <span class="variable">jwtVerifier</span> <span class="operator">=</span> JWT.require(algorithm).build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DecodedJWT</span> <span class="variable">verify</span> <span class="operator">=</span> jwtVerifier.verify(token);  <span class="comment">//对JWT令牌进行验证，看看是否被修改</span></span><br><span class="line">            Map&lt;String, Claim&gt; claims = verify.getClaims();  <span class="comment">//获取令牌中内容</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().after(claims.get(<span class="string">&quot;exp&quot;</span>).asDate())) <span class="comment">//如果是过期令牌则返回null</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              	<span class="comment">//重新组装为UserDetails对象，包括用户名、授权信息等</span></span><br><span class="line">                <span class="keyword">return</span> User</span><br><span class="line">                        .withUsername(claims.get(<span class="string">&quot;name&quot;</span>).asString())</span><br><span class="line">                        .password(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                        .authorities(claims.get(<span class="string">&quot;authorities&quot;</span>).asArray(String.class))</span><br><span class="line">                        .build();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JWTVerificationException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们需要自行实现一个JwtAuthenticationFilter加入到SpringSecurity默认提供的过滤器链（有关SpringSecurity的实现原理介绍，我们在SSM中已经详细讲解过，各位小伙伴可以回顾一下）中，用于处理请求头中携带的JWT令牌，并配置登录状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;  </span><br><span class="line"><span class="comment">//继承OncePerRequestFilter表示每次请求过滤一次，用于快速编写JWT校验规则</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">      	<span class="comment">//首先从Header中取出JWT</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">      	<span class="comment">//判断是否包含JWT且格式正确</span></span><br><span class="line">        <span class="keyword">if</span> (authorization != <span class="literal">null</span> &amp;&amp; authorization.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> authorization.substring(<span class="number">7</span>);	</span><br><span class="line">          	<span class="comment">//开始解析成UserDetails对象，如果得到的是null说明解析失败，JWT有问题</span></span><br><span class="line">            <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> JwtUtils.resolveJwt(token);</span><br><span class="line">            <span class="keyword">if</span>(user != <span class="literal">null</span>) &#123;</span><br><span class="line">              	<span class="comment">//验证没有问题，那么就可以开始创建Authentication了，这里我们跟默认情况保持一致</span></span><br><span class="line">              	<span class="comment">//使用UsernamePasswordAuthenticationToken作为实体，填写相关用户信息进去</span></span><br><span class="line">                <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user, <span class="literal">null</span>, user.getAuthorities());</span><br><span class="line">                authentication.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line">              	<span class="comment">//然后直接把配置好的Authentication塞给SecurityContext表示已经完成验证</span></span><br><span class="line">                SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//最后放行，继续下一个过滤器</span></span><br><span class="line">      	<span class="comment">//可能各位小伙伴会好奇，要是没验证成功不是应该拦截吗？这个其实没有关系的</span></span><br><span class="line">      	<span class="comment">//因为如果没有验证失败上面是不会给SecurityContext设置Authentication的，后面直接就被拦截掉了</span></span><br><span class="line">      	<span class="comment">//而且有可能用户发起的是用户名密码登录请求，这种情况也要放行的，不然怎么登录，所以说直接放行就好</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们来配置一下SecurityConfiguration配置类，其实配置方法跟之前还是差不多，用户依然可以使用表单进行登录，并且登录方式也是一样的，就是有两个新增的部分需要我们注意一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> http</span><br><span class="line">          			<span class="comment">//其他跟之前一样，就省略掉了</span></span><br><span class="line">                ...  </span><br><span class="line">                <span class="comment">//将Session管理创建策略改成无状态，这样SpringSecurity就不会创建会话了，也不会采用之前那套机制记录用户，因为现在我们可以直接从JWT中获取信息</span></span><br><span class="line">                .sessionManagement(conf -&gt; &#123;</span><br><span class="line">                    conf.sessionCreationPolicy(SessionCreationPolicy.STATELESS);</span><br><span class="line">                &#125;)</span><br><span class="line">          			<span class="comment">//添加我们用于处理JWT的过滤器到Security过滤器链中，注意要放在UsernamePasswordAuthenticationFilter之前</span></span><br><span class="line">                .addFilterBefore(<span class="keyword">new</span> <span class="title class_">JwtAuthenticationFilter</span>(), UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//这个跟之前一样的写法，整合到一起处理，统一返回JSON格式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleProcess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                               HttpServletResponse response,</span></span><br><span class="line"><span class="params">                               Object exceptionOrAuthentication)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="keyword">if</span>(exceptionOrAuthentication <span class="keyword">instanceof</span> AccessDeniedException exception) &#123;</span><br><span class="line">            writer.write(RestBean.failure(<span class="number">403</span>, exception.getMessage()).asJsonString());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(exceptionOrAuthentication <span class="keyword">instanceof</span> AuthenticationException exception) &#123;</span><br><span class="line">            writer.write(RestBean.failure(<span class="number">401</span>, exception.getMessage()).asJsonString());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(exceptionOrAuthentication <span class="keyword">instanceof</span> Authentication authentication)&#123;</span><br><span class="line">          	<span class="comment">//不过这里需要注意，在登录成功的时候需要返回我们生成的JWT令牌，这样客户端下次访问就可以携带这个令牌了，令牌过期之后就需要重新登录才可以</span></span><br><span class="line">            writer.write(RestBean.success(JwtUtils.createJwt((User) authentication.getPrincipal())).asJsonString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们创建一个测试使用的Controller来看看效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么现在采用JWT之后，我们要怎么使用呢？首先我们还是使用工具来测试一下：</p>
<p><img src="https://s2.loli.net/2023/07/24/L1O8m6auYc2IFWR.png" alt="image-20230724200235358"></p>
<p>登录成功之后，可以看到现在返回给我们了一个JWT令牌，接着我们就可以使用这个令牌了。比如现在我们要访问某个接口获取数据，那么就可以携带这个令牌进行访问：</p>
<p><img src="https://s2.loli.net/2023/07/24/Hn7X5qeDf9htk6P.png" alt="image-20230724200341917"></p>
<p>注意需要在请求头中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Authorization: Bearer 刚刚获取的Token</span><br></pre></td></tr></table></figure>

<p>如果以后没有登录或者携带一个错误的JWT访问服务器，都会返回401错误：</p>
<p><img src="https://s2.loli.net/2023/07/24/ID96yY7lkr5VsPS.png" alt="image-20230724200533964"></p>
<p>我们现在来模拟一下前端操作：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  	<span class="comment">//其他都是跟之前一样的</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        axios.<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:8081/api/auth/login&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">username</span>: <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username&#x27;</span>).<span class="property">value</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">password</span>: <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;password&#x27;</span>).<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">        &#125;, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">headers</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(data.<span class="property">code</span> === <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//将得到的JWT令牌存到sessionStorage用于本次会话</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;access_token&quot;</span>, data.<span class="property">data</span>)</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;/index.html&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&#x27;登录失败：&#x27;</span>+data.<span class="property">message</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着是首页，获取信息的时候携带上JWT即可，不需要依赖Cookie了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:8081/api/user/name&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">headers</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&quot;Bearer &quot;</span>+<span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;access_token&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username&#x27;</span>).<span class="property">innerText</span> = data.<span class="property">data</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样我们就实现了基于SpringSecurity的JWT校验，整个流程还是非常清晰的。</p>
<h4 id="退出登录JWT处理"><a href="#退出登录JWT处理" class="headerlink" title="退出登录JWT处理"></a>退出登录JWT处理</h4><p>虽然我们使用JWT已经很方便了，但是有一个很严重的问题就是，我们没办法像Session那样去踢用户下线，什么意思呢？我们之前可以使用退出登录接口直接退出，用户Session中的验证信息也会被销毁，但是现在是无状态的，用户来管理Token令牌，服务端只认Token是否合法，那这个时候该怎么让用户正确退出登录呢？</p>
<p>首先我们从最简单的方案开始，我们可以直接让客户端删除自己的JWT令牌，这样不就相当于退出登录了吗，这样甚至不需要请求服务器，直接就退了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">		...</span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">logout</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//直接删除存在sessionStorage中的JWT令牌</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">sessionStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&quot;access_token&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//然后回到登录界面</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;/login.html&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样虽然是最简单粗暴的，但是存在一个问题，用户可以自行保存这个Token拿来使用。虽然客户端已经删除掉了，但是这个令牌仍然是可用的，如果用户私自保存过，那么依然可以正常使用这个令牌，这显然是有问题的。</p>
<p>目前有两种比较好的方案：</p>
<ul>
<li>黑名单方案：所有黑名单中的JWT将不可使用。</li>
<li>白名单方案：不在白名单中的JWT将不可使用。</li>
</ul>
<p>这里我们以黑名单机制为例，让用户退出登录之后，无法再次使用之前的JWT进行操作，首先我们需要给JWT额外添加一个用于判断的唯一标识符，这里就用UUID好了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;abcdefghijklmn&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJwt</span><span class="params">(UserDetails user)</span>&#123;</span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(key);</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        calendar.add(Calendar.SECOND, <span class="number">3600</span> * <span class="number">24</span> * <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">return</span> JWT.create()</span><br><span class="line">          			<span class="comment">//额外添加一个UUID用于记录黑名单，将其作为JWT的ID属性jti</span></span><br><span class="line">          			.withJWTId(UUID.randomUUID().toString())</span><br><span class="line">                .withClaim(<span class="string">&quot;name&quot;</span>, user.getUsername())</span><br><span class="line">                .withClaim(<span class="string">&quot;authorities&quot;</span>, user.getAuthorities().stream().map(GrantedAuthority::getAuthority).toList())</span><br><span class="line">                .withExpiresAt(calendar.getTime())</span><br><span class="line">                .withIssuedAt(now)</span><br><span class="line">                .sign(algorithm);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们发出去的所有令牌都会携带一个UUID作为唯一凭据，接着我们可以创建一个专属的表用于存储黑名单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;	</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashSet&lt;String&gt; blackList = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//加入黑名单方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">invalidate</span><span class="params">(String token)</span>&#123;</span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(key);</span><br><span class="line">        <span class="type">JWTVerifier</span> <span class="variable">jwtVerifier</span> <span class="operator">=</span> JWT.require(algorithm).build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DecodedJWT</span> <span class="variable">verify</span> <span class="operator">=</span> jwtVerifier.verify(token);</span><br><span class="line">            Map&lt;String, Claim&gt; claims = verify.getClaims();</span><br><span class="line">          	<span class="comment">//取出UUID丢进黑名单中</span></span><br><span class="line">            <span class="keyword">return</span> blackList.add(verify.getId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JWTVerificationException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> UserDetails <span class="title function_">resolveJwt</span><span class="params">(String token)</span>&#123;</span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(key);</span><br><span class="line">        <span class="type">JWTVerifier</span> <span class="variable">jwtVerifier</span> <span class="operator">=</span> JWT.require(algorithm).build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DecodedJWT</span> <span class="variable">verify</span> <span class="operator">=</span> jwtVerifier.verify(token);</span><br><span class="line">            <span class="comment">//判断是否存在于黑名单中，如果存在，则返回null表示失效</span></span><br><span class="line">            <span class="keyword">if</span>(blackList.contains(verify.getId()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            Map&lt;String, Claim&gt; claims = verify.getClaims();</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().after(claims.get(<span class="string">&quot;exp&quot;</span>).asDate()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> User</span><br><span class="line">                    .withUsername(claims.get(<span class="string">&quot;name&quot;</span>).asString())</span><br><span class="line">                    .password(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                    .authorities(claims.get(<span class="string">&quot;authorities&quot;</span>).asArray(String.class))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JWTVerificationException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来SecurityConfiguration中配置一下退出登录操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                 HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                 Authentication authentication)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(authorization != <span class="literal">null</span> &amp;&amp; authorization.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> authorization.substring(<span class="number">7</span>);</span><br><span class="line">          	<span class="comment">//将Token加入黑名单</span></span><br><span class="line">            <span class="keyword">if</span>(JwtUtils.invalidate(token)) &#123;</span><br><span class="line">              	<span class="comment">//只有成功加入黑名单才会退出成功</span></span><br><span class="line">                writer.write(RestBean.success(<span class="string">&quot;退出登录成功&quot;</span>).asJsonString());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        writer.write(RestBean.failure(<span class="number">400</span>, <span class="string">&quot;退出登录失败&quot;</span>).asJsonString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就成功安排上了黑名单机制，即使用户提前保存，这个Token依然是失效的：</p>
<p><img src="https://s2.loli.net/2023/07/24/4o76q5yNHkabuip.png" alt="image-20230724214624046"></p>
<p>虽然这种黑名单机制很方便，但是如果到了后面的微服务阶段，可能多个服务器都需要共享这个黑名单，这个时候我们再将黑名单存储在单个应用中就不太行了，后续我们可以考虑使用Redis服务器来存放黑名单列表，这样就可以实现多个服务器共享，并且根据JWT的过期时间合理设定黑名单中UUID的过期时间，自动清理。</p>
<h4 id="自动续签JWT令牌"><a href="#自动续签JWT令牌" class="headerlink" title="自动续签JWT令牌"></a>自动续签JWT令牌</h4><p>在有些时候，我们可能希望用户能够一直使用我们的网站，而不是JWT令牌到期之后就需要重新登录，这种情况下前端就可以配置JWT自动续签，在发起请求时如果令牌即将到期，那么就向后端发起续签请求得到一个新的JWT令牌。</p>
<p>这里我们写一个接口专门用于令牌刷新：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/auth&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/refresh&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestBean&lt;String&gt; <span class="title function_">refreshToken</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> JwtUtils.createJwt(user);</span><br><span class="line">        <span class="keyword">return</span> RestBean.success(jwt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，前端在发现令牌可用时间不足时，就会先发起一个请求自动完成续期，得到一个新的Token：</p>
<p><img src="https://s2.loli.net/2023/07/24/cqEgnQOZtFp1w7o.png" alt="image-20230724232152613"></p>
<p>我们可能还需要配置一下这种方案的请求频率，不然用户疯狂请求刷新Token就不太好了，我们同样可以借助Redis进行限流等操作，防止频繁请求，这里就不详细编写了，各位小伙伴可以自行实现。</p>
<p>我们最后可以来对比一下两种前后端分离方式的优缺点如何：</p>
<p><strong>JWT校验方案的优点：</strong></p>
<ol>
<li>无状态: JWT是无状态的，服务器不需要在后端维护用户的会话信息，可以在分布式系统中进行水平扩展，减轻服务器的负担。</li>
<li>基于Token: JWT使用token作为身份认证信息，该token可以存储用户相关的信息和权限。这样可以减少与数据库的频繁交互，提高性能。</li>
<li>安全性: JWT使用数字签名或加密算法保证token的完整性和安全性。每次请求都会验证token的合法性，防止伪造或篡改。</li>
<li>跨域支持: JWT可以在不同域之间进行数据传输，适合前后端分离的架构。</li>
</ol>
<p><strong>JWT校验方案的缺点：</strong></p>
<ol>
<li>无法做到即时失效: JWT中的token通常具有较长的有效期，一旦签发，就无法立即失效。如果需要即时失效，需要在服务端进行额外的处理。</li>
<li>信息无法撤销: JWT中的token一旦签发，除非到期或者客户端清除，无法撤销。无法中途取消和修改权限。</li>
<li>Token增大的问题: JWT中包含了用户信息和权限等，token的体积较大，每次请求都需要携带，增加了网络传输的开销。</li>
<li>动态权限管理问题: JWT无法处理动态权限管理，一旦签发的token权限发生变化，仍然有效，需要其他手段进行处理。</li>
</ol>
<p><strong>传统Session校验方案的优点：</strong></p>
<ol>
<li>即时失效: Session在服务器端管理，可以通过设置过期时间或手动删除实现即时失效，保护会话的安全性。</li>
<li>信息即时撤销: 服务器端可以随时撤销或修改Session的信息和权限。</li>
<li>灵活的权限管理: Session方案可以更灵活地处理动态权限管理，可以根据具体场景进行即时调整。</li>
</ol>
<p><strong>传统Session校验方案的缺点：</strong></p>
<ol>
<li>状态维护: 传统Session需要在服务器端维护会话状态信息，增加了服务器的负担，不利于系统的横向扩展。</li>
<li>性能开销: 每次请求都需要在服务器端进行会话状态的校验和读写操作，增加了性能开销。</li>
<li>跨域问题: Session方案在跨域时存在一些问题，需要进行额外的处理。</li>
<li>无法分布式共享: 传统Session方案不适用于多个服务器之间共享会话信息的场景，需要额外的管理和同步机制。</li>
</ol>
<p>综上所述，JWT校验方案适用于无状态、分布式系统，几乎所有常见的前后端分离的架构都可以采用这种方案。而传统Session校验方案适用于需要即时失效、即时撤销和灵活权限管理的场景，适合传统的服务器端渲染应用，以及客户端支持Cookie功能的前后端分离架构。在选择校验方案时，需要根据具体的业务需求和技术场景进行选择。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则与设计模式</title>
    <url>/2023/09/30/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计原则与设计模式"><a href="#设计原则与设计模式" class="headerlink" title="设计原则与设计模式"></a>设计原则与设计模式</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>参考博主：IT柏码</p>
<p>博主官网：<a href="https://itbaima.net/#/">柏码 - 让每一行代码都闪耀智慧的光芒！ (itbaima.net)</a></p>
<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><p>我们在进行软件开发时，不仅仅需要将最基本的业务给完成，还要考虑整个项目的可维护性和可复用性，我们开发的项目不单单需要我们自己来维护，同时也需要其他的开发者一起来进行共同维护，因此我们在编写代码时，应该尽可能的规范。如果我们在编写代码时不注重这些问题，整个团队项目就像一座屎山，随着项目的不断扩大，整体结构只会越来越遭。</p>
<p>甚至到最后你会发现，我们的程序居然是稳定运行在BUG之上的…</p>
<p>所以，为了尽可能避免这种情况的发生，我们就来聊聊面向对象设计原则。</p>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>单一职责原则（Simple Responsibility Pinciple，SRP）是最简单的面向对象设计原则，它用于控制类的粒度大小。</p>
<blockquote>
<p>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。</p>
</blockquote>
<p>比如我们现在有一个People类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个人类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 人类会编程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;int mian() &#123;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;   printf(\&quot;Holle Wrold!\&quot;);&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;啊嘞，怎么运行不起？明明照着老师敲的啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂打螺丝也会</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;真开心，能进到富土康打螺丝&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;诶，怎么工友都提桶跑路了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 送外卖也会</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ride</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;今天终于通过美团最终面，加入了梦寐以求的大厂了&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;感觉面试挺简单的，就是不知道为啥我同学是现场做一道力扣接雨水，而我是现场问会不会骑车&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;（迫不及待穿上外卖服装）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这个People类可以说是十八般武艺样样精通了，啥都会，但是实际上，我们每个人最终都是在自己所擅长的领域工作，所谓闻道有先后，术业有专攻，会编程的就应该是程序员，会打螺丝的就应该是工人，会送外卖的应该是骑手，显然这个People太过臃肿（我们需要修改任意一种行为都需要修改People类，它拥有不止一个引起它变化的原因），所以根据单一职责原则，我们下需要进行更明确的划分，同种类型的操作我们一般才放在一起：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coder</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 程序员会编程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;int mian() &#123;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;   printf(\&quot;Hello World!\&quot;)&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;啊嘞，怎么运行不起？明明照着老师敲的啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工人会打螺丝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;真开心，能进到富土康打螺丝&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;诶，怎么工友都提桶跑路了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rider</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 骑手会送外卖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ride</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;今天终于通过美团最终面，加入了梦寐以求的大厂&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;感觉面试挺简单的，就是不知道为啥我同学是现场做一道力扣接雨水，我是现场问会不会骑车&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;（迫不及待穿上外卖服装）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将类的粒度进行更近一步的划分，这样就很清晰了，包括我们以后在设计Mapper、Service、Controller等等，根据不同的业务进行划分，都可以采用单一职责原则，以它作为我们实现高内聚低耦合的指导方针。实际上我们的微服务也是参考了单一职责原则，每个微服务只应担负一个职责。</p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开闭原则（Open Close Principle）也是重要的面向对象设计原则。</p>
<blockquote>
<p>软件实体应当对扩展开放，对修改关闭。</p>
</blockquote>
<p>一个软件实体，比如类、模块和函数应该对扩展开放，对修改关闭。其中，对扩展开放是针对提供方来说的，对修改关闭是针对调用方来说的。</p>
<p>比如我们的程序员分为Java程序员、C#程序员、C艹程序员、PHP程序员、前端程序员等，而他们要做的都是去打代码，而具体如何打代码是根据不同语言的程序员来决定的，我们可以将程序员打代码这一个行为抽象成一个统一的接口或是抽象类，这样我们就满足了开闭原则的第一个要求：对扩展开放，不同的程序员可以自由地决定他们该如何进行编程。而具体哪个程序员使用什么语言怎么编程，是自己在负责，不需要其他程序员干涉，所以满足第二个要求：对修改关闭，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">JavaCoder</span> <span class="keyword">extends</span> <span class="title class_">Coder</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Java太卷了T_T，快去学Go吧！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">PHPCoder</span> <span class="keyword">extends</span> <span class="title class_">Coder</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;PHP是世界上最好的语言&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span>艹Coder <span class="keyword">extends</span> <span class="title class_">Coder</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;笑死，Java再牛逼底层不还得找我？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过提供一个Coder抽象类，定义出编程的行为，但是不进行实现，而是开放给其他具体类型的程序员来实现，这样就可以根据不同的业务进行灵活扩展了，具有较好的延续性。</p>
<p>不过，回顾我们这一路的学习，好像处处都在使用开闭原则。</p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>里氏替换原则（Liskov Substitution Principle）是对子类型的特别定义。它由芭芭拉·利斯科夫（Barbara Liskov）在1987年在一次会议上名为 “数据的抽象与层次” 的演说中首先提出。</p>
<blockquote>
<p>所有引用基类的地方必须能透明地使用其子类的对象。</p>
</blockquote>
<p>简单的说就是，子类可以扩展父类的功能，但不能改变父类原有的功能：</p>
<ol>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入&#x2F;入参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的输出&#x2F;返回值）要比父类更严格或与父类一样。</li>
</ol>
<p>比如我们下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会打代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">JavaCoder</span> <span class="keyword">extends</span> <span class="title class_">Coder</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 子类除了会打代码之外，还会打游戏</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">game</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;艾欧尼亚最强王者已上号&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到JavaCoder虽然继承自Coder，但是并没有对父类方法进行重写，并且还在父类的基础上进行额外扩展，符合里氏替换原则。但是我们再来看下面的这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会打代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">JavaCoder</span> <span class="keyword">extends</span> <span class="title class_">Coder</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">game</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;艾欧尼亚最强王者已上号&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里我们对父类的行为进行了重写，现在它不再具备父类原本的能力了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我寒窗苦读十六年，到最后还不如培训班三个月出来的程序员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;想来想去，房子车子结婚彩礼，为什么这辈子要活的这么累呢？&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;难道来到这世间走这一遭就为了花一辈子时间买个房子吗？一个人不是也能活的轻松快乐吗？&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;摆烂了，啊对对对&quot;</span>);  </span><br><span class="line">          	<span class="comment">//好了，emo结束，继续卷吧，人生因奋斗而美丽，这个世界虽然满目疮痍，但是还是有很多美好值得期待</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，现在我们对父类的方法进行了重写，显然，父类的行为已经被我们给覆盖了，这个子类已经不具备父类的原本的行为，很显然违背了里氏替换原则。</p>
<p>要是程序员连敲代码都不会了，还能叫做程序员吗？</p>
<p>所以，对于这种情况，我们不需要再继承自Coder了，我们可以提升一下，将此行为定义到People中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span>;   <span class="comment">//这个行为还是定义出来，但是不实现</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Coder</span> <span class="keyword">extends</span> <span class="title class_">People</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我会打代码&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">JavaCoder</span> <span class="keyword">extends</span> <span class="title class_">People</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">game</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;艾欧尼亚最强王者已上号&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coding</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;摆烂了，啊对对对&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里氏替换也是实现开闭原则的重要方式之一。</p>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p>依赖倒转原则（Dependence Inversion Principle）也是我们一直在使用的，最明显的就是我们的Spring框架了。</p>
<blockquote>
<p>高层模块不应依赖于底层模块，它们都应该依赖抽象。抽象不应依赖于细节，细节应该依赖于抽象。</p>
</blockquote>
<p>还记得我们在我们之前的学习中为什么要一直使用接口来进行功能定义，然后再去实现吗？我们回顾一下在使用Spring框架之前的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserController</span>();</span><br><span class="line">      	<span class="comment">//该怎么用就这么用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">        <span class="comment">//CRUD...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserMapper</span>();</span><br><span class="line">        <span class="comment">//业务代码....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        <span class="comment">//业务代码....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是突然有一天，公司业务需求变化，现在用户相关的业务操作需要使用新的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserController</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">        <span class="comment">//CRUD...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserServiceNew</span> &#123;   <span class="comment">//由于UserServiceNew发生变化，会直接影响到其他高层模块</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserMapper</span>();</span><br><span class="line">        <span class="comment">//业务代码....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;   <span class="comment">//焯，干嘛改底层啊，我这又得重写了</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();   <span class="comment">//哦豁，原来的不能用了</span></span><br><span class="line">        <span class="type">UserServiceNew</span> <span class="variable">serviceNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceNew</span>();   <span class="comment">//只能修改成新的了</span></span><br><span class="line">        <span class="comment">//业务代码....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，我们的各个模块之间实际上是具有强关联的，一个模块是直接指定依赖于另一个模块，虽然这样结构清晰，但是底层模块的变动，会直接影响到其他依赖于它的高层模块，如果我们的项目变得很庞大，那么这样的修改将是一场灾难。</p>
<p>而有了Spring框架之后，我们的开发模式就发生了变化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserController</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">        <span class="comment">//接口中只做CRUD方法定义</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserMapperImpl</span> <span class="keyword">implements</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">        <span class="comment">//实现类完成CRUD具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">        <span class="comment">//业务代码定义....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">        <span class="meta">@Resource</span>   <span class="comment">//现在由Spring来为我们选择一个指定的实现类，然后注入，而不是由我们在类中硬编码进行指定</span></span><br><span class="line">        UserMapper mapper;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//业务代码具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">        <span class="meta">@Resource</span></span><br><span class="line">        UserService service;   <span class="comment">//直接使用接口，就算你改实现，我也不需要再修改代码了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//业务代码....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，通过使用接口，我们就可以将原有的强关联给弱化，我们只需要知道接口中定义了什么方法然后去使用即可，而具体的操作由接口的实现类来完成，并由Spring来为我们注入，而不是我们通过硬编码的方式去指定。</p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>接口隔离原则（Interface Segregation Principle, ISP）实际上是对接口的细化。</p>
<blockquote>
<p>客户端不应依赖那些它不需要的接口。</p>
</blockquote>
<p>我们在定义接口的时候，一定要注意控制接口的粒度，比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Device</span> &#123;</span><br><span class="line">    String <span class="title function_">getCpu</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getType</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getMemory</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑就是一种电子设备，那么我们就实现此接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> <span class="keyword">implements</span> <span class="title class_">Device</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;i9-12900K&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电脑&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;32G DDR5&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电风扇也算是一种电子设备</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fan</span> <span class="keyword">implements</span> <span class="title class_">Device</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;   <span class="comment">//就一个破风扇，还需要CPU？</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;风扇&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;   <span class="comment">//风扇也不需要内存吧</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然我们定义了一个Device接口，但是由于此接口的粒度不够细，虽然比较契合电脑这种设备，但是不适合风扇这种设备，因为风扇压根就不需要CPU和内存，所以风扇完全不需要这些方法。这时我们就必须要对其进行更细粒度的划分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SmartDevice</span> &#123;   <span class="comment">//智能设备才有getCpu和getMemory</span></span><br><span class="line">    String <span class="title function_">getCpu</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getType</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getMemory</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NormalDevice</span> &#123;   <span class="comment">//普通设备只有getType</span></span><br><span class="line">    String <span class="title function_">getType</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑就是一种电子设备，那么我们就继承此接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> <span class="keyword">implements</span> <span class="title class_">SmartDevice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;i9-12900K&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电脑&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;32G DDR5&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电风扇也算是一种电子设备</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fan</span> <span class="keyword">implements</span> <span class="title class_">NormalDevice</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;风扇&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就将接口进行了细粒度的划分，不同类型的电子设备就可以根据划分去实现不同的接口了。当然，也不能划分得太小，还是要根据实际情况来进行决定。</p>
<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>合成复用原则（Composite Reuse Principle）的核心就是委派。</p>
<blockquote>
<p>优先使用对象组合，而不是通过继承来达到复用的目的。</p>
</blockquote>
<p>在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新的对象通过向这些对象的委派达到复用已有功能的目的。实际上我们在考虑将某个类通过继承关系在子类得到父类已经实现的方法之外（比如A类实现了连接数据库的功能，恰巧B类中也需要，我们就可以通过继承来获得A已经写好的连接数据库的功能，这样就能直接复用A中已经写好的逻辑）我们应该应该优先地去考虑使用合成的方式来实现复用。</p>
<p>比如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connectDatabase</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是连接数据库操作！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;    <span class="comment">//直接通过继承的方式，得到A的数据库连接逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是B的方法，我也需要连接数据库！&quot;</span>);</span><br><span class="line">        connectDatabase();   <span class="comment">//直接调用父类方法就行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这样看起来没啥毛病，但是还是存在我们之前说的那个问题，耦合度太高了。</p>
<p>可以看到通过继承的方式实现复用，我们是将类B直接指定继承自类A的，那么如果有一天，由于业务的更改，我们的数据库连接操作，不再由A来负责，而是由新来的C去负责，那么这个时候，我们就不得不将需要复用A中方法的子类全部进行修改，很显然这样是费时费力的。</p>
<p>并且还有一个问题就是，通过继承子类会得到一些父类中的实现细节，比如某些字段或是方法，这样直接暴露给子类，并不安全。</p>
<p>所以，当我们需要实现复用时，可以优先考虑以下操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connectDatabase</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是连接数据库操作！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;   <span class="comment">//不进行继承，而是在用的时候给我一个A，当然也可以抽象成一个接口，更加灵活</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(A a)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是B的方法，我也需要连接数据库！&quot;</span>);</span><br><span class="line">        a.connectDatabase();   <span class="comment">//在通过传入的对象A去执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connectDatabase</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是连接数据库操作！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    </span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span>&#123;   <span class="comment">//在构造时就指定好</span></span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是B的方法，我也需要连接数据库！&quot;</span>);</span><br><span class="line">        a.connectDatabase();   <span class="comment">//也是通过对象A去执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对象之间的组合，我们就大大降低了类之间的耦合度，并且A的实现细节我们也不会直接得到了。</p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>迪米特法则（Law of Demeter）又称最少知识原则，是对程序内部数据交互的限制。</p>
<blockquote>
<p>每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p>
</blockquote>
<p>简单来说就是，一个类&#x2F;模块对其他的类&#x2F;模块有越少的交互越好。当一个类发生改动，那么，与其相关的类（比如用到此类啥方法的类）需要尽可能少的受影响（比如修改了方法名、字段名等，可能其他用到这些方法或是字段的类也需要跟着修改）这样我们在维护项目的时候会更加轻松一些。</p>
<p>其实说白了，还是降低耦合度，我们还是来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>);   <span class="comment">//假设我们当前的程序需要进行网络通信</span></span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.test(socket);   <span class="comment">//现在需要执行test方法来做一些事情</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 比如test方法需要得到我们当前Socket连接的本地地址</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;IP地址：&quot;</span>+socket.getLocalAddress());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然上面这种写法没有问题，我们提供直接提供一个Socket对象，然后再由test方法来取出IP地址，但是这样显然违背了迪米特法则，实际上这里的<code>test</code>方法只需要一个IP地址即可，我们完全可以直接传入一个字符串，而不是整个Socket对象，我们需要保证与其他类的交互尽可能的少。</p>
<p>就像我们在餐厅吃完了饭，应该是我们自己扫码付款，而不是直接把手机交给老板来帮你操作付款。</p>
<p>要是某一天，Socket类中的这些方法发生修改了，那我们就得连带着去修改这些类，很麻烦。</p>
<p>所以，我们来改进改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.test(socket.getLocalAddress().getHostAddress());  <span class="comment">//在外面解析好就行了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123;   <span class="comment">//一个字符串就能搞定，就没必要丢整个对象进来</span></span><br><span class="line">            System.out.println(<span class="string">&quot;IP地址：&quot;</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，类与类之间的耦合度再次降低。</p>
<h2 id="设计模式（创建型）"><a href="#设计模式（创建型）" class="headerlink" title="设计模式（创建型）"></a>设计模式（创建型）</h2><p>软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p>
<blockquote>
<p>肯特·贝克和<a href="https://baike.baidu.com/item/%E6%B2%83%E5%BE%B7%C2%B7%E5%9D%8E%E5%AE%81%E5%AE%89/6488429">沃德·坎宁安</a>在1987年利用克里斯托佛·亚历山大在建筑设计领域里的思想开发了设计模式并把此思想应用在Smalltalk中的图形用户接口的生成中。一年后Erich Gamma在他的<a href="https://baike.baidu.com/item/%E8%8B%8F%E9%BB%8E%E4%B8%96%E5%A4%A7%E5%AD%A6/1621125">苏黎世大学</a>博士毕业论文中开始尝试把这种思想改写为适用于软件开发。与此同时James Coplien 在1989年至1991 年也在利用相同的思想致力于C++的开发，而后于1991年发表了他的著作Advanced C++ Idioms。就在这一年Erich Gamma 得到了博士学位，然后去了美国，在那与Richard Helm, Ralph Johnson ,John Vlissides合作出版了Design Patterns - Elements of Reusable Object-Oriented Software 一书，在此书中共收录了23个设计模式。这四位作者在软件开发领域里也以他们的匿名著称Gang of Four(四人帮，简称GoF),并且是他们在此书中的协作导致了软件设计模式的突破。</p>
</blockquote>
<p>我们先来看看有关对象创建的几种设计模式。</p>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>首当其冲的是最简单的一种设计模式——工厂方法模式，我们知道，如果需要创建一个对象，那么最简单的方式就是直接new一个即可。而工厂方法模式代替了传统的直接new的形式，那么为什么要替代传统的new形式呢？</p>
<p>可以想象一下，如果所有的对象我们都通过new的方式去创建，那么当我们的程序中大量使用此对象时，突然有一天这个对象的构造方法或是类名发生了修改，那我们岂不是得挨个去进行修改？根据迪米特法则，我们应该尽可能地少与其他类进行交互，所以我们可以将那些需要频繁出现的对象创建，封装到一个工厂类中，当我们需要对象时，直接调用工厂类中的工厂方法来为我们生成对象，这样，就算类出现了变动，我们也只需要修改工厂中的代码即可，而不是大面积地进行修改。</p>
<p>同时，可能某些对象的创建并不只是一个new就可以搞定，可能还需要更多的步骤来准备构造方法需要的参数，所以我们来看看如何使用<code>简单工厂模式</code>来创建对象，既然是工厂，那么我们就来创建点工厂需要生产的东西：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;   <span class="comment">//水果抽象类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fruit</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&quot;@&quot;</span>+hashCode();   <span class="comment">//打印一下当前水果名称，还有对象的hashCode</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span>&#123;   <span class="comment">//苹果，继承自水果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span>&#123;  <span class="comment">//橘子，也是继承自水果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Orange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;橘子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下，我们直接new就可以得到对象了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">        System.out.println(apple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们将对象的创建封装到工厂中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里就直接来一个静态方法根据指定类型进行创建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 水果类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的水果对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title function_">getFruit</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;苹果&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">           	<span class="keyword">case</span> <span class="string">&quot;橘子&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Orange</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们就可以使用此工厂来创建对象了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> FruitFactory.getFruit(<span class="string">&quot;橘子&quot;</span>);   <span class="comment">//直接问工厂要，而不是我们自己去创建</span></span><br><span class="line">        System.out.println(fruit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过这样还是有一些问题，我们前面提到了开闭原则，一个软件实体，比如类、模块和函数应该对扩展开放，对修改关闭，但是如果我们现在需要新增一种水果，比如桃子，那么这时我们就得去修改工厂提供的工厂方法了，但是这样是不太符合开闭原则的，因为工厂实际上是针对于调用方提供的，所以我们应该尽可能对修改关闭。</p>
<p>所以，我们就利用对扩展开放，对修改关闭的性质，将<code>简单工厂模式</code>改进为<code>工厂方法模式</code>，那现在既然不让改，那么我们就看看如何去使用扩展的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FruitFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; &#123;   <span class="comment">//将水果工厂抽象为抽象类，添加泛型T由子类指定水果类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title function_">getFruit</span><span class="params">()</span>;  <span class="comment">//不同的水果工厂，通过此方法生产不同的水果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleFactory</span> <span class="keyword">extends</span> <span class="title class_">FruitFactory</span>&lt;Apple&gt; &#123;  <span class="comment">//苹果工厂，直接返回Apple，一步到位</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Apple <span class="title function_">getFruit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就可以使用不同类型的工厂来生产不同类型的水果了，并且如果新增了水果类型，直接创建一个新的工厂类就行，不需要修改之前已经编写好的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test(<span class="keyword">new</span> <span class="title class_">AppleFactory</span>()::getFruit);   <span class="comment">//比如我们现在要吃一个苹果，那么就直接通过苹果工厂来获取苹果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法模拟吃掉一个水果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Supplier&lt;Fruit&gt; supplier)</span>&#123;</span><br><span class="line">        System.out.println(supplier.get()+<span class="string">&quot; 被吃掉了，真好吃。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就简单实现了工厂方法模式，通过工厂来屏蔽对象的创建细节，使用者只需要关心如何去使用对象即可。</p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>前面我们介绍了工厂方法模式，通过定义顶层抽象工厂类，通过继承的方式，针对于每一个产品都提供一个工厂类用于创建。</p>
<p>不过这种模式只适用于简单对象，当我们需要生产许多个产品族的时候，这种模式就有点乏力了，比如：</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/leHOprkRiys3WhN.png" alt="image-20230301111712035"></p>
<p>实际上这些产品都是成族出现的，比如小米的产品线上有小米12，小米平板等，华为的产品线上也有华为手机、华为平板，但是如果按照我们之前工厂方法模式来进行设计，那就需要单独设计9个工厂来生产上面这些产品，显然这样就比较浪费时间的。</p>
<p>但是现在有什么方法能够更好地处理这种情况呢？我们就可以使用抽象工厂模式，我们可以将多个产品，都放在一个工厂中进行生成，按不同的产品族进行划分，比如小米，那么我就可以安排一个小米工厂，而这个工厂里面就可以生产整条产品线上的内容，包括小米手机、小米平板、小米路由等。</p>
<p>所以，我们只需要建立一个抽象工厂即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Router</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Table</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Phone <span class="title function_">getPhone</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Table <span class="title function_">getTable</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Router <span class="title function_">getRouter</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个工厂可以生产同一个产品族的所有产品，这样按族进行分类，显然比之前的工厂方法模式更好。</p>
<p>不过，缺点还是有的，如果产品族新增了产品，那么我就不得不去为每一个产品族的工厂都去添加新产品的生产方法，违背了开闭原则。</p>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>建造者模式也是非常常见的一种设计模式，我们经常看到有很多的框架都为我们提供了形如<code>XXXBuilder</code>的类型，我们一般也是使用这些类来创建我们需要的对象。</p>
<p>比如，我们在JavaSE中就学习过的<code>StringBuiler</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();   <span class="comment">//创建一个StringBuilder来逐步构建一个字符串</span></span><br><span class="line">    builder.append(<span class="number">666</span>);   <span class="comment">//拼接一个数字</span></span><br><span class="line">    builder.append(<span class="string">&quot;老铁&quot;</span>);   <span class="comment">//拼接一个字符串</span></span><br><span class="line">   	builder.insert(<span class="number">2</span>, <span class="string">&#x27;?&#x27;</span>);  <span class="comment">//在第三个位置插入一个字符</span></span><br><span class="line">    System.out.println(builder.toString());   <span class="comment">//差不多成形了，最后转换为字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上我们是通过建造者来不断配置参数或是内容，当我们配置完所有内容后，最后再进行对象的构建。</p>
<p>相比直接去new一个新的对象，建造者模式的重心更加关注在如何完成每一步的配置，同时如果一个类的构造方法参数过多，我们通过建造者模式来创建这个对象，会更加优雅。</p>
<p>比如我们现在有一个学生类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> grade;</span><br><span class="line">    String name;</span><br><span class="line">    String college;</span><br><span class="line">    String profession;</span><br><span class="line">    List&lt;String&gt; awards;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> age, <span class="type">int</span> grade, String name, String college, String profession, List&lt;String&gt; awards)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.college = college;</span><br><span class="line">        <span class="built_in">this</span>.profession = profession;</span><br><span class="line">        <span class="built_in">this</span>.awards = awards;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个学生类的属性是非常多的，所以构造方法不是一般的长，如果我们现在直接通过new的方式去创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="number">18</span>, <span class="number">3</span>, <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;计算机学院&quot;</span>, <span class="string">&quot;计算机科学与技术&quot;</span>, Arrays.asList(<span class="string">&quot;ICPC-ACM 区域赛 金牌&quot;</span>, <span class="string">&quot;LPL 2022春季赛 冠军&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们光是填参数就麻烦，我们还得一个一个对应着去填，一不小心可能就把参数填到错误的位置了。</p>
<p>所以，我们现在可以使用建造者模式来进行对象的创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一律使用建造者来创建，不对外直接开放</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> age, <span class="type">int</span> grade, String name, String college, String profession, List&lt;String&gt; awards)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StudentBuilder <span class="title function_">builder</span><span class="params">()</span>&#123;   <span class="comment">//通过builder方法直接获取建造者</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StudentBuilder</span>&#123;   <span class="comment">//这里就直接创建一个内部类</span></span><br><span class="line">        <span class="comment">//Builder也需要将所有的参数都进行暂时保存，所以Student怎么定义的这里就怎么定义</span></span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="type">int</span> grade;</span><br><span class="line">        String name;</span><br><span class="line">        String college;</span><br><span class="line">        String profession;</span><br><span class="line">        List&lt;String&gt; awards;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">id</span><span class="params">(<span class="type">int</span> id)</span>&#123;    <span class="comment">//直接调用建造者对应的方法，为对应的属性赋值</span></span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;   <span class="comment">//为了支持链式调用，这里直接返回建造者本身，下同</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">age</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      	...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">awards</span><span class="params">(String... awards)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.awards = Arrays.asList(awards);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> Student <span class="title function_">build</span><span class="params">()</span>&#123;    <span class="comment">//最后我们只需要调用建造者提供的build方法即可根据我们的配置返回一个对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(id, age, grade, name, college, profession, awards);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们就可以使用建造者来为我们生成对象了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> Student.builder()   <span class="comment">//获取建造者</span></span><br><span class="line">            .id(<span class="number">1</span>)    <span class="comment">//逐步配置各个参数</span></span><br><span class="line">            .age(<span class="number">18</span>)</span><br><span class="line">            .grade(<span class="number">3</span>)</span><br><span class="line">            .name(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line">            .awards(<span class="string">&quot;ICPC-ACM 区域赛 金牌&quot;</span>, <span class="string">&quot;LPL 2022春季赛 冠军&quot;</span>)</span><br><span class="line">            .build();   <span class="comment">//最后直接建造我们想要的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就可以让这些参数对号入座了，并且也比之前的方式优雅许多。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式其实在之前的课程中已经演示过很多次了，这也是使用频率非常高的一种模式。</p>
<p>那么，什么是单例模式呢？顾名思义，单例那么肯定就是只有一个实例对象，在我们的整个程序中，同一个类始终只会有一个对象来进行操作。比如数据库连接类，实际上我们只需要创建一个对象或是直接使用静态方法就可以了，没必要去创建多个对象。</p>
<p>这里还是还原一下我们之前使用的简单单例模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();   <span class="comment">//用于引用全局唯一的单例对象，在一开始就创建好</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;   <span class="comment">//不允许随便new，需要对象直接找getInstance</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;   <span class="comment">//获取全局唯一的单例对象</span></span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当我们需要获取此对象时，只能通过<code>getInstance()</code>来获取唯一的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，单例模式除了这种写法之外，还有其他写法，这种写法被称为饿汉式单例，也就是说在一开始类加载时就创建好了，我们来看看另一种写法——懒汉式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;   <span class="comment">//在一开始先不进行对象创建</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;   <span class="comment">//不用多说了吧</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;   <span class="comment">//将对象的创建延后到需要时再进行</span></span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;    <span class="comment">//如果实例为空，那么就进行创建，不为空说明已经创建过了，那么就直接返回</span></span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，懒汉式就真的是条懒狗，你不去用它，它是不会给你提前准备单例对象的（延迟加载，懒加载），当我们需要获取对象时，才会进行检查并创建。虽然饿汉式和懒汉式写法不同，但是最后都是成功实现了单例模式。</p>
<p>不过，这里需要特别提醒一下，由于懒汉式是在方法中进行的初始化，在多线程环境下，可能会出现问题（建议学完JUC篇视频教程再来观看）大家可以试想一下，如果这个时候有多个线程同时调用了<code>getInstance()</code>方法，那么会出现什么问题呢？</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/w1oN7u3SxG4cEzL.png" alt="image-20230301111737649"></p>
<p>可以看到，在多线程环境下，如果三条线程同时调用<code>getInstance()</code>方法，会同时进行<code>INSTANCE == null</code>的判断，那么此时由于确实还没有进行任何实例化，所以导致三条线程全部判断为<code>true</code>（而饿汉式由于在类加载时就创建完成，不会存在这样的问题）此时问题就来了，我们既然要使用单例模式，那么肯定是只希望对象只被初始化一次的，但是现在由于多线程的机制，导致对象被多次创建。</p>
<p>所以，为了避免线程安全问题，针对于懒汉式单例，我们还得进行一些改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;   <span class="comment">//方法必须添加synchronized关键字加锁</span></span><br><span class="line">    <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然多个线程要调用，那么我们就直接加一把锁，在方法上添加<code>synchronized</code>关键字即可，这样同一时间只能有一个线程进入了。虽然这样简单粗暴，但是在高并发的情况下，效率肯定是比较低的，我们来看看如何进行优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;    <span class="comment">//实际上只需要对赋值这一步进行加锁即可</span></span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过这样还不完美，因为这样还是有可能多个线程同时判断为<code>null</code>而进入等锁的状态，所以，我们还得加一层内层判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  <span class="comment">//内层还要进行一次检查，双重检查锁定</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过我们还少考虑了一样内容，其实IDEA此时应该是给了黄标了：</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/I9PAi6HRbyMNsJn.png" alt="image-20230301111754155"></p>
<p>可以看到，这种情况下，IDEA会要求我们添加一个<code>volatile</code>给<code>INSTANCE</code>，各位还记得这个关键字有什么作用吗？没错，我们还需要保证<code>INSTANCE</code>在线程之间的可见性，这样当其他线程进入之后才会拿<code>INSTANCE</code>由其他线程更新的最新值去判断，这样，就差不多完美了。</p>
<p>那么，有没有一种更好的，不用加锁的方式也能实现延迟加载的写法呢？我们可以使用静态内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;   <span class="comment">//由静态内部类持有单例对象，但是根据类加载特性，我们仅使用Singleton类时，不会对静态内部类进行初始化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;   <span class="comment">//只有真正使用内部类时，才会进行类初始化</span></span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;   <span class="comment">//直接获取内部类中的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式显然是最完美的懒汉式解决方案，没有进行任何的加锁操作，也能保证线程安全，不过要实现这种写法，跟语言本身也有一定的关联，并不是所有的语言都支持这种写法。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式实际上与对象的拷贝息息相关，原型模式使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。也就是说，原型对象作为模板，通过克隆操作，来产生更多的对象，就像细胞的复制一样。</p>
<p>开始之前，我们先介绍一下对象的深拷贝和浅拷贝，首先我们来看浅拷贝：</p>
<ul>
<li><p><strong>浅拷贝：</strong>对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象，拷贝个基莫。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;  <span class="comment">//基本类型浅拷贝</span></span><br><span class="line">    System.out.println(a == b);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">k</span> <span class="operator">=</span> o;    <span class="comment">//引用类型浅拷贝，拷贝的仅仅是对上面对象的引用</span></span><br><span class="line">    System.out.println(o == k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>深拷贝：</strong>无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。</p>
</li>
</ul>
<p>在Java中，我们就可以使用Cloneable接口提供的拷贝机制，来实现原型模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;   <span class="comment">//注意需要实现Cloneable接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;   <span class="comment">//提升clone方法的访问权限</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来看看克隆的对象是不是原来的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> (Student) student0.clone();</span><br><span class="line">    System.out.println(student0);</span><br><span class="line">    System.out.println(student1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，通过<code>clone()</code>方法克隆的对象并不是原来的对象，我们来看看如果对象内部有属性会不会一起进行克隆：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    </span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> (Student) student0.clone();</span><br><span class="line">    System.out.println(student0.getName() == student1.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然Student对象成功拷贝，但是其内层对象并没有进行拷贝，依然只是对象引用的复制，所以Java为我们提供的<code>clone</code>方法只会进行浅拷贝。那么如何才能实现深拷贝呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;   <span class="comment">//这里我们改进一下，针对成员变量也进行拷贝</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) <span class="built_in">super</span>.clone();</span><br><span class="line">    student.name = <span class="keyword">new</span> <span class="title class_">String</span>(name);</span><br><span class="line">    <span class="keyword">return</span> student;   <span class="comment">//成员拷贝完成后，再返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就实现了深拷贝。</p>
<h2 id="设计模式（结构型）"><a href="#设计模式（结构型）" class="headerlink" title="设计模式（结构型）"></a>设计模式（结构型）</h2><p>结构型设计模式关注如何将现有的类或对象组织在一起形成更加强大的结构。并且根据我们前面学习的合成复用原则，我们该如何尽可能地使用关联关系来代替继承关系是我们本版块需要重点学习的内容。</p>
<h3 id="类-对象适配器模式"><a href="#类-对象适配器模式" class="headerlink" title="类&#x2F;对象适配器模式"></a>类&#x2F;对象适配器模式</h3><p>在生活中，我们经常遇到这样的一个问题：笔记本太轻薄了，以至于没有RJ45网口和USB A口（比如Macbook为了轻薄甚至全是type-c形式的雷电口）但是现在我们因为工作需要，又得使用这些接口来连接线缆，这时我们想到的第一个解决方案，就是去买一个转接口（扩展坞），扩展坞可以将type-c口转换为其他类型的接口供我们使用，实际上这就是一种适配模式。</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/5HkWt8fhwIZCxPE.png" alt="image-20230301111837481"></p>
<p>由于我们的电脑没有这些接口，但是提供了type-c类型的接口，虽然接口类型不一样，但是同样可以做其他接口能做的事情，比如USB文件传输、有线网络连接等，所以，这个时候，我们只需要添加一个中间人来帮我们转换一下接口形态即可。包括我们常用的充电头，为什么叫电源适配器呢？我们知道传统的供电是220V交流电，但是我们的手机可能只需要5V的电压进行充电，虽然现在有电，但是不能直接充，我们也不可能让电力公司专门为我们提供一个5V的直流电使用。这时电源适配器就开始发挥作用了，比如苹果的祖传5V1A充电头，实际上就是将220V交流电转换为5V的直流电进行传输，这样就相当于在220V交流电和我们的手机之前，做了一个适配器的角色。</p>
<p>在我们的Java程序中，也会经常遇到这样的问题，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSupplier</span> &#123;   <span class="comment">//手机供应商</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doSupply</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;iPhone 14 Pro&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestSupplier</span> <span class="variable">supplier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestSupplier</span>();</span><br><span class="line">      	test( ? );   <span class="comment">//我们没有Target类型的手机供应商，只有其他的，那这里该填个啥</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Target target)</span>&#123;   <span class="comment">//现在我们需要调用test方法，但是test方法需要Target类型的手机供应商</span></span><br><span class="line">        System.out.println(<span class="string">&quot;成功得到：&quot;</span>+target.supply());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;    <span class="comment">//现在的手机供应商，并不是test方法所需要的那种类型</span></span><br><span class="line"></span><br><span class="line">    String <span class="title function_">supply</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，我们就可以使用适配器模式了，适配器模式分为类适配器和对象适配器，我们首先来看看如何使用类适配器解决这种问题，我们直接创建一个适配器类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAdapter</span> <span class="keyword">extends</span> <span class="title class_">TestSupplier</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;  </span><br><span class="line">  <span class="comment">//让我们的适配器继承TestSupplier并且实现Target接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">supply</span><span class="params">()</span> &#123;   <span class="comment">//接着实现supply方法，直接使用TestSupplier提供的实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.doSupply();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就得到了一个Target类型的实现类，并且同时采用的是TestSupplier提供的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">TestAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestAdapter</span>();</span><br><span class="line">    test(adapter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Target target)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;成功得到：&quot;</span>+target.supply());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，这种实现方式需要占用一个继承坑位，如果此时Target不是接口而是抽像类的话，由于Java不支持多继承，那么就无法实现了。同时根据合成复用原则，我们应该更多的通过合成的方式去实现功能，所以我们来看看第二种，也是用的比较多的一种模式，对象适配器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAdapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;   <span class="comment">//现在不再继承TestSupplier，仅实现Target</span></span><br><span class="line"></span><br><span class="line">    TestSupplier supplier;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestAdapter</span><span class="params">(TestSupplier supplier)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.supplier = supplier;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">supply</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.doSupply();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们就将对象以组合的形式存放在TestAdapter中，依然是通过存放的对象调用具体实现。</p>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>相信各位都去奶茶店买过奶茶，在购买奶茶的时候，店员首先会问我们，您需要什么类型的奶茶，比如我们此时点了一杯啵啵芋圆奶茶，接着店员会直接问我们需要大杯、中杯还是小杯，最后还会询问我们需要加什么配料，比如椰果、珍珠等，最后才会给我们制作奶茶。</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/ZAjo69kfFUuIJ52.png" alt="image-20230301111852891"></p>
<p>那么现在让你来设计一下这种模式的Java类，该怎么做呢？首先我们要明确，一杯奶茶除了类型之外，还分大中小杯，甚至可能还分加什么配料，这个时候，如果我们按照接口实现的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Tea</span> &#123;   <span class="comment">//由具体类型的奶茶实现</span></span><br><span class="line">    String <span class="title function_">getType</span><span class="params">()</span>;   <span class="comment">//不同的奶茶返回的类型不同</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Size</span> &#123;   <span class="comment">//分大杯小杯中杯</span></span><br><span class="line">    String <span class="title function_">getSize</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如现在我们创建一个新的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大杯芋圆啵啵奶茶</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LargeKissTea</span> <span class="keyword">implements</span> <span class="title class_">Tea</span>, Size&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;大杯&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;芋圆啵啵奶茶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这样设计起来还挺合理的，但是如果现在我们的奶茶品种多起来了，并且每种奶茶都有大中小杯，现在一共有两个维度需要考虑，那么我们岂不是得一个一个去创建这些类？甚至如果还要考虑配料，那么光创建类就得创建不知道多少个了。显然这种设计不太好，我们得换个方式。</p>
<p>这时，就可以使用我们的桥接模式了，现在我们面临的问题是，维度太多，不可能各种类型各种尺寸的奶茶都去创建一个类，那么我们就还是单独对这些接口进行简单的扩展，单独对不同的维度进行控制，但是如何实现呢？我们不妨将奶茶的类型作为最基本的抽象类，然后对尺寸、配料等属性进行桥接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractTea</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> Size size;   <span class="comment">//尺寸作为桥接属性存放在类中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractTea</span><span class="params">(Size size)</span>&#123;   <span class="comment">//在构造时需要知道尺寸属性</span></span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getType</span><span class="params">()</span>;   <span class="comment">//具体类型依然是由子类决定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过这个抽象类提供的方法还不全面，仅仅只有Tea的getType方法，我们还需要添加其他维度的方法，所以继续编写一个子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RefinedAbstractTea</span> <span class="keyword">extends</span> <span class="title class_">AbstractTea</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RefinedAbstractTea</span><span class="params">(Size size)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSize</span><span class="params">()</span>&#123;   <span class="comment">//添加尺寸维度获取方式</span></span><br><span class="line">        <span class="keyword">return</span> size.getSize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们只需要单独为Size创建子类即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Large</span> <span class="keyword">implements</span> <span class="title class_">Size</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;大杯&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们如果需要一个大杯的啵啵芋圆奶茶，只需要：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KissTea</span> <span class="keyword">extends</span> <span class="title class_">RefinedAbstractTea</span>&#123;   <span class="comment">//创建一个啵啵芋圆奶茶的子类</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">KissTea</span><span class="params">(Size size)</span> &#123;   <span class="comment">//在构造时需要指定具体的大小实现</span></span><br><span class="line">        <span class="built_in">super</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;啵啵芋圆奶茶&quot;</span>;   <span class="comment">//返回奶茶类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们就将两个维度拆开，可以分别进行配置了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">KissTea</span> <span class="variable">tea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KissTea</span>(<span class="keyword">new</span> <span class="title class_">Large</span>());</span><br><span class="line">    System.out.println(tea.getType());</span><br><span class="line">    System.out.println(tea.getSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过桥接模式，使得抽象和实现可以沿着各自的维度来进行变化，不再是固定的绑定关系。</p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式实际上就是将多个组件进行组合，让用户可以对它们进行一致性处理。比如我们的文件夹，一个文件夹中可以有很多个子文件夹或是文件：</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/MYPyj9edEOmNWwU.png" alt="image-20230301111907078"></p>
<p>它就像是一个树形结构一样，有分支有叶子，而组合模式则是可以对整个树形结构上的所有节点进行递归处理，比如我们现在希望将所有文件夹中的文件的名称前面都添加一个前缀，那么就可以使用组合模式。</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/FzeBOp53ojM4Sui.png" alt="image-20230301111916996"></p>
<p>组合模式的示例如下，这里我们就用文件和文件夹的例子来讲解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先创建一个组件抽象，组件可以包含组件，组件有自己的业务方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(Component component)</span>;    <span class="comment">//添加子组件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(Component component)</span>;   <span class="comment">//删除子组件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> index)</span>;   <span class="comment">//获取子组件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;   <span class="comment">//执行对应的业务方法，比如修改文件名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来编写两种实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Directory</span> <span class="keyword">extends</span> <span class="title class_">Component</span>&#123;   <span class="comment">//目录可以包含多个文件或目录</span></span><br><span class="line"></span><br><span class="line">    List&lt;Component&gt; child = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();   <span class="comment">//这里我们使用List来存放目录中的子组件</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        child.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        child.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> child.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        child.forEach(Component::test);   <span class="comment">//将继续调用所有子组件的test方法执行业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File</span> <span class="keyword">extends</span> <span class="title class_">Component</span>&#123;   <span class="comment">//文件就相当于是树叶，无法再继续添加子组件了</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();   <span class="comment">//不支持这些操作了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称修改成功！&quot;</span>+<span class="built_in">this</span>);   <span class="comment">//具体的名称修改操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们来测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Directory</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>();   <span class="comment">//新建一个外层目录</span></span><br><span class="line">    <span class="type">Directory</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>();   <span class="comment">//新建一个内层目录</span></span><br><span class="line">    outer.addComponent(inner);</span><br><span class="line">    outer.addComponent(<span class="keyword">new</span> <span class="title class_">File</span>());   <span class="comment">//在内层目录和外层目录都添加点文件，注意别导错包了</span></span><br><span class="line">    inner.addComponent(<span class="keyword">new</span> <span class="title class_">File</span>());</span><br><span class="line">    inner.addComponent(<span class="keyword">new</span> <span class="title class_">File</span>());</span><br><span class="line">    outer.test();    <span class="comment">//开始执行文件名称修改操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们对最外层目录进行操作后，会递归向下处理当前目录和子目录中所有的文件。</p>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>装饰模式就像其名字一样，为了对现有的类进行装饰。比如一张相片就一张纸，如果直接贴在墙上，总感觉少了点什么，但是我们给其添加一个好看的相框，就会变得非常对味。装饰模式的核心就在于不改变一个对象本身功能的基础上，给对象添加额外的行为，并且它是通过组合的形式完成的，而不是传统的继承关系。</p>
<p>比如我们现在有一个普通的功能类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;   <span class="comment">//顶层抽象类，定义了一个test方法执行业务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseImpl</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是业务方法&quot;</span>);   <span class="comment">//具体的业务方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过现在的实现类太单调了，我们来添加一点装饰上去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;   <span class="comment">//装饰者需要将装饰目标组合到类中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Base base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Base base)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.base = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        base.test();    <span class="comment">//这里暂时还是使用目标的原本方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorImpl</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span>&#123;   <span class="comment">//装饰实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecoratorImpl</span><span class="params">(Base base)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;    <span class="comment">//对原本的方法进行装饰，我们可以在前后都去添加额外操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;装饰方法：我是操作前逻辑&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.test();</span><br><span class="line">        System.out.println(<span class="string">&quot;装饰方法：我是操作后逻辑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就通过装饰模式对类的功能进行了扩展：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BaseImpl</span>();</span><br><span class="line">    <span class="type">Decorator</span> <span class="variable">decorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecoratorImpl</span>(base);  <span class="comment">//将Base实现装饰一下</span></span><br><span class="line">    <span class="type">Decorator</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecoratorImpl</span>(decorator);  <span class="comment">//装饰者还可以嵌套</span></span><br><span class="line"></span><br><span class="line">    decorator.test();</span><br><span class="line"></span><br><span class="line">    outer.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就实现了装饰模式。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式和装饰模式很像，初学者很容易搞混，所以这里我们得紧接着来讲解一下。首先请记住，当无法直接访问某个对象或访问某个对象存在困难时，我们就可以通过一个代理对象来间接访问。</p>
<p>实际上代理在我们生活中处处都存在，比如手机厂商要去销售手机，但是手机厂商本身没有什么渠道可以大规模地进行售卖，很难与这些消费者进行对接，这时就得交给代理商去进行出售，比如Apple在中国的直营店很少，但是在中国的授权经销商却很多，手机厂商通过交给旗下代理商的形式来进行更大规模的出售。比如我们经常要访问Github，但是直接连接会发现很难连的上，这时我们加了一个代理就可以轻松访问，也是在体现代理的作用。</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/4yRZix1FfvaYboj.png" alt="image-20230301111934493"></p>
<p>同时，代理类需要保证客户端使用的透明性，也就是说操作起来需要与原本的真实对象相同，比如我们访问Github只需要输入网址即可访问，而添加代理之后，也是使用同样的方式去访问Github，所以操作起来是一样的。包括Spring框架其实也是依靠代理模式去实现的AOP记录日志等。</p>
<p>比如现在有一个目标类，但是我们现在需要通过代理来使用它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubjectImpl</span> <span class="keyword">extends</span> <span class="title class_">Subject</span>&#123;  <span class="comment">//此类无法直接使用，需要我们进行代理</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是测试方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们为其建立一个代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">extends</span> <span class="title class_">Subject</span>&#123;   <span class="comment">//为了保证和Subject操作方式一样，保证透明性，也得继承</span></span><br><span class="line"></span><br><span class="line">    Subject target;   <span class="comment">//被代理的对象（甚至可以多重代理）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Proxy</span><span class="params">(Subject subject)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;   <span class="comment">//由代理去执行被代理对象的方法，并且我们还可以在前后添油加醋</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代理前绕方法&quot;</span>);</span><br><span class="line">        target.test();</span><br><span class="line">        System.out.println(<span class="string">&quot;代理后绕方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍一看，这不跟之前的装饰模式一模一样吗？</p>
<p>对装饰器模式来说，装饰者和被装饰者都实现同一个接口&#x2F;抽象类。对代理模式来说，代理类和被代理的类都实现同一个接口&#x2F;抽象类，在结构上确实没有啥区别。但是他们的作用不同，装饰器模式强调的是增强自身，在被装饰之后你能够在被增强的类上使用增强后的功能，增强后你还是你，只不过被强化了而已；代理模式强调要让别人帮你去做事情，以及添加一些本身与你业务没有太多关系的事情（记录日志、设置缓存等）重点在于让别人帮你做。</p>
<p>装饰模式和代理模式的不同之处在于思想。</p>
<p>当然实现代理模式除了我们上面所说的这种方式之外，我们还可以使用JDK为我们提供的动态代理机制，我们不再需要手动编写继承关系创建代理类，它能够在运行时通过反射机制为我们自动生成代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;  <span class="comment">//JDK提供的动态代理只支持接口</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubjectImpl</span> <span class="keyword">implements</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是测试方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们需要创建一个动态代理的处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;    <span class="comment">//代理类，需要实现InvocationHandler接口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object object;   <span class="comment">//这里需要保存一下被代理的对象，下面需要用到</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestProxy</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//此方法就是调用代理对象的对应方法时会进入，这里我们就需要编写如何进行代理了</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">     		<span class="comment">//method就是调用的代理对象的哪一个方法，args是实参数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代理的对象：&quot;</span>+proxy.getClass());   <span class="comment">//proxy就是生成的代理对象了，我们看看是什么类型的</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(object, args);   <span class="comment">//在代理中调用被代理对象原本的方法，因为你是代理，还是得执行一下别人的业务，当然也可以不执行，但是这样就失去代理的意义了，注意要用上面的object</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法调用完成，返回值为：&quot;</span>+res);   <span class="comment">//看看返回值是什么</span></span><br><span class="line">        <span class="keyword">return</span> res;   <span class="comment">//返回返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们来看看如何创建一个代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SubjectImpl</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubjectImpl</span>();   <span class="comment">//被代理的大冤种</span></span><br><span class="line">    <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestProxy</span>(subject);</span><br><span class="line">    <span class="type">Subject</span> <span class="variable">proxy</span> <span class="operator">=</span> (Subject) Proxy.newProxyInstance(</span><br><span class="line">            subject.getClass().getClassLoader(),    <span class="comment">//需要传入被代理的类的类加载器</span></span><br><span class="line">            subject.getClass().getInterfaces(),    <span class="comment">//需要传入被代理的类的接口列表</span></span><br><span class="line">            handler);    <span class="comment">//最后传入我们实现的代理处理逻辑实现类</span></span><br><span class="line">    proxy.test();    <span class="comment">//比如现在我们调用代理类的test方法，那么就会进入到我们上面TestProxy中invoke方法，走我们的代理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行一次，可以看到调用代理类的方法，最终会走到我们的invoke方法中进行：</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/RipPFu3Q6Y5Idel.png" alt="image-20230301112001604"></p>
<p>根据接口，代理对象是<code>com.sun.proxy.$Proxy0</code>类（看名字就知道不对劲），这个类是动态生成的，我们也找不到具体的源代码。</p>
<p>不过JDK提供的动态代理只能使用接口，如果换成我们一开始的抽象类，就没办法了，这时我们可以使用一些第三方框架来实现更多方式的动态代理，比如Spring都在使用的CGLib框架，Maven依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于CGlib底层使用ASM框架（JVM篇视频教程有介绍）进行字节码编辑，所以能够实现不仅仅局限于对接口的代理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;  <span class="comment">//首先还是编写我们的代理逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;   <span class="comment">//这些和之前JDK动态代理写法是一样的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//我们也是需要在这里去编写我们的代理逻辑</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;现在是由CGLib进行代理操作！&quot;</span>+o.getClass());</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, objects);   <span class="comment">//也是直接调用代理对象的方法即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来创建一下代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SubjectImpl</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubjectImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();   <span class="comment">//增强器，一会就需要依靠增强器来为我们生成动态代理对象</span></span><br><span class="line">    enhancer.setSuperclass(SubjectImpl.class);    <span class="comment">//直接选择我们需要代理的类型，直接不需要接口或是抽象类，SuperClass作为代理类的父类存在，这样我们就可以按照指定类型的方式去操作代理类了</span></span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">TestProxy</span>(subject));  <span class="comment">//设定我们刚刚编写好的代理逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="type">SubjectImpl</span> <span class="variable">proxy</span> <span class="operator">=</span> (SubjectImpl) enhancer.create();   <span class="comment">//直接创建代理类</span></span><br><span class="line"></span><br><span class="line">    proxy.test();   <span class="comment">//调用代理类的test方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，效果其实是差不多的：</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/Y1bHtnZTIoq8pBu.png" alt="image-20230301112013486"></p>
<p>可以看到代理类是<code>包名.SubjectImpl$$EnhancerByCGLIB$$47f6ed3a</code>，也是动态生成的一个类，所以我们无法去查看源码，不过此类是继承自我们指定的类型的。</p>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>你是否经历过类似的情况：今年计算机学院的奖学金评定工作开始了，由于你去年一不小心拿了个ACM的区域赛金牌，觉得自己又行了，于是也想参与到奖学金的争夺中，首先你的辅导员会通知你去打印你的获奖材料，然后你高高兴兴拿给辅导员之后，辅导员又给了你一张表，让你打印了之后填写一下，包括你的个人信息还有一些个人介绍，完成后，你本以为可以坐等发奖了，结果辅导员又跟你说我们评定还要去某某地方盖章，盖完章还要去找谁谁谁签字，最后还要参加一下答辩… 看着如此复杂的流程，你瞬间不想搞了。</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/y2wzFh1UWYmpgJX.png" alt="image-20230301112039165"></p>
<p>实际上我们生活中很多时候都是这样，可能在办一件事情的时候，由于部门职能的不同，你得各个部门到处跑，你肯定会抱怨一句，就不能有个人来统一一下吗，就不能在一个地方一起把事情都办了吗？这时，我们就可以用到外观模式了。</p>
<p>外观模式充分体现了迪米特法则。可能我们的整个项目有很多个子系统，但是我们可以在这些子系统的上面加一个门面（Facade）当我们外部需要与各个子系统交互时，无需再去直接使用各个子系统，而是与门面进行交互，再由门面与后面的各个子系统操作，这样，我们以后需要办什么事情，就统一找门面就行了。这样的好处是，首先肯定方便了代码的编写，统一找门面就行，不需要去详细了解子系统，并且，当子系统需要修改时，也只需要修改门面中的逻辑，不需要大面积的变动，遵循迪米特法则尽可能少的交互。</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/BylhOfcFtni29uQ.png" alt="image-20230301112103676"></p>
<p>比如现在我们设计了三个子系统，分别是排队、结婚、领证，正常情况下我们是需要分别去找这三个部门去完成的，但是现在我们通过门面统一来完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;排队&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结婚&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;领证&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在三个系统太复杂了，我们添加一个门面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">SubSystemA</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemA</span>();</span><br><span class="line">    <span class="type">SubSystemB</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemB</span>();</span><br><span class="line">    <span class="type">SubSystemC</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystemC</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">()</span>&#123;   <span class="comment">//红白喜事一条龙服务</span></span><br><span class="line">        a.test1();</span><br><span class="line">        b.test2();</span><br><span class="line">        c.test3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们只需要一个门面就能直接把事情办完了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Facade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Facade</span>();</span><br><span class="line">    facade.marry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用外观模式，我们就大大降低了类与类直接的关联程度，并且简化了流程。</p>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>最后我们来看看享元模式（Flyweight），那么这个”享元”代表什么意思呢？我们先来看看下面的问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现上面的例子中，两个字符串虽然长短不同，但是却包含了一段相同的部分，那么现在我们如果要对内存进行优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;efg&quot;</span>;   <span class="comment">//由于str1包含str2，所以我们可以去掉重复的部分，当需要原本的str1时，再合在一起</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;str1 = &quot;</span>+str2+str1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而享元模式就是这个思想，我们可以将那些重复出现的内容作为共享部分取出，这样当我们拥有大量对象时，我们把其中共同的部分抽取出来，由于提取的部分是多个对象共享只有一份，那么就可以减轻内存的压力。包括我们的围棋，实际上我们只需要知道棋盘上的各个位置是黑棋还是白棋，实际上没有毕业创建很多个棋子对象，我们只需要去复用一个黑棋和一个白棋子对象即可。</p>
<p>比如现在我们有两个服务，但是他们都需要使用数据库工具类来操作，实际上这个工具类没必要创建多个，我们这时就可以使用享元模式，让数据库工具类作为享元类，通过享元工厂来提供一个共享的数据库工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectDB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是数据库操作...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtilFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DBUtil</span> <span class="variable">UTIL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DBUtil</span>();   <span class="comment">//享元对象被存放在工厂中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DBUtil <span class="title function_">getFlyweight</span><span class="params">()</span>&#123;   <span class="comment">//获取享元对象</span></span><br><span class="line">        <span class="keyword">return</span> UTIL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后当我们需要使用享元对象时，直接找享元工厂要就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;   <span class="comment">//用户服务</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DBUtil</span> <span class="variable">util</span> <span class="operator">=</span> DBUtilFactory.getFlyweight();   <span class="comment">//通过享元工厂拿到DBUtil对象</span></span><br><span class="line">        util.selectDB();    <span class="comment">//该干嘛干嘛</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这只是简单的享元模式实现，实际上我们一开始举例的String类，也在使用享元模式进行优化，比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span> + <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">    System.out.println(str1 == str2);</span><br><span class="line">    System.out.println(str1 == str3);   <span class="comment">//猜猜这三个对象是不是都是同一个？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然我们这里定义了三个字符串，但是我们发现，这三个对象指向的都是同一个对象，这是为什么呢？实际上这正是Java语言实现了数据的共享，想要了解具体实现请前往JVM篇视频教程。</p>
<h2 id="设计模式（行为型）"><a href="#设计模式（行为型）" class="headerlink" title="设计模式（行为型）"></a>设计模式（行为型）</h2><p>前面我们已经学习了12种设计模式，分为两类：</p>
<ul>
<li>创建型：关注对象创建</li>
<li>结构型：关注类和对象的结构组织</li>
</ul>
<p>我们接着来看最后一种设计模式，也是最多的一种，行为型设计模式关注系统中对象之间的交互，研究系统在运行时对象之间的相互通信与协作，进一步明确对象的职责。</p>
<h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p>这种模式的使用场景较少，很少使用的一种设计模式，这里提一下就行。</p>
<p>解释器顾名思义，就是对我们的语言进行解释，根据不同的语义来做不同的事情，比如我们在SE中学习的双栈计算器，正是根据我们输入的算式，去进行解析，并根据不同的运算符来不断进行计算。</p>
<p>比如我们输入：1+2*3</p>
<p>那么计算器就会进行解析然后根据语义优先计算2*3的结果然后在计算1+6最后得到7，详细实现请参考JavaSE篇双栈计算器实现。</p>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>模板方法模式我们之前也见到过许多，我们先来看看什么是模板方法。</p>
<p>有些时候，我们的业务可能需要经历很多个步骤来完成，比如我们生病了在医院看病，首先是去门诊挂号，然后等待叫号，然后是去找医生看病，确定病因后，就根据医生的处方去前台开药，最后付钱。这一整套流程看似是规规矩矩的，但是在这其中，某些步骤并不是确定的，比如医生看病这一步，由于不同的病因，可能会进行不同的处理，最后开出来的药方也会不同，所以，整套流程中，有些操作是固定的，有些操作可能需要根据具体情况而定。</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/PjOsmFXyI2Cl3pU.png" alt="image-20230301112153648"></p>
<p>在我们的程序中也是如此，可能某些操作是固定的，我们就可以直接在类中对应方法进行编写，但是可能某些操作需要视情况而定，由不同的子类实现来决定，这时，我们就需要让这些操作由子类来延迟实现了。现在我们就需要用到模板方法模式。</p>
<p>我们先来写个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象诊断方法，因为现在只知道挂号和看医生是固定模式，剩下的开处方和拿药都是不确定的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractDiagnosis</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;今天头好晕，不想起床，开摆，先跟公司请个假&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;去医院看病了~&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1 &gt;&gt; 先挂号&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2 &gt;&gt; 等待叫号&quot;</span>);</span><br><span class="line">        <span class="comment">//由于现在不知道该开什么处方，所以只能先定义一下行为，然后具体由子类实现</span></span><br><span class="line">      	<span class="comment">//大致的流程先定义好就行</span></span><br><span class="line">        <span class="built_in">this</span>.prescribe();</span><br><span class="line">        <span class="built_in">this</span>.medicine();  <span class="comment">//开药同理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">prescribe</span><span class="params">()</span>;   <span class="comment">//开处方操作根据具体病症决定了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">medicine</span><span class="params">()</span>;   <span class="comment">//拿药也是根据具体的处方去拿</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们定义好了抽象方法，只是将具体的流程先定义出来了，但是部分方法需要根据实现决定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 感冒相关的具体实现子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ColdDiagnosis</span> <span class="keyword">extends</span> <span class="title class_">AbstractDiagnosis</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prescribe</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3 &gt;&gt; 一眼丁真，鉴定为假，你这不是感冒，纯粹是想摆烂&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">medicine</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4 &gt;&gt; 开点头孢回去吃吧&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就有了一个具体的实现类，并且由于看病的逻辑已经由父类定义好了，所以子类只需要实现需要实现的部分即可，这样我们就实现了简单的模板方法模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AbstractDiagnosis</span> <span class="variable">diagnosis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColdDiagnosis</span>();</span><br><span class="line">    diagnosis.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.itbaima.net/markdown/2023/03/01/IVyz42i1brvUWfl.png" alt="image-20230301112206668"></p>
<p>最后我们来看看在JUC中讲解AQS源码实现中出现的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;    <span class="comment">//AQS的锁释放操作</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;   <span class="comment">//可以看到这里调用了tryRelease方法，但是此方法并不是在AQS实现的，而是不同的锁自行实现，因为AQS也不知道你这种类型的锁到底该怎么去解锁</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();   <span class="comment">//AQS中不支持，需要延迟到具体的子类去实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板方法模式，实际上部分功能的实现是在子类完成的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;   </span><br><span class="line">  <span class="comment">//ReentrantLock中的AQS Sync实现类，对tryRelease方法进行了具体实现</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是现在感觉，这种层层套娃的写法，好像并不是这些大佬故意为了装逼才这样写的，而是真的在遵守规范编写，让代码更易懂一些，甚至你现在再回去推一遍会发现思路非常清晰。当然，除了这里之外，还有很多框架都使用了模板方法模式来设计类结构，还请各位小伙伴自行探索。</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>责任链模式也非常好理解，比如我们的钉钉审批，实际上就是一条流水线一样的操作，由你发起申请，然后经过多个部门主管审批，最后才能通过，所以你的申请表相当于是在一条责任链上传递。当然除了这样的直线型责任链之外，还有环形、树形等。</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/l4C6SmDYKb2QeTi.png" alt="image-20230301112223069"></p>
<p>实际上我们之前也遇到过很多种责任链，比如JavaWeb中学习的Filter过滤器，正是采用的责任链模式，通过将请求一级一级不断向下传递，来对我们所需要的请求进行过滤和处理。</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/gO5IUmS17tQouAh.png" alt="image-20230301112235576"></p>
<p>这里我们就使用责任链模式来模拟一个简单的面试过程，我们面试也是一面二面三面这样走的流程，这里我们先设计一下责任链上的各个处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Handler successor;    <span class="comment">//这里我们就设计责任链以单链表形式存在，这里存放后继节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Handler <span class="title function_">connect</span><span class="params">(Handler successor)</span>&#123;     <span class="comment">//拼接后续节点</span></span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">        <span class="keyword">return</span> successor;  <span class="comment">//这里返回后继节点，方便我们一会链式调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.doHandle();   <span class="comment">//由不同的子类实现具体处理过程</span></span><br><span class="line">        Optional</span><br><span class="line">                .ofNullable(successor)</span><br><span class="line">                .ifPresent(Handler::handle);    <span class="comment">//责任链上如果还有后继节点，就继续向下传递</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doHandle</span><span class="params">()</span>;   <span class="comment">//结合上节课学习的模板方法，交给子类实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为面试有很多轮，所以我们这里创建几个处理器的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;   <span class="comment">//用于一面的处理器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHandle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============= 白马程序员一面 ==========&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1. 谈谈你对static关键字的理解？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2. 内部类可以调用外部的数据吗？如果是静态的呢？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3. hashCode()方法是所有的类都有吗？默认返回的是什么呢？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;以上问题会的，可以依次打在评论区&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;  <span class="comment">//二面</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHandle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============= 白马程序员二面 ==========&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1. 如果我们自己创建一个java.lang包并且编写一个String类，能否实现覆盖JDK默认的？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2. HashMap的负载因子有什么作用？变化规律是什么？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3. 线程池的运作机制是什么？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4. ReentrantLock公平锁和非公平锁的区别是什么？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;以上问题会的，可以依次打在评论区&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThirdHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHandle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============= 白马程序员三面 ==========&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1. synchronized关键字了解吗？如何使用？底层是如何实现的？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2. IO和NIO的区别在哪里？NIO三大核心组件？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3. TCP握手和挥手流程？少一次握手可以吗？为什么？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4. 操作系统中PCB是做什么的？运行机制是什么？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;以上问题会的，可以依次打在评论区&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就编写好了每一轮的面试流程，现在我们就可以构建一个责任链了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FirstHandler</span>();  <span class="comment">//一面首当其冲</span></span><br><span class="line">    handler</span><br><span class="line">            .connect(<span class="keyword">new</span> <span class="title class_">SecondHandler</span>())   <span class="comment">//继续连接二面和三面</span></span><br><span class="line">            .connect(<span class="keyword">new</span> <span class="title class_">ThirdHandler</span>());</span><br><span class="line">    handler.handle();   <span class="comment">//开始面试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后结果也是按照我们的责任链来进行的。</p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>大家有没有发现现在的家电都在趋向于智能化，通过一个中央控制器，我们就可以对家里的很多电器进行控制，比如国内做的比较好的小米智能家居系列，还有Apple的HomeKit等，我们只需要在一个终端上进行操作，就可以随便控制家里的电器。</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/SuaYPFW4kojctM6.png" alt="image-20230301112308454"></p>
<p>比如现在我们有很多的类，彩电、冰箱、空调、洗衣机、热水器等，既然现在我们要通过一个遥控器去控制他们，那么我们就需要将控制这些电器的指令都给设计好才行，并且还不能有太强的关联性。</p>
<p>所有的电器肯定需要通过蓝牙或是红外线接受遥控器发送的请求，所以所有的电器都是接收者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>;   <span class="comment">//具体行为，这里就写一个算了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们要控制这些电器，那么肯定需要一个指令才能控制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Command</span> &#123;   <span class="comment">//指令抽象，不同的电器有指令</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Command</span><span class="params">(Receiver receiver)</span>&#123;   <span class="comment">//指定此命令对应的电器（接受者）</span></span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.action();   <span class="comment">//执行命令，实际上就是让接收者开始干活</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们来安排一个遥控器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller</span> &#123;   <span class="comment">//遥控器只需要把我们的指令发出去就行了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(Command command)</span>&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如现在我们创建一个空调，那么它就是作为我们命令的接收者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirConditioner</span> <span class="keyword">implements</span> <span class="title class_">Receiver</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;空调已开启，呼呼呼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们创建一个开启空调的命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OpenCommand</span><span class="params">(AirConditioner airConditioner)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(airConditioner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们只需要通过遥控器发送出去就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AirConditioner</span> <span class="variable">airConditioner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AirConditioner</span>();   <span class="comment">//先创建一个空调</span></span><br><span class="line">    Controller.call(<span class="keyword">new</span> <span class="title class_">OpenCommand</span>(airConditioner));   <span class="comment">//直接通过遥控器来发送空调开启命令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，遥控器这个角色并不需要知道具体会执行什么，只需要发送命令即可，遥控器和电器的关联性就不再那么强了。</p>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器我们在JavaSE篇就已经讲解过了，迭代器可以说是我们学习Java语言的基础，没有迭代器，集合类的遍历就成了问题，正是因为有迭代器的存在，我们才能更加优雅的使用foreach语法。</p>
<p>回顾我们之前使用迭代器的场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : list) &#123;   <span class="comment">//使用foreach语法糖进行迭代，依次获取每一个元素</span></span><br><span class="line">        System.out.println(s);   <span class="comment">//打印一下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>);</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var2</span> <span class="operator">=</span> list.iterator();   <span class="comment">//实际上这里本质是通过List生成的迭代器来遍历我们每个元素的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var2.hasNext()) &#123;   <span class="comment">//判断是否还有元素可以迭代，没有就false</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String)var2.next();   <span class="comment">//通过next方法得到下一个元素，每调用一次，迭代器会向后移动一位</span></span><br><span class="line">        System.out.println(s);    <span class="comment">//打印一下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当我们使用迭代器对List进行遍历时，实际上就像一个指向列表头部的指针，我们通过不断向后移动指针来依次获取所指向的元素：</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/RjZSDFcPm4q7odM.png" alt="image-20230301112320947"></p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/B7P3OlIQz8wgTAR.png" alt="image-20230301112329551"></p>
<p>这里，我们依照JDK提供的迭代器接口（JDK已经为我们定义好了一个迭代器的具体相关操作），也来设计一个迭代器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayCollection</span>&lt;T&gt; &#123;    <span class="comment">//首先设计一个简单的数组集合，一会我们就迭代此集合内的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T[] array;   <span class="comment">//底层使用一个数组来存放数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ArrayCollection</span><span class="params">(T[] array)</span>&#123;   <span class="comment">//private掉，自己用</span></span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ArrayCollection&lt;T&gt; <span class="title function_">of</span><span class="params">(T[] array)</span>&#123;   <span class="comment">//开个静态方法直接吧数组转换成ArrayCollection，其实和直接new一样，但是这样写好看一点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayCollection</span>&lt;&gt;(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们就可以将数据存放在此集合中了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;DDD&quot;</span>&#125;;</span><br><span class="line">    ArrayCollection&lt;String&gt; collection = ArrayCollection.of(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们就可以来实现迭代器接口了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayCollection</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt;&#123;   <span class="comment">//实现Iterable接口表示此类是支持迭代的</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;    <span class="comment">//需要实现iterator方法，此方法会返回一个迭代器，用于迭代我们集合中的元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;   <span class="comment">//这里实现一个，注意别用静态，需要使用对象中存放的数组</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//这里我们通过一个指针表示当前的迭代位置</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;     <span class="comment">//判断是否还有下一个元素</span></span><br><span class="line">            <span class="keyword">return</span> cur &lt; array.length;   <span class="comment">//如果指针大于或等于数组最大长度，就不能再继续了</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;   <span class="comment">//返回当前指针位置的元素并向后移动一位</span></span><br><span class="line">            <span class="keyword">return</span> array[cur++];   <span class="comment">//正常返回对应位置的元素，并将指针自增</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，我们就可以对我们自己编写的一个简单集合类进行迭代了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;DDD&quot;</span>&#125;;</span><br><span class="line">    ArrayCollection&lt;String&gt; collection = ArrayCollection.of(arr);</span><br><span class="line">    <span class="keyword">for</span> (String s : collection) &#123;    <span class="comment">//可以直接使用foreach语法糖，当然最后还是会变成迭代器调用</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后编译出来的样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;DDD&quot;</span>&#125;;</span><br><span class="line">    ArrayCollection&lt;String&gt; collection = ArrayCollection.of(arr);</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var3</span> <span class="operator">=</span> collection.iterator();   <span class="comment">//首先获取迭代器，实际上就是调用我们实现的iterator方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String)var3.next();   <span class="comment">//直接使用next()方法不断向下获取</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就实现了一个迭代器来遍历我们的元素。</p>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>在早期，我们想要和别人进行语音聊天，一般都是通过电话的方式，我们通过拨打他人的电话号码，来建立会话，不过这样有一个问题，比如我现在想要通知通知3个人某件事情，那么我就得依次给三个人打电话，甚至还会遇到一种情况，就是我们没有某个人的电话号码，但是其他人有，这时还需要告知这个人并进行转告，就很麻烦。</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/UoChEBnujTDMGpF.png" alt="image-20230301112503997"></p>
<p>但是现在我们有了Facetime、有了微信，我们可以同时让多个人参与到群通话中进行群聊，这样我们就不需要一个一个单独进行通话或是转达了。实际上正是依靠了一个中间商给我们提供了进行群体通话的平台，我们才能实现此功能，而这个平台实际上就是一个中间人。又比如我们想要去外面租房，但是我们怎么知道哪里有可以租的房子呢？于是我们就会上各大租房APP上去找房源，同样的，如果我们现在有房子需要出租，我们也不知道谁会想要租房子，同样的我们也会把房子挂在租房APP上展示，而当我们去租房时或是出租时，就会有一个称为中介的人来跟我们对接，实际上也是一种中介的模式。</p>
<p>在我们的程序中，可能也会出现很多的对象，但是这些对象之间的相互调用关系错综复杂，可能一个对象要做什么事情就得联系好几个对象：</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/Pobq2ZB1dyExNs9.png" alt="image-20230301112515239"></p>
<p>但是如果我们在这中间搞一个中间人：</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/fru13VTnkDS2y4v.png" alt="image-20230301112526146"></p>
<p>这样当我们要联系其他人时，一律找中介就可以了，中介存储了所有人的联系方式，这样就不会像上面一样乱成一团了。这里我们就以房产中介的例子来编写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;   <span class="comment">//房产中介</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, User&gt; userMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();   <span class="comment">//在出售的房子需要存储一下</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String address, User user)</span>&#123;   <span class="comment">//出售房屋的人，需要告诉中介他的房屋在哪里</span></span><br><span class="line">        userMap.put(address, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(String address)</span>&#123;   <span class="comment">//通过此方法来看看有没有对应的房源</span></span><br><span class="line">        <span class="keyword">return</span> userMap.get(address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着就是用户了，用户有两种角色，一种是租房，一种是出租：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;   <span class="comment">//用户可以是出售房屋的一方，也可以是寻找房屋的一方</span></span><br><span class="line">    String name;</span><br><span class="line">    String tel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, String tel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.tel = tel;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(String address, Mediator mediator)</span>&#123;   <span class="comment">//找房子的话，需要一个中介和你具体想找的地方</span></span><br><span class="line">        <span class="keyword">return</span> mediator.find(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&quot; (电话：&quot;</span>+tel+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们来测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;刘女士&quot;</span>, <span class="string">&quot;10086&quot;</span>);   <span class="comment">//出租人</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李先生&quot;</span>, <span class="string">&quot;10010&quot;</span>);   <span class="comment">//找房人</span></span><br><span class="line">    <span class="type">Mediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mediator</span>();   <span class="comment">//我是黑心中介</span></span><br><span class="line"></span><br><span class="line">    mediator.register(<span class="string">&quot;成都市武侯区天府五街白马程序员&quot;</span>, user0);   <span class="comment">//先把房子给中介挂上去</span></span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> user1.find(<span class="string">&quot;成都市武侯区天府五街下硅谷&quot;</span>, mediator);  <span class="comment">//开始找房子</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>) System.out.println(<span class="string">&quot;没有找到对应的房源&quot;</span>);</span><br><span class="line"></span><br><span class="line">    user = user1.find(<span class="string">&quot;成都市武侯区天府五街白马程序员&quot;</span>, mediator);  <span class="comment">//开始找房子</span></span><br><span class="line">    System.out.println(user);   <span class="comment">//成功找到对应房源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中介者模式优化了原有的复杂多对多关系，而是将其简化为一对多的关系，更容易理解一些。</p>
<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><blockquote>
<p>2021年10月1日下午，河南驻马店的一名13岁女中学生，因和同学发生不愉快喝下半瓶百草枯。</p>
<p>10月5日，抢救四天情况恶化，家属泣不成声称“肺部一个小时一变”。</p>
<p>10月6日下午，据武警河南省总队医院消息，“目前女孩仍在医院救治。”</p>
</blockquote>
<p>喝下百草枯，会给你后悔的时间，但是不会给你后悔的机会（百草枯含有剧毒物质，会直接导致肺部纤维化，这是不可逆的，一般死亡过程在一周左右，即使家里花了再多的钱，接受了再多的治疗，也无法逆转这一过程）相信如果再给这位小女孩一次机会，回到拿起百草枯的那一刻，一定不会再冲动地喝下了吧。</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/PnkvjD7GORWNCaZ.png" alt="image-20230301112608808"></p>
<p>备忘录模式，就为我们的软件提供了一个可回溯的时间节点，可能我们程序在运行过程中某一步出现了错误，这时我们就可以回到之前的某个被保存的节点上重新来过（就像艾克的大招），我们平时编辑文本的时候，当我们编辑出现错误时，就需要撤回，而我们只需要按下<code>Ctrl+Z</code>就可以回到上一步，这样就大大方便了我们的文本编辑。</p>
<p>其实备忘录模式也可以应用到我们的程序中，如果你学习过安卓开发，安卓程序在很多情况下都会重新加载<code>Activity</code>，实际上安卓中<code>Activity</code>的<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>就是用到了备忘录模式，分别用于保存和恢复，这样就算重新加载也可以恢复到之前的状态。</p>
<p>这里我们就模拟一下对象的状态保存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String currentWork;   <span class="comment">//当前正在做的事情</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> percentage;   <span class="comment">//当前的工作完成百分比</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(String currentWork)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentWork = currentWork;</span><br><span class="line">        <span class="built_in">this</span>.percentage = <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我现在正在做：&quot;</span>+currentWork+<span class="string">&quot; (进度：&quot;</span>+percentage+<span class="string">&quot;%)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们需要保存它在某一时刻的状态，我们来编写一个状态保存类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> String currentWork;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> percentage;</span><br><span class="line"></span><br><span class="line">    State(String currentWork, <span class="type">int</span> percentage) &#123;   <span class="comment">//仅开放给同一个包下的Student类使用</span></span><br><span class="line">        <span class="built_in">this</span>.currentWork = currentWork;</span><br><span class="line">        <span class="built_in">this</span>.percentage = percentage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来将状态的保存和恢复操作都实现一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">State</span>(currentWork, percentage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restore</span><span class="params">(State state)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.currentWork = state.currentWork;</span><br><span class="line">        <span class="built_in">this</span>.percentage = state.percentage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们来测试一下吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student.work(<span class="string">&quot;学Java&quot;</span>);   <span class="comment">//开始学Java</span></span><br><span class="line">    System.out.println(student);</span><br><span class="line"></span><br><span class="line">    <span class="type">State</span> <span class="variable">savedState</span> <span class="operator">=</span> student.save();   <span class="comment">//保存一下当前的状态</span></span><br><span class="line"></span><br><span class="line">    student.work(<span class="string">&quot;打电动&quot;</span>);   <span class="comment">//刚打开B站播放视频，学一半开始摆烂了</span></span><br><span class="line">    System.out.println(student);</span><br><span class="line"></span><br><span class="line">    student.restore(savedState);   <span class="comment">//两级反转！回到上一个保存的状态</span></span><br><span class="line">    System.out.println(student);   <span class="comment">//回到学Java的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然在学习Java的过程中，中途摆烂了，但是我们可以时光倒流，回到还没开始摆烂的时候，继续学习Java：</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/ohGTRiEMYAay3zB.png" alt="image-20230301112626822"></p>
<p>不过备忘录模式为了去保存对象的状态，会占用大量的资源，尤其是那种属性很多的对象，我们需要合理的使用才能保证程序稳定运行。</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>牵一发而动全身，一幅有序摆放的多米诺骨牌，在我们推到第一个骨牌时，后面的骨牌会不断地被上一个骨牌推倒：</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/vZBkdeXEQrcTagV.png" alt="image-20230301112702467"></p>
<p>在Java中，一个对象的状态发生改变，可能就会影响到其他的对象，与之相关的对象可能也会联动的进行改变。还有我们之前遇到过的监听器机制，当具体的事件触发时，我们在一开始创建的监听器就可以执行相关的逻辑。我们可以使用观察者模式来实现这样的功能，当对象发生改变时，观察者能够立即观察到并进行一些联动操作，我们先定义一个观察者接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;   <span class="comment">//观察者接口</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;   <span class="comment">//当对象有更新时，会回调此方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来写一个支持观察者的实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Observer&gt; observerSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">observe</span><span class="params">(Observer observer)</span> &#123;   <span class="comment">//添加观察者</span></span><br><span class="line">        observerSet.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span> &#123;   <span class="comment">//模拟对象进行修改</span></span><br><span class="line">        observerSet.forEach(Observer::update);   <span class="comment">//当对象发生修改时，会通知所有的观察者，并进行方法回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们就可以测试一下了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line">    subject.observe(() -&gt; System.out.println(<span class="string">&quot;我是一号观察者！&quot;</span>));</span><br><span class="line">    subject.observe(() -&gt; System.out.println(<span class="string">&quot;我是二号观察者！&quot;</span>));</span><br><span class="line">    subject.modify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就简单实现了一下观察者模式，当然JDK也为我们提供了实现观察者模式相关的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;    <span class="comment">//java.util包下提供的观察者抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;   <span class="comment">//继承此抽象类表示支持观察者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对对象进行修改！&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setChanged();    <span class="comment">//当对对象修改后，需要setChanged来设定为已修改状态</span></span><br><span class="line">        <span class="built_in">this</span>.notifyObservers(<span class="keyword">new</span> <span class="title class_">Date</span>());   <span class="comment">//使用notifyObservers方法来通知所有的观察者</span></span><br><span class="line">      	<span class="comment">//注意只有已修改状态下通知观察者才会有效，并且可以给观察者传递参数，这里传递了一个时间对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来测试一下吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line">    subject.addObserver((o, arg) -&gt; System.out.println(<span class="string">&quot;监听到变化，并得到参数：&quot;</span>+arg));  </span><br><span class="line">  	<span class="comment">//注意这里的Observer是java.util包下提供的</span></span><br><span class="line">    subject.modify();   <span class="comment">//进行修改操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>在标准大气压下，水在0度时会结冰变成固态，在0-100度之间时，会呈现液态，100度以上会变成气态，水这种物质在不同的温度下呈现出不同的状态，而我们的对象，可能也会像这样存在很多种状态，甚至在不同的状态下会有不同的行为，我们就可以通过状态模式来实现。</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/gyAHTPpVQ2c5Y3E.png" alt="image-20230301112716993"></p>
<p>我们来设计一个学生类，然后学生的学习方法会根据状态不同而发生改变，我们先设计一个状态枚举：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;   <span class="comment">//状态直接使用枚举定义</span></span><br><span class="line">    NORMAL, LAZY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来编写一个学生类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> State state;   <span class="comment">//使用一个成员来存储状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;   <span class="comment">//根据不同的状态，学习方法会有不同的结果</span></span><br><span class="line">            <span class="keyword">case</span> LAZY:</span><br><span class="line">                System.out.println(<span class="string">&quot;只要我不努力，老板就别想过上想要的生活，开摆！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NORMAL:</span><br><span class="line">                System.out.println(<span class="string">&quot;拼搏百天，我要上清华大学！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看，在不同的状态下，是否学习会出现不同的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student.setState(State.NORMAL);   <span class="comment">//先正常模式</span></span><br><span class="line">    student.study();</span><br><span class="line"></span><br><span class="line">    student.setState(State.LAZY);   <span class="comment">//开启摆烂模式</span></span><br><span class="line">    student.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态模式更加强调当前的对象所处的状态，我们需要根据对象不同的状态决定其他的处理逻辑。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>对面卡兹克打野被开了，我们是去打小龙还是打大龙呢？这就要看我们团队这一局的打法策略了。</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/3WAha1ZeQUTHvCi.png" alt="image-20230301112727567"></p>
<p>我们可以为对象设定一种策略，这样对象之后的行为就会按照我们在一开始指定的策略而决定了，看起来和前面的状态模式很像，但是，它与状态模式的区别在于，这种转换是“主动”的，是由我们去指定，而状态模式，可能是在运行过程中自动切换的。</p>
<p>其实策略模式我们之前也遇到过，比如线程池的拒绝策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),  <span class="comment">//这里不给排队</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());   <span class="comment">//当线程池无法再继续创建新任务时，我们可以自由决定使用什么拒绝策略</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">60</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    executor.execute(runnable);   <span class="comment">//连续提交两次任务，肯定塞不下，这时就得走拒绝了</span></span><br><span class="line">    executor.execute(runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们如果使用AbortPolicy，那么就是直接抛出异常：</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/j3NdO1tzHfBDAn7.png" alt="image-20230301112805739"></p>
<p>我们也可以使用其他的策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy());   <span class="comment">//使用DiscardOldestPolicy策略从队列中丢弃</span></span><br></pre></td></tr></table></figure>

<p>这种策略就会从等待队列中踢出一个之前的，不过我们这里的等待队列是没有容量的那种，所以会直接炸掉：</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/di5A9acmTXOuv2V.png" alt="image-20230301112814947"></p>
<p>至于具体原因，可以回去看看JUC篇视频教程。</p>
<p>再比如我们现在有一个排序类，但是根据不同的策略，会使用不同的排序方案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;   <span class="comment">//策略接口，不同的策略实现也不同</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Strategy</span> <span class="variable">SINGLE</span> <span class="operator">=</span> Arrays::sort;   <span class="comment">//单线程排序方案</span></span><br><span class="line">    <span class="type">Strategy</span> <span class="variable">PARALLEL</span> <span class="operator">=</span> Arrays::parallelSort;   <span class="comment">//并行排序方案</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] array)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们编写一个排序类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sorter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;   <span class="comment">//策略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] array)</span>&#123;</span><br><span class="line">        strategy.sort(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们就可以指定不同的策略进行排序了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Sorter</span> <span class="variable">sorter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sorter</span>();</span><br><span class="line">    sorter.setStrategy(Strategy.PARALLEL);    <span class="comment">//指定为并行排序方案</span></span><br><span class="line">    </span><br><span class="line">    sorter.sort(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>公园中存在多个景点，也存在多个游客，不同的游客对同一个景点的评价可能不同；医院医生开的处方单中包含多种药元素，査看它的划价员和药房工作人员对它的处理方式也不同，划价员根据处方单上面的药品名和数量进行划价，药房工作人员根据处方单的内容进行抓药，相对于处方单来说，划价员和药房工作人员就是它的访问者，不过访问者的访问方式可能会不同。</p>
<p><img src="https://image.itbaima.net/markdown/2023/03/01/Iws7kQE8Z6MCfNp.png" alt="image-20230301112827540"></p>
<p>在我们的Java程序中，也可能会出现这种情况，我们就可以通过访问者模式来进行设计。</p>
<p>比如我们日以继夜地努力，终于在某某比赛赢得了冠军，而不同的人对于这分荣誉，却有着不同的反应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prize</span> &#123;   <span class="comment">//奖</span></span><br><span class="line">    String name;   <span class="comment">//比赛名称</span></span><br><span class="line">    String level;    <span class="comment">//等级</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Prize</span><span class="params">(String name, String level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先定义一个访问者接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Prize prize)</span>;   <span class="comment">//visit方法来访问我们的奖项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是访问者相关的实现了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;   <span class="comment">//指导老师作为一个访问者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Prize prize)</span> &#123;   <span class="comment">//它只关心你得了什么奖以及是几等奖，这也关乎老师的荣誉</span></span><br><span class="line">        System.out.println(<span class="string">&quot;你得奖是什么奖？&quot;</span>+prize.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;你得了几等奖？&quot;</span>+prize.level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Boss</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span>&#123;    <span class="comment">//你的公司老板作为一个访问者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Prize prize)</span> &#123;   <span class="comment">//你的老板只关心这些能不能为公司带来什么效益，奖本身并不重要</span></span><br><span class="line">        System.out.println(<span class="string">&quot;你的奖项大么，能够为公司带来什么效益么？&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;还不如老老实实加班给我多干干，别去搞这些没用的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Classmate</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span>&#123;   <span class="comment">//你的同学也可以作为一个访问者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Prize prize)</span> &#123;   <span class="comment">//你的同学也关心你得了什么奖，不过是因为你是他的奖学金竞争对手，他其实并不希望你得奖</span></span><br><span class="line">        System.out.println(<span class="string">&quot;你得了&quot;</span>+prize.name+<span class="string">&quot;奖啊，还可以&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;不过这个奖没什么含金量，下次别去了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Family</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span>&#123;    <span class="comment">//你的家人也可以是一个访问者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Prize prize)</span> &#123;   <span class="comment">//你的家人并不是最关心你得了什么奖，而是先关心你自己然后才是奖项，他们才是真正希望你好的人。这个世界很残酷，可能你会被欺负得遍体鳞伤，可能你会觉得活着如此艰难，但是你的背后至少还有爱你的人，为了他们，怎能就此驻足。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;孩子，辛苦了，有没有好好照顾自己啊&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;你得了什么奖啊？&quot;</span>+prize.name+<span class="string">&quot;，很不错，要继续加油啊！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里我们就设计了四种访问者，但是不同的访问者对于某一件事务的处理可能会不同。访问者模式把数据结构和作用于结构上的操作解耦，使得操作集合可相对自由地演化，我们上面就是将奖项本身的属性和对于奖项的不同操作进行了分离。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
